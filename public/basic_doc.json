[
  {
    "name": "2D Drawing",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/",
    "members": [
      {
        "name": "DrawImage",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/drawimage-r20",
        "description": "Draws a texture on screen. The image rectangle will start at the specified coordinate and the image will be stretched to match the specified width and height.",
        "c_syntax": "void DrawImage( TEntity texture, int x, int y, int width, int height )",
        "cpp_syntax": "static void Draw::Image( const Texture& image, int x, int y, int width = -1, int height = -1 );",
        "example": "\n//Draws a texture on screen that comes with the leadwerks SDK.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawImage\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tTTexture texture = LoadTexture(\"abstract::door1.dds\");\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\n\t\t//Texture, x-position, y-position, width, height\n\t\tDrawImage(texture, 50, 50, 200, 400);\n\t\tDrawText (0,0,\"Simply drawing an image that comes with the SDK.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "DrawLine",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/drawline-r18",
        "description": "Draws a line on screen between coordinates 1 and 2.",
        "c_syntax": "void DrawLine( int x1, int y1, int x2, int y2 )",
        "cpp_syntax": "static void Draw::Line( int x1, int y1, int x2, int y2 )Example\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawLine\");\n\tGraphics(640,480);\n\tCreateWorld();\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tSetColor(Vec4(0)); // clear the screen (= BackBuffer = current buffer) with black\n\t\tClearBuffer();\n \n\t\tSetColor(Vec4(1)); // drawing color = white\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawLine(50, 50, 500, 300);\n\n\t\tDrawText (0,0,\"DrawLine",
        "example": "\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawLine\");\n\tGraphics(640,480);\n\tCreateWorld();\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tSetColor(Vec4(0)); // clear the screen (= BackBuffer = current buffer) with black\n\t\tClearBuffer();\n \n\t\tSetColor(Vec4(1)); // drawing color = white\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawLine(50, 50, 500, 300);\n\n\t\tDrawText (0,0,\"DrawLine example.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n "
      },
      {
        "name": "DrawRect",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/drawrect-r19",
        "description": "Draws a rectangle on screen.",
        "c_syntax": "void DrawRect( int x, int y, int width, int height )",
        "cpp_syntax": "static void Draw::Rect( int x, int y, int width, int height )",
        "example": "\n//Rectangles with increasing transparency / decreasing alpha.\n#include \"engine.h\"\n \nint drawrect(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawRect\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tconst int iRectangles = 12, offset = 32, size = 20;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tSetColor(Vec4(0)); // clear the screen (= BackBuffer = current buffer) with black\n\t\tClearBuffer();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\tfor(int i = 0;i <= iRectangles-1;i++)\n\t\t{\n\t\t\tSetColor(Vec4(1,1,1,1.0 - (float)i/iRectangles)); // drawing color\n\t\t\tDrawRect(offset+ i*offset,offset+ i*offset,size,size);\n\t\t}\n \n\t\tSetBlend(BLEND_NONE);\n\t\tDrawText (0,0,\"Rectangles with increasing transparency / decreasing alpha.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      },
      {
        "name": "DrawText",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/drawtext-r23",
        "description": "DrawText can draw whatever text you want at any screen position you would like.",
        "c_syntax": "void DrawText( int x, int y, str text, ... )C++:\nstatic int Draw::Text( int x, int y, const_str text, ... )Example\n//Draws text on screen\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawText\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\n\t\tDrawText (0,0,\"Drawing text example\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n\nThe provided DrawText wrapper function will allow you to accomplish drawing text as if you were using printf and is the preferred means of drawing text.\nHowever, when you pass a std::string to the function, you will need to use the c_str() method of the std::string class to pass a usable C-styled pointer to the function.std::string text = \"Hello, world!\";\nDrawText(0, 0, text.c_str());\nThe C API function is DrawText.\n\nC/C++ users can simply pass any non-string data type as part of the third parameter. In C++, you can use templates along with the std::stringstream class to convert any primitive types as well as build your strings.\n// C Example[code]DrawText( 0, 16, \"Hello, %s! I am %i years old!\", \"world\", 70);\n//",
        "cpp_syntax": "static int Draw::Text( int x, int y, const_str text, ... )Example\n//Draws text on screen\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawText\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\n\t\tDrawText (0,0,\"Drawing text example\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n\nThe provided DrawText wrapper function will allow you to accomplish drawing text as if you were using printf and is the preferred means of drawing text.\nHowever, when you pass a std::string to the function, you will need to use the c_str() method of the std::string class to pass a usable C-styled pointer to the function.std::string text = \"Hello, world!\";\nDrawText(0, 0, text.c_str());\nThe C API function is DrawText.\n\nC/C++ users can simply pass any non-string data type as part of the third parameter. In C++, you can use templates along with the std::stringstream class to convert any primitive types as well as build your strings.\n// C Example[code]DrawText( 0, 16, \"Hello, %s! I am %i years old!\", \"world\", 70);\n// C++",
        "example": "\n//Draws text on screen\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DrawText\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\n\t\tDrawText (0,0,\"Drawing text example\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      },
      {
        "name": "FontHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/fontheight-r27",
        "description": "Returns the maximum height of the current font. If no font has been loaded, the default font will be used.",
        "c_syntax": "int FontHeight( void )",
        "cpp_syntax": "int FontHeight( void )",
        "example": "\n//Getting the font height\n#include \"engine.h\"\n \nint fontheight(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Fontheight\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tchar text[] = \"Some text which's bounding box is being calculated.\";\n\tint textWidth = TextWidth(text);\n\tint textHeight = FontHeight();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tSetColor(0,0,0);\n\t\tClearBuffer();\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetColor(1,0,0);\n\t\tDrawRect(32,32,textWidth, textHeight);\n\t\tSetColor(1,1,1);\n\t\tSetBlend(BLEND_ALPHA);\n\t\tDrawText(32,32,\"%s\",text);\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}"
      },
      {
        "name": "FreeFont",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/freefont-r28",
        "description": "Frees the specified font from memory.",
        "c_syntax": "void FreeFont( TFont font )",
        "cpp_syntax": "void Font::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "LoadFont",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/loadfont-r24",
        "description": "Loads a font and returns a handle to it. Leadwerks Engine supports Font Studio fonts, which should be saved as a .dds and .ini file. E.g. when loading LoadFont(\"abstract::myfont\"), the engine will load a font from abstract::myfont.ini and abstract::myfont.dds. See the example page for more detailed information.",
        "c_syntax": "TFont LoadFont(str name)",
        "cpp_syntax": "Font::Font( const std::string& fontName ) ;\nFont::Font( const Font& font ) ;\nvirtual void Font::Create( const std::string& fontName ) ;",
        "example": "\n//\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Hello World With Custom Font\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tCameraClearColor(CreateCamera(),Vec4(0.8));\n \n\tSetFont(LoadFont(\"abstract::Arial12Shadow\"));\n \n\tSetColor(Vec4(1,0,0,1));\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\tDrawText(32,32,\"Hello World!\");\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "Plot",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/plot-r17",
        "description": "Draws a single pixel onscreen.",
        "c_syntax": "void Plot( int x, int y)",
        "cpp_syntax": "static void Draw::Plot( int x, int y )",
        "example": "\n//\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tfor(int i = 0;i < 360;i++)\n\t\t{\n\t\t\tPlot(32+i,200-100* sin(i*M_PI/180.0));\n\t\t}\n \n\t\tDrawText (0,0,\"Plot: sincurve with pixels\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      },
      {
        "name": "SetBlend",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/setblend-r22",
        "description": "Sets the drawing blend. The following values are allowed:BLEND_ALPHABLEND_LIGHTBLEND_SHADEBLEND_MOD2X",
        "c_syntax": "void SetBlend( int blendMode )",
        "cpp_syntax": null,
        "example": "\n//Draws rectangles with increasing transparency / decreasing alpha.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tconst int iRectangles = 12, offset = 32, size = 20;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tSetColor(Vec4(0)); // clear the screen (= BackBuffer = current buffer) with black\n\t\tClearBuffer();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\tfor(int i = 0;i <= iRectangles-1;i++)\n\t\t{\n\t\t\tSetColor(Vec4(1,1,1,1.0 - (float)i/iRectangles)); // drawing color\n\t\t\tDrawRect(offset+ i*offset,offset+ i*offset,size,size);\n\t\t}\n \n\t\tSetBlend(BLEND_NONE);\n\t\tDrawText (0,0,\"Rectangles with increasing transparency / decreasing alpha.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      },
      {
        "name": "SetColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/setcolor-r21",
        "description": "Sets the drawing color. SetColor changes the color of the pixels that the draw commands send to the screen (actually the back buffer). It uses a TVec4 value such as Vec4(1.0, 1.0, 1.0, 1.0). 0.0 would be 0 whereas 1.0 would be 255. So if you want to use the value 80 you have to divide it by 255.",
        "c_syntax": "void SetColor(TVec4 &color=Vec4(1))\nvoid SetColor(flt r, flt g, flt b, flt a=1)",
        "cpp_syntax": "static void Draw::SetColor( const TVec3& color )\nstatic void Draw::SetColor( const TVec4& color )\nstatic void Draw::SetColor( flt red, flt green, flt blue, flt alpha = 1.0f )",
        "example": "\n//Looping through all colors.\n#include \"engine.h\"\n#include <math.h>\n \nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tconst int offset = 32, size = 20;\n\tfloat green = 0.5;\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tSetColor(Vec4(0)); // clear the screen (= BackBuffer = current buffer) with black\n\t\tClearBuffer();\n \n\t\t// r and b are position based, g goes (sin wave shape) up and down from 0 to 1\n\t\tUpdateAppTime();\n\t\tgreen = sin(AppTime()/1000) * 0.5 + 0.5;\n \n\t\tfor(int x = 0;x < GraphicsWidth();x += offset)\n\t\t{\n\t\t\tfor(int y = 0;y < GraphicsHeight();y += offset)\n\t\t\t{\n\t\t\t\tSetColor( Vec4((float)x/GraphicsWidth(), green, (float)y/GraphicsHeight(), 1.0 ) );\n\t\t\t\tDrawRect(x,y,size,size);\n\t\t\t}\n\t\t}\n \n\t\tSetColor(Vec4(1));\n\t\tDrawText (0,0,\"Looping through all colors.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      },
      {
        "name": "SetFont",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/setfont-r25",
        "description": "Sets the font to use when drawing text.",
        "c_syntax": "void SetFont( TFont font )",
        "cpp_syntax": "void Font::Set( void )",
        "example": "\n//Load a font\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Hello World With Custom Font\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tCameraClearColor(CreateCamera(),Vec4(0.8));\n \n\tSetFont(LoadFont(\"abstract::Arial12Shadow\"));\n \n\tSetColor(Vec4(1,0,0,1));\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\tDrawText(32,32,\"Hello World!\");\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "TextWidth",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/2d-drawing/textwidth-r26",
        "description": "Returns the width in pixels the specified string would have if it was drawn with the current font.",
        "c_syntax": "int TextWidth(str text)",
        "cpp_syntax": "static int Draw::GetTextWidth( const_str text )",
        "example": "\n//Getting the text width\n#include \"engine.h\"\n \nint fontheight(void)\n{\n\tInitialize();\n\tSetAppTitle(\"TextWidth\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tchar text[] = \"Some text which's bounding box is being calculated.\";\n\tint textWidth = TextWidth(text);\n\tint textHeight = FontHeight();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tSetColor(0,0,0);\n\t\tClearBuffer();\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetColor(1,0,0);\n\t\tDrawRect(32,32,textWidth, textHeight);\n\t\tSetColor(1,1,1);\n\t\tSetBlend(BLEND_ALPHA);\n\t\tDrawText(32,32,\"%s\",text);\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}"
      }
    ]
  },
  {
    "name": "Animation",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/",
    "members": [
      {
        "name": "Animate",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/animate-r29",
        "description": "Animates an animated entity. The animation is interpolated between the nearest two keyframes, indicated by the frame parameter. The blend parameter can be used to control the strength of the animation effect. A blend value of 0.5 will interpolate halfway between the current orientation and the animation frame, while a blend value of 1.0 will use the animation frame with no blending. This can be used to mix different animations. Any entity in the hierarchy can be animated independently, so the legs of a character can use one animation while the upper body uses another.Important:This will only have an effect when used directly on a mesh or on an entity that has a mesh child entity (e.g. a Model). Important: The mesh must have a material specifying a \"mesh_..._skin.vert\" and \"mesh_shadow_skin.vert\" shader.",
        "c_syntax": "void Animate( TEntity entity, flt frame, flt blend=1, int sequence=0, int recursive=1 )",
        "cpp_syntax": "virtual void Entity::Animate( flt frame, flt blend, int sequence, const Recursion& recursion = RECURSIVE ) \nWhere recursion is either NONRECURSIVE or RECURSIVE",
        "example": "\n//Animates an entity\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n \n\t//Create a graphics context\n\tGraphics(800,600);\n \n\t//Create a world\n\tif (!CreateWorld()) {\n\t\tMessageBoxA(0,\"Error\",\"Failed to create world.\",0);\n\t\tgoto exitapp;\n\t}\n \n\t//Create a camera\n\tTCamera cam=CreateCamera();\n\tCameraClearColor(cam,Vec4(0,0,1,1));\n\tMoveEntity(cam,Vec3(0,0.85,-2));\n \n\t//Create a render buffer for lighting\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a spot light\n\tTLight light=CreateSpotLight();\n\tRotateEntity(light,Vec3(20,45,0));\n\tEntityColor(light,Vec4(2,2,2,1));\n\tMoveEntity(light,Vec3(0,0,-5));\n\tSetShadowmapSize(light,1024);\n\tAmbientLight(Vec3(0.1));\n \n\t//Load the animated mesh\n\tTMesh mesh=LoadMesh(\"crawler.gmf\");\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) {\n \n\t\t//Animate the mesh\n\t\tAnimate(mesh,AppTime()/100.0,1.0,true);\n \n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\t\tFlip();\n\t}\n \n\texitapp:\n\treturn Terminate();\n}"
      },
      {
        "name": "AnimationLength",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/animationlength-r33",
        "description": "Returns number of frames of the specified animation sequence.SyntaxC:\nint AnimationLength( TEntity entity, int sequence=0 )",
        "c_syntax": "int AnimationLength( TEntity entity, int sequence=0 )Syntax",
        "cpp_syntax": "int Entity::GetAnimationLength( int sequence=0 )",
        "example": "\n//\n"
      },
      {
        "name": "ClearAnimation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/clearanimation-r34",
        "description": "Clears all entity animation sequences.",
        "c_syntax": "void ClearAnimation( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n//\n"
      },
      {
        "name": "CountAnimations",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/countanimations-r32",
        "description": "Returns the number of animation sequences an entity has.",
        "c_syntax": "int CountAnimations( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n//\n"
      },
      {
        "name": "LoadAnimation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/animation/loadanimation-r31",
        "description": "Returns the index of the loaded animation sequence.",
        "c_syntax": "int LoadAnimation( TEntity entity, str path )",
        "cpp_syntax": null,
        "example": "\n//Loads an animation\n\n"
      }
    ]
  },
  {
    "name": "Application",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/",
    "members": [
      {
        "name": "AppLog",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/applog-r39",
        "description": "Writes text to the application log. The options parameter can be used to specify bitwise flags:A notification box containing the text is displayed.The text \"Warning: \" is added to the beginning of the line.",
        "c_syntax": "void AppLog( str text, int options=APPLOG_NORMAL )",
        "cpp_syntax": "void Engine::SetAppLog( const_str text, int flags=APPLOG_NORMAL)Example\n//The applog command adds text to the app log.\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppLog\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tAppLog(\"This is Text added via AppLogwith the 0 parameter\", 0);\n\tAppLog(\"This is Text added via AppLog with the 1 parameter\", 1);\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Applog",
        "example": "\n//The applog command adds text to the app log.\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppLog\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tAppLog(\"This is Text added via AppLogwith the 0 parameter\", 0);\n\tAppLog(\"This is Text added via AppLog with the 1 parameter\", 1);\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Applog Example\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "AppLogMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/applogmode-r40",
        "description": "If mode is set to 1 application logging is enabled, otherwise it is disabled. If application logging is disabled, calls to AppLog as well as internal log data will not be written to the log file or printed to the console.",
        "c_syntax": "void AppLogMode( int mode=1 )",
        "cpp_syntax": "void Engine::AppLogMode( int mode=1 )Example\n//The applogmode command enables or disables logging.\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppLogMode\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tAppLogMode(1);\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Applogmode",
        "example": "\n//The applogmode command enables or disables logging.\n#include \"engine.h\"\n  \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppLogMode\");\n\tGraphics(640,480);\n\tCreateWorld();\n\tAppLogMode(1);\n\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Applogmode Example\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "AppTerminate",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/appterminate-r38",
        "description": "Returns 1 if the user has pressed the close button at the top-right of a graphics window. It is recommended that this function be called once per program loop. This or any of the Mouse...() or Key...() commands has to be called once per loop in order to make the main application window work correctly (so that it responds to OS messages and can be moved/minimized).",
        "c_syntax": "int AppTerminate( void )",
        "cpp_syntax": "bool Engine::IsTerminated( void ) const",
        "example": "\n//Closes the program by clicking on the red cross.\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"AppTerminate\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!AppTerminate())\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Closes the program by clicking on the red cross.\");\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}"
      },
      {
        "name": "Initialize",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/initialize-r36",
        "description": "Initializes the engine and loads the dll and all the commands. Returns 1 if succeeded.",
        "c_syntax": "int Initialize(void)",
        "cpp_syntax": null,
        "example": "\n//Initialises the engine, returns 1 if succesful\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Initialise\");\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!AppTerminate())\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\t\t\n\t\tDrawText (0,0,\"Initialises the engine, returns 1 if succesful.\");\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetAppTitle",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/setapptitle-r37",
        "description": "Sets the application title that will appear on a graphics window. This command must be called before the graphics window is created.",
        "c_syntax": "void SetAppTitle( str title )",
        "cpp_syntax": "void Engine::SetTitle( const string& title )",
        "example": "\n//Set the application title\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"MyWindow\");\n\tGraphics(640,480);\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\t// Main loop goes here\n\t}\n \n\treturn Terminate();\n}"
      },
      {
        "name": "Terminate",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/application/terminate-r41",
        "description": "Shuts down the engine and unloads the dll. Returns 0 when succeeded.",
        "c_syntax": "int Terminate(void)",
        "cpp_syntax": null,
        "example": "\n//Terminate the program and unload the dll's\n#include \"engine.h\"\n\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tDrawText (0,0,\"Press space to terminate the programm.\");\n\t\tFlip();\n\t}\n\treturn Terminate();\n}"
      }
    ]
  },
  {
    "name": "Bodies",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/",
    "members": [
      {
        "name": "AddBodyForce",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/addbodyforce-r48",
        "description": "Adds a force to the body. If the global parameter is 0 the force will be added along the body's own axes. This can be used to make a car move forward regardless of its orientation.",
        "c_syntax": "void AddBodyForce( TBody body, TVec3 &force, int global=1 )",
        "cpp_syntax": "void Body::AddForce( const TVec3& force, const EntityTypes& types = Global )\nvoid Body::AddForce( flt x, flt y, flt z, const EntityTypes& types = Global )",
        "example": "\n#include \"engine.h\"\n \nvoid CreatePhyCube(float width, float height, float depth, TBody* outBody, TMesh* outMesh,const TMesh& basecube)\n{\n\t*outMesh = CopyEntity(basecube); ShowEntity(*outMesh);\n\tScaleEntity(*outMesh, Vec3(width, height, depth));\n \n\t*outBody = CreateBodyBox(width, height, depth);\n\tEntityParent(*outMesh, *outBody);\n \n\treturn;\n}\n \ninline float random(float min, float max)\n{\n\tfloat interval = max - min;\n\treturn min + interval * rand()/(float)RAND_MAX;\n}\n \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"AddBodyForce Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); HideEntity(basecube);\n \n\t// ground\n\tTEntity ground,groundphy;\n\tCreatePhyCube(50,50,50,&groundphy, &ground, basecube);\n\tMoveEntity\t (groundphy, Vec3(0,-26,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\t// objects\n\tTBody boxes[10];\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\t// create\n\t\tTEntity box;\n\t\tCreatePhyCube(1,1,1,&boxes[i], &box, basecube);\n \n\t\t// setup body\n\t\tSetBodyMass\t\t(boxes[i], 0.1);\n\t\tEntityType\t\t(boxes[i], 1,0);\n \n\t\t// move\n\t\tMoveEntity\t\t(boxes[i], Vec3(random(-0.1,0.1),i * 1.1f + 1.f,random(-0.1,0.1)));\n\t}\n \n\t// Enable collision between bodys of type 1\n\tCollisions(1,1,1);   \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t// update\n\t\tUpdateAppTime();\n \n\t\t// apply force\n\t\tif(KeyHit(KEY_SPACE))AddBodyForce(boxes[rand()%10],Vec3(30,0,30),1); \n\t\tif(KeyHit(KEY_ENTER))AddBodyForce(boxes[rand()%10],Vec3(0,0,30),0);\n \n\t\tUpdateWorld(1);\n \n\t\t// render\n\t\tSetBuffer(buffer);\n\t\tRenderWorld(ENTITY_ALL);\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to apply globally directed force to one of the boxes!\");\n\t\tDrawText(0,12, \"Press ENTER to apply locally directed force to one of the boxes!\");\n\t\t// end render\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}"
      },
      {
        "name": "AddBodyForceAtPoint",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/addbodyforceatpoint-r49",
        "description": "Adds force and torque to a body applied at a specific point.",
        "c_syntax": "void AddBodyForceAtPoint(TBody body, TVec3 &force, TVec3 &position)",
        "cpp_syntax": "void Body::AddForceAtPoint( const TVec3& force, const TVec3& position )\nvoid Body::AddForceAtPoint( flt fx, flt fy, flt fz , flt x, flt y, flt z )",
        "example": "\n#include \"engine.h\"\n#include <algorithm>\n#include <math.h>\n \n//   Globals\nTCamera Camera;\n \n// Functions\ninline void NormalizeVec3(TVec3& vector)\n{\n\tfloat length = (float)sqrt(vector.X*vector.X + vector.Y*vector.Y + vector.Z*vector.Z);\n \n\tvector.X /= length;\n\tvector.Y /= length;\n\tvector.Z /= length;\n}\n \ninline void pickedAddForce(const TPick& pick)\n{\n\tTBody body = GetParent(pick.entity);\n \n\tTVec3 campos = EntityPosition(Camera);\n\tTVec3 force = Vec3(pick.X-campos.X,pick.Y-campos.Y,pick.Z-campos.Z); // add a force away from the camera\n\tNormalizeVec3(force);\n\tforce.X *= 300.0f;\n\tforce.Y *= 300.0f;\n\tforce.Z *= 300.0f;\n\tAddBodyForceAtPoint(body,force,Vec3(pick.X,pick.Y,pick.Z));\n}\n \nvoid CreatePhyCube(float width, float height, float depth, TBody* outBody, TMesh* outMesh,const TMesh& basecube)\n{\n\t*outMesh = CopyEntity(basecube); ShowEntity(*outMesh);\n\tScaleEntity(*outMesh, Vec3(width, height, depth));\n \n\t*outBody = CreateBodyBox(width, height, depth);\n\tEntityParent(*outMesh, *outBody);\n \n\treturn;\n}\n \n// Main\nint main(void)\n{\n\t// Init\n\tInitialize();\n\tSetAppTitle(\"AddBodyForceAtPoint Demo\");\n\tGraphics(640,480);\n\tTEntity World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tCamera = CreateCamera();\t\t\t   \n\tMoveEntity  (Camera, Vec3(0,6,-5) );\n\tRotateEntity(Camera, Vec3(40,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight();\t   \n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// Cube, base for other cubes (so they can be instanced)\n\tTEntity basecube = CreateCube(); HideEntity(basecube);\n \n\t// Ground\n\tTEntity ground,groundphy;\n\tCreatePhyCube(40,50,40, &groundphy, &ground, basecube);\n\tMoveEntity(groundphy, Vec3(0,-26,0));\n\tEntityType(groundphy, 1); // physics type is 1 for both object classes\n\tEntityType(ground, 1);// mesh of type 1 = clickable\n \n\t//Boxes\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tTEntity cube,cubePhy;\n\t\tCreatePhyCube(1,1,1, &cubePhy, &cube, basecube);\n \n\t\tMoveEntity (cubePhy, Vec3(0,i,0));\n\t\tSetBodyMass(cubePhy, 1);\n\t\tEntityType (cubePhy, 1); // physics type is 1 for both object classes\n\t\tEntityType (cube, 2); // mesh of type 2 = clickable & dynamic\n\t}\n \n\t// Enable collision between bodys of type 1\n\tCollisions(1,1,1);\t\t \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t   \n\t{\n\t\t// Clicked a cube?\n\t\tif(MouseHit(1))\n\t\t{\n\t\t\tTPick picked;\n\t\t\tif(CameraPick(&picked, Camera, Vec3(MouseX(), MouseY(), 1000), 0, 0, 0))\n\t\t\t{\n\t\t\t\tswitch(GetEntityType(picked.entity)) // get the type of the picked mesh\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\t  // picked the floor, can't add forces to static objects\n\t\t\t\t\tbreak;\n \n\t\t\t\tcase 2:\n\t\t\t\t\t  pickedAddForce(picked);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Update\n\t\tUpdateWorld(1);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tDrawText(0,0,\"Click the cubes to push them!\");\n \n\t\tFlip\t   (1);\n\t}\n \n \n\treturn Terminate();\n}"
      },
      {
        "name": "AddBodyTorque",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/addbodytorque-r50",
        "description": "Adds torque to a body. If the global parameter is 0 the torque will be added along the body's own axes.",
        "c_syntax": "void AddBodyTorque( TBody body, TVec3 &torque, int global=1 )",
        "cpp_syntax": "void Body::AddTorque( const TVec3& torque, const EntityTypes& types = Global )\nvoid Body::AddTorque( flt x, flt y, flt z , const EntityTypes& types = Global )",
        "example": "\n//AddBodyTorque demo\n#include \"engine.h\"\n \nvoid CreatePhyCube(float width, float height, float depth, TBody* outBody, TMesh* outMesh,const TMesh& basecube)\n{\n\t*outMesh = CopyEntity(basecube); ShowEntity(*outMesh);\n\tScaleEntity(*outMesh, Vec3(width, height, depth));\n \n\t*outBody = CreateBodyBox(width, height, depth);\n\tEntityParent(*outMesh, *outBody);\n \n\treturn;\n}\n \ninline float random(float min, float max)\n{\n\tfloat interval = max - min;\n\treturn min + interval * rand()/(float)RAND_MAX;\n}\n \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"AddBodyTorque Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); HideEntity(basecube);\n \n\t// ground\n\tTEntity ground,groundphy;\n\tCreatePhyCube(50,50,50,&groundphy, &ground, basecube);\n\tMoveEntity\t (groundphy, Vec3(0,-26,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\t// objects\n\tTBody boxes[10];\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\t// create\n\t\tTEntity box;\n\t\tCreatePhyCube(1,1,1,&boxes[i], &box, basecube);\n \n\t\t// setup body\n\t\tSetBodyMass\t\t(boxes[i], 0.1);\n\t\tEntityType\t\t(boxes[i], 1,0);\n \n\t\t// move\n\t\tMoveEntity\t\t(boxes[i], Vec3(random(-0.1,0.1),i * 1.1f + 1.f,random(-0.1,0.1)));\n\t}\n \n\t// Enable collision between bodys of type 1\n\tCollisions(1,1,1);   \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t// update\n\t\tUpdateAppTime();\n \n\t\t// apply Torque\n\t\tif(KeyHit(KEY_SPACE))AddBodyTorque(boxes[rand()%10],Vec3(30,0,30),1); \n\t\tif(KeyHit(KEY_ENTER))AddBodyTorque(boxes[rand()%10],Vec3(0,0,30),0);\n \n\t\tUpdateWorld(1);\n \n\t\t// render\n\t\tSetBuffer(buffer);\n\t\tRenderWorld(ENTITY_ALL);\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to apply globally directed force to one of the boxes!\");\n\t\tDrawText(0,20, \"Press ENTER to apply locally directed force to one of the boxes!\");\n\t\t// end render\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "CalcBodyOmega",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/calcbodyomega-r52",
        "description": "Calculates the angular velocity required to make the body reach the specified rotation in one second, with no damping. This can be used for precise control of body movement.",
        "c_syntax": null,
        "cpp_syntax": null,
        "example": null
      },
      {
        "name": "CalcBodyVelocity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/calcbodyvelocity-r51",
        "description": "Calculates the velocity required to make the body reach the specified position in one second, with no damping. This can be used for precise control of body movement.",
        "c_syntax": "TVec3 CalcBodyVelocity( TBody body, TVec3 &position, flt smoothing=1 )",
        "cpp_syntax": null,
        "example": "\n\n\n"
      },
      {
        "name": "CreateBodyBox",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/createbodybox-r44",
        "description": "Creates a new box body.",
        "c_syntax": "TBody CreateBodyBox( flt width, flt height, flt depth, TEntity parent=NULL )",
        "cpp_syntax": "BodyBox::BodyBox( flt width, flt height, flt depth, const TEntity = 0 )\nvirtual void BodyBox::Create( flt width, flt height, flt depth, const TEntity = 0 )",
        "example": "\n//This programm creates 2 body boxes. A cube with mass and a plane.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Create a body box\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,1,1);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"A body box is created\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "CreateBodyCylinder",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/createbodycylinder-r45",
        "description": "Creates a new cylinder body.",
        "c_syntax": "TBody CreateBodyCylinder( flt radius=0.5f, flt height=1, TEntity parent=NULL )",
        "cpp_syntax": "BodyCylinder::BodyCylinder( flt radius, flt height, const TEntity = 0 )\nvirtual void BodyCylinder::Create( flt radius, flt height, const TEntity = 0 )",
        "example": "\n//This programm creates 1 body box and a body cylinder. \n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Create a body box\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body cylinder\n\tTBody\t\t\tcylinder = CreateBodyCylinder(1,5);\n\tSetBodyMass\t\t(cylinder, 10);\n\tEntityType\t\t(cylinder,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,1,1);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"A body cylinder is created\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}"
      },
      {
        "name": "CreateBodyHull",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/createbodyhull-r47",
        "description": "Creates a new convex hull body from the specified surface's geometry data. This body can be static or dynamic. The mesh has to be convex.",
        "c_syntax": "TBody CreateBodyHull(TSurface surf, TEntity parent=NULL)",
        "cpp_syntax": null,
        "example": "\n"
      },
      {
        "name": "CreateBodySphere",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/createbodysphere-r549",
        "description": null,
        "c_syntax": null,
        "cpp_syntax": null,
        "example": null
      },
      {
        "name": "CreateBodyTree",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/createbodytree-r46",
        "description": "Creates a new collision tree body (static only) from the specified surface's geometry data. This is an exact representation of the triangles in the surface.",
        "c_syntax": "TBody CreateBodyTree(TSurface surf, TEntity parent=NULL)",
        "cpp_syntax": null,
        "example": "\n"
      },
      {
        "name": "GetBodyMass",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/getbodymass-r66",
        "description": "Gets the body mass.",
        "c_syntax": "lt GetBodyMass( TBody body )",
        "cpp_syntax": "flt Body::GetMass( void )const",
        "example": "\n\n"
      },
      {
        "name": "GetBodyOmega",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/getbodyomega-r65",
        "description": "Gets the body omega (angular velocity). If the global parameter is 0 omega will be returned relative to the body's own axes.",
        "c_syntax": "TVec3 GetBodyOmega( TBody body, int global=1 )",
        "cpp_syntax": "TVec3 Body::GetOmega( const EntityTypes& type = Global ) const",
        "example": "\n\n"
      },
      {
        "name": "GetBodyVelocity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/getbodyvelocity-r64",
        "description": "Gets the body velocity. If the global parameter is 0 the velocity will be returned relative to the body's own axes.",
        "c_syntax": "TVec3 GetBodyVelocity( TBody body, int global=1 )",
        "cpp_syntax": "TVec3 Body::GetVelocity( const EntityTypes& type = Global ) const",
        "example": "\n\n"
      },
      {
        "name": "LoadBody",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/loadbody-r43",
        "description": "Loads a body from a serialized physics shape file.",
        "c_syntax": "TBody LoadBody( str path, TEntity parent=NULL )",
        "cpp_syntax": "Body::Body( const std::string& path, const TEntity = 0 )\nvirtual void Body::Load( const std::string& path, const TEntity = 0 )",
        "example": "\n//\n"
      },
      {
        "name": "SetBodyDamping",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodydamping-r56",
        "description": "Sets the damping value of a body. Damping slows the velocity and omega each frame by a small amount.",
        "c_syntax": "oid SetBodyDamping( TBody body, flt linearDamping=1, flt angularDamping=1 )",
        "cpp_syntax": "Body::SetDamping( flt linear_damping = 1.0f, flt angular_damping = 1.0f )",
        "example": "\n#include \"engine.h\"\n#include \"time.h\"\n \nint main(void)\n{\n\tsrand ( time(NULL) ); // To make the rand() more natural\n \n\tInitialize();\n\tGraphics\t (640,480, 0, 0, 0);\n \n\tTEntity\t   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\tMoveEntity\t(Camera, Vec3(0,20,-15) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\tTEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\tTEntity\t\t groundphy = CreateBodyBox(100,100,100,0);\n\tEntityParent   (ground,\tgroundphy,0);\n\tScaleEntity\t(ground,\tVec3(100,100,100));\n\tMoveEntity\t (groundphy, Vec3(0,-50,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\tTEntity cubePhy[10];\n\tfor(int i=1; i<=3; i++)\n\t{\n\t\tTEntity cube  = CreateCube(0);\t\t\t//Boxes\n\t\tcubePhy[i-1]  = CreateBodyBox(2,2,2,0);\n\t\tEntityParent   (cube,\tcubePhy[i-1],1);\n\t\tScaleEntity\t(cube,\tVec3(2,2,2));\n\t\tSweptCollision (cubePhy[i-1], 1);\n\t\tMoveEntity\t (cubePhy[i-1], Vec3(-8+i*4,1,0));\n\t\tSetBodyMass\t(cubePhy[i-1], 1);\n\t\tEntityType\t (cubePhy[i-1], 1,0);\n\t\tSetBodyDamping (cubePhy[i-1], 1-0.5*(i-1));\n\t}\n \n\tCollisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n \n \n\twhile(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t\t// Main Program\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tfor(int i=1; i<=3; i++)\n\t\t\t\tAddBodyForce(cubePhy[i-1],Vec3(0,0,1000),0);\t// Apply force\n\t\t}\n \n\t\tUpdateWorld(1);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n\t\tleDrawText (\"Damping (from left to right): 1, 0.5, 0\",0,0);\n\t\tleDrawText (\"Press SPACE to apply the same force to all boxes!\",0,20);\n\t\tleDrawText (\"The higher the damping-value, the faster the box stops.\",0,40);\n\t\tSetBlend   (0);\n\t\tFlip\t   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetBodyElasticity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodyelasticity-r58",
        "description": "Set the elasticity of a body to a value between 0 and 1, 1.0 being the maximum.",
        "c_syntax": "void SetBodyElasticity( TBody body, flt elasticity=1 )",
        "cpp_syntax": "void Body::SetElasticity( flt elasticity )",
        "example": "\n#include \"engine.h\"\n#include \"time.h\"\n \nint main(void)\n{\n\tsrand ( time(NULL) ); // To make the rand() more natural\n \n\tInitialize();\n\tGraphics\t (640,480);\n \n\tTEntity\t   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\tMoveEntity\t(Camera, Vec3(0,20,-15) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\tTEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\tTEntity\t\t groundphy = CreateBodyBox(100,100,100,0);\n\tEntityParent   (ground,\tgroundphy,0);\n\tScaleEntity\t(ground,\tVec3(100,100,100));\n\tMoveEntity\t (groundphy, Vec3(0,-50,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\tTEntity cubePhy[10];\n\tfor(int i=1; i<=3; i++)\n\t{\n\t\tTEntity cube  = CreateCube(0);\t\t\t//Boxes\n\t\tcubePhy[i-1]  = CreateBodyBox(2,2,2,0);\n\t\tEntityParent   (cube,\tcubePhy[i-1],1);\n\t\tScaleEntity\t(cube,\tVec3(2,2,2));\n\t\tSweptCollision (cubePhy[i-1], 1);\n\t\tMoveEntity\t (cubePhy[i-1], Vec3(-10+i*5,18,0));\n\t\tSetBodyMass\t(cubePhy[i-1], 1);\n\t\tEntityType\t (cubePhy[i-1], 1,0);\n\t\tSetBodyElasticity (cubePhy[i-1], 1-0.5*(i-1));\n\t}\n \n\tCollisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n \n \n\twhile(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t\t// Main Program\n\t{\n\t\tUpdateWorld(1);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n\t\tDrawText (0,0,\"Elasticity (from left to right): 1, 0.5, 0\");\n\t\tDrawText (0,20,\"The higher the 'Elasticity', the higher the amount of the force that is used for another 'jump'.\");\n\t\tSetBlend   (0);\n\t\tFlip\t   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetBodyForce",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodyforce-r63",
        "description": "Sets the body force (mass * acceleration). If the global parameter is 0 force will be set along the body's own axes.",
        "c_syntax": "void SetBodyForce( TBody body, TVec3 &force, int global=1 )",
        "cpp_syntax": "void Body::SetForce( const TVec3& force, const EntityTypes& type = Global )\nvoid Body::SetForce( flt x, flt y, flt z, const EntityTypes& type = Global )",
        "example": "\n\n"
      },
      {
        "name": "SetBodyFriction",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodyfriction-r60",
        "description": "Sets a body's friction.",
        "c_syntax": "void SetBodyFriction(TBody body, flt staticfriction=1, flt kineticfriction=1)",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n#include \"time.h\"\n \nint main(void)\n{\n\tsrand ( time(NULL) ); // To make the rand() more natural\n \n\tInitialize();\n\tGraphics\t (640,480, 0, 0, 0);\n \n\tTEntity\t   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\tMoveEntity\t(Camera, Vec3(0,20,-15) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\tTEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\tTEntity\t\t groundphy = CreateBodyBox(100,100,100,0);\n\tEntityParent   (ground,\tgroundphy,0);\n\tScaleEntity\t(ground,\tVec3(100,100,100));\n\tMoveEntity\t (groundphy, Vec3(0,-50,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\tTEntity cubePhy[10];\n\tfor(int i=1; i<=3; i++)\n\t{\n\t\tTEntity cube  = CreateCube(0);\t\t\t//Boxes\n\t\tcubePhy[i-1]  = CreateBodyBox(2,2,2,0);\n\t\tEntityParent   (cube,\tcubePhy[i-1],1);\n\t\tScaleEntity\t(cube,\tVec3(2,2,2));\n\t\tSweptCollision (cubePhy[i-1], 1);\n\t\tMoveEntity\t (cubePhy[i-1], Vec3(-8+i*4,1,0));\n\t\tSetBodyMass\t(cubePhy[i-1], 1);\n\t\tEntityType\t (cubePhy[i-1], 1,0);\n \n\t\tSetBodyFriction (cubePhy[i-1], 1-0.5*(i-1), 1-0.5*(i-1));\n\t}\n \n\tCollisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n \n \n\twhile(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t\t// Main Program\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tfor(int i=1; i<=3; i++)\n\t\t\t\tAddBodyForce(cubePhy[i-1],Vec3(0,0,1000),0);\t// Apply force\n\t\t}\n \n\t\tUpdateWorld(1);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n\t\tleDrawText (\"Friction (from left to right): 1, 0.5, 0\",0,0);\n\t\tleDrawText (\"Press SPACE to apply the same force to all boxes!\",0,20);\n\t\tleDrawText (\"The higher the friction-value, the faster the box stops (if it does at all).\",0,40);\n\t\tSetBlend   (0);\n\t\tFlip\t   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetBodyGravityMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodygravitymode-r55",
        "description": "Enables or disables body gravity. By default body gravity is enabled.",
        "c_syntax": "void SetBodyGravityMode( TBody body, int usegravity=1 )",
        "cpp_syntax": "void Body::SetGravityMode( bool usegravity = true )",
        "example": "\n\n\n"
      },
      {
        "name": "SetBodyMass",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodymass-r54",
        "description": "Sets the body mass (mass > 0 means that this body should be dynamic). If the mass is set to 0, the body will be static.",
        "c_syntax": "void SetBodyMass( TBody body, flt mass=1 )",
        "cpp_syntax": "void Body::SetMass( flt mass )",
        "example": "\n//This programm sets the body mass to 1 body in the scene, making it fall dawn.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Create a body box\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,1,1);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the body mass to a body. This will make it fall down.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetBodyMassCenter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodymasscenter-r57",
        "description": "Sets a body's center of mass. This is a local offset to the default center.",
        "c_syntax": "void SetBodyMassCenter( TBody body, TVec3 &center )",
        "cpp_syntax": "void Body::SetMassCenter( const TVec3& center )\nvoid Body::SetMassCenter( flt x, flt y, flt z )",
        "example": "\n#include \"engine.h\"\n \nvoid CreatePhyCube(float width, float height, float depth, TBody* outBody, TMesh* outMesh,const TMesh& basecube)\n{\n\t*outMesh = CopyEntity(basecube); ShowEntity(*outMesh);\n\tScaleEntity(*outMesh, Vec3(width, height, depth));\n \n\t*outBody = CreateBodyBox(width, height, depth);\n\tEntityParent(*outMesh, *outBody);\n \n\treturn;\n}\n \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"SetBodyMassCenter Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,5,-5) );\n\tRotateEntity  (Camera, Vec3(25,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); HideEntity(basecube);\n \n\t// ground\n\tTEntity ground,groundphy;\n\tCreatePhyCube(50,50,50,&groundphy, &ground, basecube);\n\tMoveEntity\t (groundphy, Vec3(26,-26,0));\n\tSetBodyMass\t(groundphy, 0);\n\tEntityType\t (groundphy, 1, 1);\n \n\t// objects\n\tTMesh baseMarker = CreateSphere(5); HideEntity(baseMarker);\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\t// create\n\t\tTEntity plank,plankPhy;\n\t\tCreatePhyCube(9,0.1,1,&plankPhy, &plank, basecube);\n \n\t\t// setup body\n\t\tSetBodyMass\t\t(plankPhy, 0.1);\n\t\tEntityType\t\t(plankPhy, 1,0);\n\t\tEntityColor\t\t(plank, Vec4(1.0f,0.0f,0.0f,0.0f));\n \n\t\t// setup center\n\t\tTVec3 centerPos = Vec3( 3 - i * 0.5,0,0);\n\t\tSetBodyMassCenter(plankPhy, centerPos);\n \n\t\t// center marker\n\t\tTMesh marker = CopyEntity(baseMarker); ShowEntity(marker);\n\t\tPositionEntity(marker, centerPos);\n\t\tEntityParent(marker, plankPhy);\n \n\t\t// move\n\t\tMoveEntity\t\t(plankPhy, Vec3(0,0.6,(10-i) * 2));\n\t}\n \n\t// Enable collision between bodys of type 1\n\tCollisions(1,1,1);   \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t// update\n\t\tUpdateAppTime();\n\t\tUpdateWorld(1);\n \n\t\t// render\n\t\tSetBuffer(buffer);\n\t\tRenderWorld(ENTITY_ALL);\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// text\n\t\tDrawText(0,0, \"Demonstrating different mass centers\");\n\t\t// end render\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetBodyOmega",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodyomega-r61",
        "description": "Sets the body omega (angular velocity). If the global parameter is 0 omega will be set along the body's own axes.",
        "c_syntax": "void SetBodyOmega( TBody body, TVec3 &omega, int global=1 )",
        "cpp_syntax": "void Body::SetOmega( const TVec3& omega, const EntityTypes& type = Global )\nvoid Body::SetOmega( flt x, flt y, flt z, const EntityTypes& type = Global )",
        "example": "\n\n"
      },
      {
        "name": "SetBodySoftness",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodysoftness-r59",
        "description": "Sets a body's softness.",
        "c_syntax": "void SetBodySoftness(TBody body, flt softness=1)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetBodyTorque",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/setbodytorque-r62",
        "description": "Sets the body torque. If the global parameter is 0 torque will be set along the body's own axes.",
        "c_syntax": "void SetBodyTorque( TBody body, TVec3 &torque, int global=1 )",
        "cpp_syntax": "void Body::SetTorque( const TVec3& torque, const EntityTypes& type = Global )\nvoid Body::SetTorque( flt x, flt y, flt z, const EntityTypes& type = Global )",
        "example": "\n\n"
      },
      {
        "name": "SweptCollision",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/bodies/sweptcollision-r53",
        "description": "Sets the body swept collision mode. Enabling swept collision is slower, but it can prevent small or thin bodies from penetrating other bodies or falling through the floor.",
        "c_syntax": "void SweptCollision( TBody body, int mode=1 )",
        "cpp_syntax": "void Body::SetSweptCollision( bool mode = true )",
        "example": "\n\n\n"
      }
    ]
  },
  {
    "name": "Buffers",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/",
    "members": [
      {
        "name": "BackBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/backbuffer-r82",
        "description": "Returns the default Leadwerks back buffer.",
        "c_syntax": "TBuffer BackBuffer( void )",
        "cpp_syntax": "Buffer Window::GetBackBuffer( void )",
        "example": "\n\n"
      },
      {
        "name": "BufferHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/bufferheight-r79",
        "description": "",
        "c_syntax": "int BufferHeight( TBuffer buffer )",
        "cpp_syntax": "int Buffer::GetHeight( void ) const",
        "example": "\n\n"
      },
      {
        "name": "BufferWidth",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/bufferwidth-r78",
        "description": "Returns width of the specified buffer.",
        "c_syntax": "int BufferWidth( TBuffer buffer )",
        "cpp_syntax": "int Buffer::GetWidth( void ) const",
        "example": "\n\n"
      },
      {
        "name": "ClearBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/clearbuffer-r72",
        "description": "Clears the current buffer. The components can be any combination of the following:BUFFER_DEPTHBUFFER_NORMALBUFFER_COLOR, BUFFER_COLOR0BUFFER_COLOR1BUFFER_COLOR2",
        "c_syntax": "void ClearBuffer( int components=BUFFER_COLOR\nvoid Buffer::Clear( int components=BUFFER_DEPTH",
        "cpp_syntax": "void Buffer::Clear( int components=BUFFER_DEPTH",
        "example": "\nClears the back buffer with red resulting in a red window:\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics(640, 480);\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tSetColor(Vec4(1,0,0,1));\n\t\tClearBuffer();\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n\n"
      },
      {
        "name": "CopyBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/copybuffer-r70",
        "description": "Copies buffer content to another buffer. The components can be any combination of the following:BUFFER_DEPTHBUFFER_NORMALBUFFER_COLOR, BUFFER_COLOR0BUFFER_COLOR1BUFFER_COLOR2",
        "c_syntax": "TBuffer CopyBuffer( TBuffer source, int components )",
        "cpp_syntax": "void Buffer::Copy( Buffer& destination, int components ) const",
        "example": "\n\n"
      },
      {
        "name": "CreateBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/createbuffer-r68",
        "description": "reates a new buffer with the specified parameters. Flags:BUFFER_DEPTHBUFFER_NORMAL (= BUFFER_COLOR1)BUFFER_COLOR, BUFFER_COLOR0BUFFER_COLOR1BUFFER_COLOR2BUFFER_COLOR3\nThis command increments the object reference count. To allow memory management to delete the resource, the reference count must be decremented by calling Release(object).",
        "c_syntax": "TBuffer CreateBuffer(int width=640, int height=480, int flags=BUFFER_COLOR",
        "cpp_syntax": "virtual void Buffer::Create( int width, int height, int flags = BUFFER_COLOR",
        "example": "\n\n"
      },
      {
        "name": "CreateCustomBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/createcustombuffer-r69",
        "description": "Creates and returns a new custom buffer. GetSize (defined as void _stdcall GetSize(int* width, int* height)) and MakeCurrent (defined as void _stdcall MakeCurrent(void)) are callback functions for the buffer. GetSize should return (by changing the value provided with a pointer) the size of the custum OpenGL buffer/context used. MakeCurrent should set the custom buffer as the current OpenGL context.\nNote: CreateCustomBuffer can vary based on which language you use. CustomBuffers must be managed by the user. Leadwerks will only handle rendering to that buffer.",
        "c_syntax": "TBuffer CreateCustomBuffer( byte* getsize, byte* makecurrent)",
        "cpp_syntax": null,
        "example": null
      },
      {
        "name": "CurrentBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/currentbuffer-r83",
        "description": "Returns the current buffer.",
        "c_syntax": "TBuffer CurrentBuffer( void )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "FreeBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/freebuffer-r71",
        "description": "Frees the specified buffer from memory.",
        "c_syntax": "void FreeBuffer( TBuffer buffer )",
        "cpp_syntax": "void Buffer::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "GetColorBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/getcolorbuffer-r76",
        "description": "Returns the specified buffer's color texture (as a reference). Index is a number from one to MaxColorBuffers() minus 1.",
        "c_syntax": "TTexture GetColorBuffer( TBuffer buffer, int index=0 )",
        "cpp_syntax": "Texture Buffer::GetColor( int index ) const",
        "example": "\n//This sample shows how to:\n//Render a camera to a buffer.\n//Create a material from code (using the camera buffer as diffuse texture).\n//Render a buffer/texture to the screen (multiple times).\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n \n\t// Setup\n\tSetAppTitle(\"GetColorBuffer Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer  = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n\tTEntity gbuffer = CreateBuffer(640,480,BUFFER_COLOR0);\n \n\t// Background scene\n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(45,45,0), 0);\n \n\tAmbientLight(Vec3(.05,.05,.2));\n \n\t// Camera\n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\t// Cube\n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(3,3,3) ); \n \n\t// Material\n\tTMaterial material = CreateMaterial();\n\tSetMaterialShader (material, LoadShader(\"abstract::mesh.vert\",\"abstract::mesh_diffuse.frag\"));\n\tSetMaterialTexture(material, GetColorBuffer(gbuffer));\n\tPaintEntity(cube, material);\n \n\t// Update, render, end\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\t// Update\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,0.5,0.2), 0);\n \n\t\t// Render camera to gbuffer\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(gbuffer);\n\t\tRenderLights(buffer);\n \n\t\t// Draw gbuffer to screen.\n\t\tSetBuffer(BackBuffer());\n\t\tDrawImage(GetColorBuffer(gbuffer), 0, 480, 640, -480); // Note that we need to flip the image\n \n\t\t// Draw a second time just for fun\n\t\tDrawImage(GetColorBuffer(gbuffer), 0, 150, 200, -150); // Note that we need to flip the image\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "GetDepthBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/getdepthbuffer-r77",
        "description": "Returns the specified buffer's depth texture.",
        "c_syntax": "TTexture GetDepthBuffer( TBuffer buffer )",
        "cpp_syntax": "Texture Buffer::GetDepth( void ) const",
        "example": "\n\n"
      },
      {
        "name": "MaxColorBuffers",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/maxcolorbuffers-r84",
        "description": "Returns the maximum number of color attachments allowed on the user's hardware.",
        "c_syntax": "int MaxColorBuffers( void )",
        "cpp_syntax": "static int Buffer::GetMaxColors( void ) const",
        "example": "\n//This program shows your computer's capabilities (in the console window).\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Hello World (window title)\");\n\tGraphics(640,480); ShowWindow(GetActiveWindow(),SW_HIDE);\n\tCreateWorld();\n \n\tprintf(\"\\n\\n==Computer capabilities==\\n\");\n\tprintf(\"MaxTextureUnits() = %d\\n\",MaxTextureUnits());\n\tprintf(\"MaxColorBuffers() = %d\\n\",MaxColorBuffers());\n\tprintf(\"MaxAFilter() = %d\\n\",MaxAFilter());\n\tprintf(\"ShaderModel = %d\\n\",GetShaderModel());\n \n\tchar gvendor[] = \"VENDOR_UNKNOWN\"; int gvendorID = GetGraphicsVendor();\n\tif(gvendorID == VENDOR_NVIDIA)strcpy(gvendor,\"VENDOR_NVIDIA\");\n\tif(gvendorID == VENDOR_ATI)strcpy(gvendor,\"VENDOR_ATI\");\n\tprintf(\"GraphicsVendor = %s\\n\",gvendor);\n \n\tprintf(\"\\n\\n\");\n \n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SaveBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/savebuffer-r81",
        "description": "Saves the specified buffer to a file (saving the BackBuffer() is like taking a screenshot). Quality is only used for JPG/JPEG files. Leadwerks Engine 2 supports saving to JPG/JPEG, TGA, and PNG files.",
        "c_syntax": "int SaveBuffer( TBuffer buffer, str filename, int quality=85 )",
        "cpp_syntax": "int Buffer::SaveBuffer( const_str filename, int quality )",
        "example": "\n\n"
      },
      {
        "name": "SetBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/setbuffer-r80",
        "description": "Sets the specified buffer as the active buffer.",
        "c_syntax": "void SetBuffer( TBuffer buffer )",
        "cpp_syntax": "void Buffer::Set( void )",
        "example": "\n\n"
      },
      {
        "name": "SetColorBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/setcolorbuffer-r73",
        "description": "Assigns a texture to one of the buffer's color channels. The optional cubeface parameter can be used to assign a cubemap face to a buffer.",
        "c_syntax": "int SetColorBuffer(TBuffer buffer, TTexture texture, int index=0, int cubeface=0)",
        "cpp_syntax": "int Buffer::SetColor( const Texture& texture, int index, int cubeface )",
        "example": "\n\n"
      },
      {
        "name": "SetDepthBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/setdepthbuffer-r74",
        "description": "Assigns a texture to the buffer's depth channel.",
        "c_syntax": "void SetDepthBuffer(TBuffer buffer, TTexture texture)",
        "cpp_syntax": "void Buffer::SetDepth( const Texture& texture )",
        "example": "\n\n"
      },
      {
        "name": "SetNormalBuffer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/buffers/setnormalbuffer-r75",
        "description": "Assigns a texture to the buffer's normal channel.",
        "c_syntax": "void SetNormalBuffer(TBuffer buffer, TTexture texture)",
        "cpp_syntax": "void Buffer::SetNormal( const Texture& texture )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Cameras",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/",
    "members": [
      {
        "name": "CameraClearColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/cameraclearcolor-r88",
        "description": "Sets the clear color for the specified camera.",
        "c_syntax": "void CameraClearColor( TEntity camera, TVec4 &color )",
        "cpp_syntax": "void Camera::SetClearColor( const TVec4& color )",
        "example": "\n#include \"engine.h\"\n \nvoid HSVtoRGB( float *r, float *g, float *b, float h, float s, float v )\n{\n\tint i;\n\tfloat f, p, q, t;\n \n\tif( s == 0 ) {\n\t\t// achromatic (grey)\n\t\t*r = *g = *b = v;\n\t\treturn;\n\t}\n \n\th /= 60;\t\t\t// sector 0 to 5\n\ti = floor( h );\n\tf = h - i;\t\t\t// factorial part of h\n\tp = v * ( 1 - s );\n\tq = v * ( 1 - s * f );\n\tt = v * ( 1 - s * ( 1 - f ) );\n \n\tswitch( i ) {\n\t\tcase 0:\n\t\t\t*r = v;\n\t\t\t*g = t;\n\t\t\t*b = p;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*r = q;\n\t\t\t*g = v;\n\t\t\t*b = p;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*r = p;\n\t\t\t*g = v;\n\t\t\t*b = t;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*r = p;\n\t\t\t*g = q;\n\t\t\t*b = v;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*r = t;\n\t\t\t*g = p;\n\t\t\t*b = v;\n\t\t\tbreak;\n\t\tdefault:\t\t// case 5:\n\t\t\t*r = v;\n\t\t\t*g = p;\n\t\t\t*b = q;\n\t\t\tbreak;\n\t}\n \n}\n \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"CameraClearColor Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,0,-5) );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity cube = CreateCube(0);\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tTurnEntity(cube, Vec3(0.5,1,0.3));\n \n\t\t// update\n\t\tUpdateAppTime();\n \n\t\tTVec4 color = Vec4(1.0);\n\t\tHSVtoRGB(&color.X, &color.Y, &color.Z, fmodf(AppTime()/20.0f,360.0f), 1.0f, 1.0f);\n\t\tCameraClearColor(Camera, color);\n \n\t\t// render\n\t\tSetBuffer(buffer);\n\t\tRenderWorld(ENTITY_ALL);\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// text\n\t\tDrawText(0,0, \"Demonstrating CameraClearColor\");\n\t\t// end render\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "CameraClearMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/cameraclearmode-r91",
        "description": "Sets the clear mode for the specified camera. Possible values for mode are:BUFFER_COLOR\nDepth clears the depth bufferBUFFER_DEPTH\nFor any finished scene where you aren't running around in a big empty void, you should not use BUFFER_COLOR.\nDisabling this will save a few frames per second.\nMost of the time you want BUFFER_DEPTH enabled, unless you are doing something with multi-world\nrendering where the results of one render need to be used in the next. An example would be\nrendering transparent surfaces in a second pass.",
        "c_syntax": "void CameraClearMode( TEntity camera, int mode )",
        "cpp_syntax": "void Camera::SetClearMode( int clearMode )",
        "example": "\n#include \"engine.h\"\n#include <string>\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tTCamera camera;\n\tTLight light;\n\tTEntity cube;\n\tcamera = CreateCamera();\n\tint camera_mode = 3;\n\tCameraClearMode(camera, camera_mode);\n\tTVec4 rgba = Vec4(0, 0, 0, 1);\n\tCameraClearColor(camera, rgba);\n\tMoveEntity(camera, Vec3(0, 0, -5));\n\tTurnEntity(camera, Vec3(15, 0, 0));\n\tlight = CreatePointLight();\n\tcube = CreateCube();\n\tstd::string cmode = \"CLS_COLOR + CLS_DEPTH\";\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(cube, Vec3(1, 1, 1));\n \n\t\tif(KeyHit(KEY_1)) { rgba.X += .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_2)) { rgba.X -= .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_3)) { rgba.Y += .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_4)) { rgba.Y -= .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_5)) { rgba.Z += .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_6)) { rgba.Z -= .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_7)) { rgba.W += .1f; CameraClearColor(camera, rgba); }\n\t\tif(KeyHit(KEY_8)) { rgba.W -= .1f; CameraClearColor(camera, rgba); }\n \n\t\tif(KeyHit(KEY_F1)) {camera_mode = 1; CameraClearMode(camera, camera_mode); cmode = \"CLS_COLOR\"; }\n\t\tif(KeyHit(KEY_F2)) {camera_mode = 2; CameraClearMode(camera, camera_mode); cmode = \"CLS_DEPTH\"; }\n\t\tif(KeyHit(KEY_F3)) {camera_mode = 3; CameraClearMode(camera, camera_mode); cmode = \"CLS_COLOR + CLS_DEPTH\"; }\n \n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tDrawText(0, 0, \"R = %f | G = %f | B = %f | A = %f\", rgba.X, rgba.Y, rgba.Z, rgba.W);\n\t\tDrawText(0, 16, \"Use 1,2\t3,4\t5,6\t7,8   to +/- color component\");\n\t\tDrawText(0, 32, \"Use F1, F2, F3 to change the camera clear mode. Current Mode: %s\", cmode.c_str());\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "CameraProject",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/cameraproject-r93",
        "description": "Projects the specified screen coordinates into world coordinates.",
        "c_syntax": "TVec3 CameraProject( TCamera camera, TVec3& pos )",
        "cpp_syntax": "void Camera::Project( TVec3& pos ) const",
        "example": "\n#include \"engine.h\"\n#include <gl/GL.h>\n#pragma comment(lib, \"opengl32.lib\")\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tTCamera camera = CreateCamera();\n\tTEntity cube = CreateCube();\n\tCameraRange(camera, 1.0, 1000);\n\tPositionEntity(camera, Vec3(-5, -5, -5));\n\tRotateEntity(camera, Vec3(-35, -45, 0));\n \n\tfloat depth_ = 0.0f;\n\tfloat near_ = 1.0f;\n\tfloat far_ = 100.0f;\n\t\tCameraRange(camera, near_, far_);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(cube, Vec3(1, 1, 1));\n \n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tglReadPixels(MouseX(), GraphicsHeight() - MouseY(), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &depth_) ;\n\t\tfloat z = near_ / (far_ - depth_ * (far_ - near_)) * far_;\n\t\tTVec3 pos = CameraProject(camera, Vec3(MouseX(), MouseY(), z));\n \n\t\tDrawText(0, 0, \"Depth: %f\", depth_);\n\t\tDrawText(0, 16, \"Projected: (%.2f, %.2f, %.2f)\", pos.X, pos.Y, pos.Z);\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "CameraProjMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/cameraprojmode-r89",
        "description": "Sets the projection mode for the specified camera.\n0 - Nothing\n1 - Perspective projection (default)\n2 - Orthographic projection\nAttention: Orthographic project may not work correctly with lighting, various shaders and unproject commands.",
        "c_syntax": "void CameraProjMode( TEntity camera, int projMode )",
        "cpp_syntax": "void Body::SetProjMode( const ProjectionMode& mode ) Where mode is one of NOPROJECTION, PERSPECTIVE or ORTHOGRAPHIC",
        "example": "\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tTCamera camera;\n\tTLight light;\n\tTEntity cube;\n\tcamera = CreateCamera();\n\tint camera_mode = 3;\n\tCameraClearMode(camera, camera_mode);\n\tTVec4 rgba = Vec4(.2, .4, .7, 1);\n\tCameraClearColor(camera, rgba);\n\tMoveEntity(camera, Vec3(0, 0, -5));\n\tTurnEntity(camera, Vec3(15, 0, 0));\n\tlight = CreatePointLight();\n\tcube = CreateCube();\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(cube, Vec3(1, 1, 1));\n \n\t\tif(KeyHit(KEY_F1)) { CameraProjMode(camera, 0); }\n\t\tif(KeyHit(KEY_F2)) { CameraProjMode(camera, 1); }\n \n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tDrawText(0, 0, \"Use (F1) to change to Orthographic projection or (F2) to change to Perspective projection\");\n\t\tDrawText(0, 16, \"In Orthographic projection, the cube no longer rotates\");\n \n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "CameraRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/camerarange-r90",
        "description": "Sets the frustum range for the specified camera.",
        "c_syntax": "void CameraRange( TEntity camera, float near, float far )",
        "cpp_syntax": "void Camera::SetRange( flt near, flt far )",
        "example": "\n#include \"engine.h\"\n#include \"time.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera();\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,40,-22) );\n\tRotateEntity  (Camera, Vec3(60,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight();\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// Ground\n\tTEntity\t\t ground = CreateCube();\t\t\t\t\n\tScaleEntity\t(ground,\tVec3(100,1,100));\n\t//MoveEntity\t (ground , Vec3(0,-51,0) );\n \n \n\t// Set CameraRange\n\tfloat farCameraRange = 120;\n\tfloat nearCameraRange = 0.1;\n\tCameraRange(Camera,nearCameraRange,farCameraRange);\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t// chang range\n\t\tbool changedCameraRange = false;\n \n\t\tif(KeyDown(KEY_NUMADD))\n\t\t{\n\t\t\tif (KeyDown(KEY_SPACE))\n\t\t\t\tnearCameraRange += 0.5;\n\t\t\telse\n\t\t\t\tfarCameraRange++;\n \n\t\t\tchangedCameraRange = true;\n\t\t}\n \n\t\tif(KeyDown(KEY_NUMSUBTRACT))\n\t\t{\n\t\t\tif (KeyDown(KEY_SPACE))\n\t\t\t{\n\t\t\t\tif(nearCameraRange > 0.5)nearCameraRange -= 0.5;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(farCameraRange > 1)farCameraRange--;\n\t\t\t}\n \n\t\t\tchangedCameraRange = true;\n\t\t}\n \n\t\tif (changedCameraRange)\n\t\t\tCameraRange(Camera,nearCameraRange,farCameraRange);\n \n\t\t// Render\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// Text\n\t\tDrawText (0,0,\"Camera range: near %f, far %f\",nearCameraRange,farCameraRange);\n\t\tDrawText (0,20,\"Use the add/subtract keys to change the 'farCameraRange'\");\n\t\tDrawText (0,40,\"Use the add/subtract keys + SPACE to change the 'nearCameraRange'\");\n \n\t\t// Flip\n\t\tFlip();\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "CameraUnproject",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/cameraunproject-r94",
        "description": "Projects the specified world coordinates into screen coordinates. If the z position is less than 0, the point is behind the camera.",
        "c_syntax": "TVec3 CameraUnproject( TCamera camera, TVec3 &pos )",
        "cpp_syntax": "void Camera::UnProject( TVec3& pos ) const",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics\t (640,480, 0, 0, 0);\n \n\tTEntity\t   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\tMoveEntity   (Camera, Vec3(0,2,-2) );\n\tRotateEntity (Camera, Vec3(20,0,0) ,0);\n \n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n \n\tTEntity cube   = CreateCube(0); \n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tfloat anglepos = 0;\n\tfloat dist = 10;\n \n\twhile(!KeyHit(KEY_ESCAPE)){\n \n\t\tPositionEntity(cube, Vec3(sin(anglepos*M_PI/180.0)*dist,0,cos(anglepos*M_PI/180.0)*dist));\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tanglepos -= 0.8;\n\t\t}\n \n \n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tanglepos += 0.8;\n\t\t}\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n \n\t\tTVec3 pos = CameraUnproject(Camera,EntityPosition(cube)) ;\n\t\tDrawText (pos.X,pos.Y,\"Cube center position\");\n\t\tif (pos.Z < 0)\n\t\t\tDrawText (pos.X,pos.Y+15,\"Cube behind camera\");\n \n \n\t\tDrawText (0,0,\"Use the arrow keys to move the cube\");\n\t\tSetBlend   (0);\n\t\tFlip\t   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "CameraZoom",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/camerazoom-r92",
        "description": "Sets the zoom level for the specified camera.",
        "c_syntax": "void CameraZoom( TEntity camera, flt zoom )",
        "cpp_syntax": "void Camera::SetZoom( flt zoom )",
        "example": "\n#include \"engine.h\"\n\n\nint main(void)\n{\n\tInitialize();\n\tGraphics\t (640,480, 0, 0, 0);\n\t\n\tTEntity\t   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\tMoveEntity\t(Camera, Vec3(0,40,-22) );\n\tRotateEntity  (Camera, Vec3(60,0,0),0 );\n\n\n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\tTEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\tScaleEntity\t(ground,\tVec3(100,100,100));\n\tMoveEntity\t (ground , Vec3(0,-51,0) );\n \n\tCollisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n\n\tTEntity cube   = CreateCube(0);\t\t// In LE2.1, the cubes size is 1x1x1\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\n\t// Set CameraRange\n\tfloat cameraZoom = 1;\n\tCameraZoom(Camera,cameraZoom);\n\n\twhile(!KeyHit(KEY_ESCAPE)){\n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\t   \n\t\tif(KeyDown(KEY_NUMADD)){\n\t\t\tcameraZoom += 0.1;\n\t\t\tCameraZoom(Camera,cameraZoom);\n\t\t}\n\n\n\t\tif(KeyDown(KEY_NUMSUBTRACT)){\n\t\t\tcameraZoom -= 0.1;\n\t\t\tCameraZoom(Camera,cameraZoom);\n\t\t}\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend   (BLEND_ALPHA);\n\t\tDrawText (0,0,\"CameraZoom: %f\",cameraZoom);\n\t\tDrawText (0,20,\"Use the add/subtract keys to change the CameraZoom\");\n\t\tSetBlend   (0);\n\t\tFlip\t   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "CreateCamera",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/createcamera-r87",
        "description": "Creates a new camera.",
        "c_syntax": "TCamera CreateCamera( TEntity parent=NULL )",
        "cpp_syntax": "Camera::Camera( const TEntity = 0 ) Create has to be called\nCamera::Camera( const CreateMode& createMode, const TEntity = 0 ) Where createMode is either CREATENOW or CREATELATER\nvirtual void Camera::Create( Entity parent=NULL )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics(640, 480);\n\tCreateWorld(); \n\tCreateCamera(); // of course, you'd store a handle to this for future use like: \"TCamera camera = CreateCamera();\"\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld(); // renders the world from the view of the only visible camera\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "GetCameraRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/getcamerarange-r95",
        "description": "Returns the range of the specified camera.",
        "c_syntax": "void GetCameraRange(TCamera camera, flt &nearRange, flt &farRange)",
        "cpp_syntax": "void Camera::GetRange( flt& near, flt& far ) const",
        "example": "\n\n"
      },
      {
        "name": "SetCameraClipPlane",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/cameras/setcameraclipplane-r96",
        "description": "Sets the clip plane of the specified camera.The plane is specified using a normal (the up-normal) plus an offset. The plane is infinite. Everything beneath the plane won't be drawn next time the camera is rendered.",
        "c_syntax": "void SetCameraClipPlane(TCamera camera, int n, TVec4 &plane)",
        "cpp_syntax": "void Camera::SetClipPlane( int n, const Matrix4& plane )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Collision",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/collision/",
    "members": [
      {
        "name": "ClearCollisions",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/collision/clearcollisions-r99",
        "description": "Resets all collision responses to 0.",
        "c_syntax": "void ClearCollisions( void )",
        "cpp_syntax": "static void Collisions::Clear( void )",
        "example": "\n\n"
      },
      {
        "name": "Collision Callback Example",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/collision/collision-callback-example-r547",
        "description": null,
        "c_syntax": null,
        "cpp_syntax": null,
        "example": "#include \"engine.h\"\n\nint DoorCollision(TEntity e1, TEntity e2)\n{\n\t\tif(GetEntityType(e2)==1)\t\t// only interested in balls\n\t\t\t\tAddBodyForce(e2,Vec3(0,1000,0));\n\t\treturn 0;\n}\n\nint main(int argc, char* argv[])\n{\n\t\tInitialize();\n\t\tGraphics(800,600);\n\t\tCreateFramework();\n\t\tDebugPhysics(1);\n\n\t\tTBody door=CreateBodyBox(1,2,0.3);\n\t\tMoveEntity(door,Vec3(0,1,0));\n\t\tSetBodyMass(door,1);\n\t\tEntityType(door,2);\n\n\t\tTBody ball=CreateBodySphere();\n\t\tMoveEntity(ball,Vec3(0,2,-8));\n\t\tSetBodyMass(ball,1);\n\t\tEntityType(ball,1);\n\n\t\tTTerrain terrain=CreateTerrain(128);\n\t\tEntityType(terrain,3);\n\n\t\tCollisions(1,2);\t\t// ball with door\n\t\tCollisions(1,3);\t\t// ball with terrain\n\t\tCollisions(2,3);\t\t// door with terrain\n\n\t\tTCamera cam=GetLayerCamera(GetFrameworkLayer(0));\n\t\tMoveEntity(cam,Vec3(0,2,-10));\n\n\t\tSetEntityCallback(door,(BP)DoorCollision,ENTITYCALLBACK_COLLISION);\n\n\t\tAddBodyForce(ball,Vec3(0,0,500));\n\n\t\twhile( !AppTerminate() and !KeyHit() )\n\t\t{\n\t\t\t\tUpdateFramework();\n\t\t\t\tRenderFramework();\n\t\t\t\tFlip();\n\t\t}\n\t\treturn Terminate();\n}"
      },
      {
        "name": "Collisions",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/collision/collisions-r98",
        "description": "Sets the collision response for collision type 1 and 2.\n0 - no collision (default)\n1 - sliding collision\n2 - no-response collision; a collision is recorded, but the objects will pass through each other.",
        "c_syntax": "void Collisions( int collisionType1, int collisionType2, int collisionResponse )",
        "cpp_syntax": "static void Collisions::Set( int type1 = 1, int type2 = 1, const CollisionResponse& response = SLIDINGCOLLISION )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Controllers",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/controllers/",
    "members": [
      {
        "name": "ControllerAirborne",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/controllers/controllerairborne-r103",
        "description": "Returns a value of 1 if the specified controller is currently airborne (= not touching the ground), otherwise 0.",
        "c_syntax": "int ControllerAirborne( TController controller )",
        "cpp_syntax": "bool Controller::IsAirborne( void ) const",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"CharacterController Demo\");\n\tGraphics(800,600);\n\tCreateWorld();\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL); // Create a graphics buffer\n \n\t//Create the character controller\n\tTController character=CreateController();\n\tPositionEntity(character,Vec3(0,2,0));\n\tEntityType(character, 1); SetBodyMass(character, 1);\n \n\t//Create the cylindrical character mesh\n\tTMesh characterMesh=CreateCylinder(32);\n\tScaleMesh(characterMesh,Vec3(0.8,1.8,0.8));\n\tTranslateMesh(characterMesh,Vec3(0,0.9,0));\n \n\t//Create a camera\n\tTEntity campiv=CreatePivot();\n\tTCamera cam=CreateCamera(campiv);\n\tPositionEntity(cam,Vec3(0,0,-4));\n \n\t//Create a spotlight\n\tTLight light=CreateSpotLight();\n\tPositionEntity(light,Vec3(4,2,-4));\n\tRotateEntity(light,Vec3(45,45,0));\n\tSetShadowmapSize(light,1024);\n \n\t// Create the ground mesh\n\tTBody ground=CreateBodyBox(10,0.1,10);\n\tTMesh ground2=CreateCube();\n\tScaleMesh(ground2,Vec3(10,0.1,10));\n\tPositionEntity(ground2,Vec3(0,-2,0));\n\tPositionEntity(ground,Vec3(0,-2,0));\n\tEntityType(ground,1);\n \n\t// Enable the collisions\n\tCollisions(1, 1, 1);\n \n\t// Create  camera variables\n\tfloat mx=0.0,my=0.0,cx=0.0,cz=0.0;\n\tfloat move=0.0,strafe=0.0;\n\tTVec3 camrotation = {0};\n \n\t//Prepare values for mouse movement calculation\n\tTVec2 lastMousePos = {MouseX(),MouseY()};\n\tTVec2 mouseMove = {0};\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) {\n\t\t// calculate mouse movement\n\t\tmouseMove = Vec2(MouseX()-lastMousePos.X,MouseY()-lastMousePos.Y);\n\t\tlastMousePos = Vec2(MouseX(),MouseY());\n \n\t\t// Controller movement\n\t\tmove=KeyDown(KEY_W)-KeyDown(KEY_S);\n\t\tstrafe=KeyDown(KEY_D)-KeyDown(KEY_A);\n\t\tfloat jump = KeyDown(KEY_SPACE) * (!ControllerAirborne(character)) * 5.5;\n\t\tUpdateController(character,camrotation.Y,move*2.5,strafe,jump,5);\n \n\t\t//Find the location of the character\n\t\tTVec3 charpos=EntityPosition(character);\n\t\tPositionEntity(characterMesh,charpos); // and update the mesh\n \n\t\t//Camera movement\n\t\tmx=0;\n\t\tmy=0;\n\t\tcx=0.0;\n\t\tcz=0.0;\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tmx=mx+3;\n\t\t}\n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tmx=mx-3;\n\t\t}\n\t\tif(KeyDown(KEY_UP)){\n\t\t\tmy=my+3;\n\t\t}\n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tmy=my-3;\n\t\t}\n\t\tcamrotation=EntityRotation(campiv);\n\t\tcamrotation.X += my + mouseMove.Y*MouseDown(2)*0.5;\n\t\tcamrotation.Y -= mx + mouseMove.X*MouseDown(2)*0.5;\n\t\tRotateEntity(campiv, camrotation);\n \n\t\tPositionEntity(campiv, charpos);\n \n\t\t//Update the world & render\n\t\tUpdateAppTime();\n\t\tUpdateWorld(1);\n\t\tDebugPhysics(KeyDown(KEY_P));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// 2d drawing\n\t\tSetBlend(BLEND_ALPHA);\n\t\tint line = 0;\n\t\tDrawText(0,14*line,\"FPS: %f, TrisRendered: %d, Light tris: %d [lights are only updated if something moves]\",FPS(),TrisRendered(0),TrisRendered(1));line++;\n\t\tDrawText(0,14*line,\"Hold P to debug Physics.\");line++;\n\t\tDrawText(0,14*line,\"Use WASD to move. SPACE to jump. Character controller airborne?: %s\", ControllerAirborne(character)?\"yes\":\"no\");line++;\n\t\tDrawText(0,14*line,\"Use the arrow keys and the right mouse button + the mouse to move/rotate the camera.\");line++;\n\t\tSetBlend(BLEND_NONE);\n \n\t\t// flip buffers\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "ControllerCrouched",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/controllers/controllercrouched-r104",
        "description": "Returns a value of 1 if the specified controller is currently crouched (= not standing upright), otherwise 0.",
        "c_syntax": "int ControllerCrouched( TController controller )",
        "cpp_syntax": "bool Controller::IsCrouched() const",
        "example": "\n\n"
      },
      {
        "name": "CreateController",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/controllers/createcontroller-r101",
        "description": "Creates a new player controller.",
        "c_syntax": "TController CreateController( flt height, flt radius, flt stepheight=0.5f, flt maxslope=45, flt crouchheight=0 )",
        "cpp_syntax": "Controller::Controller( flt height, flt radius=0.4f, flt stepheight=0.5f, flt maxslope=45, flt crouchheight=0 )\nvirtual void Controller::Create( flt height=1.8f, flt radius=0.4f, flt stepheight=0.5f, flt maxslope=45, flt crouchheight=0 )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"CharacterController Demo\");\n\tGraphics(800,600);\n\tCreateWorld();\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL); // Create a graphics buffer\n \n\t//Create the character controller\n\tTController character=CreateController();\n\tPositionEntity(character,Vec3(0,2,0));\n\tEntityType(character, 1); SetBodyMass(character, 1);\n \n\t//Create the cylindrical character mesh\n\tTMesh characterMesh=CreateCylinder(32);\n\tScaleMesh(characterMesh,Vec3(0.8,1.8,0.8));\n\tTranslateMesh(characterMesh,Vec3(0,0.9,0));\n \n\t//Create a camera\n\tTEntity campiv=CreatePivot();\n\tTCamera cam=CreateCamera(campiv);\n\tPositionEntity(cam,Vec3(0,0,-4));\n \n\t//Create a spotlight\n\tTLight light=CreateSpotLight();\n\tPositionEntity(light,Vec3(4,2,-4));\n\tRotateEntity(light,Vec3(45,45,0));\n\tSetShadowmapSize(light,1024);\n \n\t// Create the ground mesh\n\tTBody ground=CreateBodyBox(10,0.1,10);\n\tTMesh ground2=CreateCube();\n\tScaleMesh(ground2,Vec3(10,0.1,10));\n\tPositionEntity(ground2,Vec3(0,-2,0));\n\tPositionEntity(ground,Vec3(0,-2,0));\n\tEntityType(ground,1);\n \n\t// Enable the collisions\n\tCollisions(1, 1, 1);\n \n\t// Create  camera variables\n\tfloat mx=0.0,my=0.0,cx=0.0,cz=0.0;\n\tfloat move=0.0,strafe=0.0;\n\tTVec3 camrotation = {0};\n \n\t//Prepare values for mouse movement calculation\n\tTVec2 lastMousePos = {MouseX(),MouseY()};\n\tTVec2 mouseMove = {0};\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) {\n\t\t// calculate mouse movement\n\t\tmouseMove = Vec2(MouseX()-lastMousePos.X,MouseY()-lastMousePos.Y);\n\t\tlastMousePos = Vec2(MouseX(),MouseY());\n \n\t\t// Controller movement\n\t\tmove=KeyDown(KEY_W)-KeyDown(KEY_S);\n\t\tstrafe=KeyDown(KEY_D)-KeyDown(KEY_A);\n\t\tfloat jump = KeyDown(KEY_SPACE) * (!ControllerAirborne(character)) * 5.5;\n\t\tUpdateController(character,camrotation.Y,move*2.5,strafe,jump,5);\n \n\t\t//Find the location of the character\n\t\tTVec3 charpos=EntityPosition(character);\n\t\tPositionEntity(characterMesh,charpos); // and update the mesh\n \n\t\t//Camera movement\n\t\tmx=0;\n\t\tmy=0;\n\t\tcx=0.0;\n\t\tcz=0.0;\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tmx=mx+3;\n\t\t}\n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tmx=mx-3;\n\t\t}\n\t\tif(KeyDown(KEY_UP)){\n\t\t\tmy=my+3;\n\t\t}\n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tmy=my-3;\n\t\t}\n\t\tcamrotation=EntityRotation(campiv);\n\t\tcamrotation.X += my + mouseMove.Y*MouseDown(2)*0.5;\n\t\tcamrotation.Y -= mx + mouseMove.X*MouseDown(2)*0.5;\n\t\tRotateEntity(campiv, camrotation);\n \n\t\tPositionEntity(campiv, charpos);\n \n\t\t//Update the world & render\n\t\tUpdateAppTime();\n\t\tUpdateWorld(1);\n\t\tDebugPhysics(KeyDown(KEY_P));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// 2d drawing\n\t\tSetBlend(BLEND_ALPHA);\n\t\tint line = 0;\n\t\tDrawText(0,14*line,\"FPS: %f, TrisRendered: %d, Light tris: %d [lights are only updated if something moves]\",FPS(),TrisRendered(0),TrisRendered(1));line++;\n\t\tDrawText(0,14*line,\"Hold P to debug Physics.\");line++;\n\t\tDrawText(0,14*line,\"Use WASD to move. SPACE to jump. Character controller airborne?: %s\", ControllerAirborne(character)?\"yes\":\"no\");line++;\n\t\tDrawText(0,14*line,\"Use the arrow keys and the right mouse button + the mouse to move/rotate the camera.\");line++;\n\t\tSetBlend(BLEND_NONE);\n \n\t\t// flip buffers\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "UpdateController",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/controllers/updatecontroller-r102",
        "description": "Updates the controller direction, movement and jump state. The iterations parameter controls how many times collision is calculated. Using several iterations can make motion appear smoother when a camera is attached to the controller. However, an iterations value of one is enough for controllers that do not control the view.",
        "c_syntax": "void UpdateController( TController controller, flt angle, flt move, flt strafe=0, flt jump=0, flt maxacceleration=0.5f, int iterations=1, int crouchmode=0 )",
        "cpp_syntax": "virtual void Controller::Update( flt angle, flt move, flt strafe = 0.0f, flt jump = 0.0f, flt maxacceleration = 0.5f, int iterations=1, int crouchmode=0 )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"CharacterController Demo\");\n\tGraphics(800,600);\n\tCreateWorld();\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL); // Create a graphics buffer\n \n\t//Create the character controller\n\tTController character=CreateController();\n\tPositionEntity(character,Vec3(0,2,0));\n\tEntityType(character, 1); SetBodyMass(character, 1);\n \n\t//Create the cylindrical character mesh\n\tTMesh characterMesh=CreateCylinder(32);\n\tScaleMesh(characterMesh,Vec3(0.8,1.8,0.8));\n\tTranslateMesh(characterMesh,Vec3(0,0.9,0));\n \n\t//Create a camera\n\tTEntity campiv=CreatePivot();\n\tTCamera cam=CreateCamera(campiv);\n\tPositionEntity(cam,Vec3(0,0,-4));\n \n\t//Create a spotlight\n\tTLight light=CreateSpotLight();\n\tPositionEntity(light,Vec3(4,2,-4));\n\tRotateEntity(light,Vec3(45,45,0));\n\tSetShadowmapSize(light,1024);\n \n\t// Create the ground mesh\n\tTBody ground=CreateBodyBox(10,0.1,10);\n\tTMesh ground2=CreateCube();\n\tScaleMesh(ground2,Vec3(10,0.1,10));\n\tPositionEntity(ground2,Vec3(0,-2,0));\n\tPositionEntity(ground,Vec3(0,-2,0));\n\tEntityType(ground,1);\n \n\t// Enable the collisions\n\tCollisions(1, 1, 1);\n \n\t// Create  camera variables\n\tfloat mx=0.0,my=0.0,cx=0.0,cz=0.0;\n\tfloat move=0.0,strafe=0.0;\n\tTVec3 camrotation = {0};\n \n\t//Prepare values for mouse movement calculation\n\tTVec2 lastMousePos = {MouseX(),MouseY()};\n\tTVec2 mouseMove = {0};\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) {\n\t\t// calculate mouse movement\n\t\tmouseMove = Vec2(MouseX()-lastMousePos.X,MouseY()-lastMousePos.Y);\n\t\tlastMousePos = Vec2(MouseX(),MouseY());\n \n\t\t// Controller movement\n\t\tmove=KeyDown(KEY_W)-KeyDown(KEY_S);\n\t\tstrafe=KeyDown(KEY_D)-KeyDown(KEY_A);\n\t\tfloat jump = KeyDown(KEY_SPACE) * (!ControllerAirborne(character)) * 5.5;\n\t\tUpdateController(character,camrotation.Y,move*2.5,strafe,jump,5);\n \n\t\t//Find the location of the character\n\t\tTVec3 charpos=EntityPosition(character);\n\t\tPositionEntity(characterMesh,charpos); // and update the mesh\n \n\t\t//Camera movement\n\t\tmx=0;\n\t\tmy=0;\n\t\tcx=0.0;\n\t\tcz=0.0;\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tmx=mx+3;\n\t\t}\n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tmx=mx-3;\n\t\t}\n\t\tif(KeyDown(KEY_UP)){\n\t\t\tmy=my+3;\n\t\t}\n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tmy=my-3;\n\t\t}\n\t\tcamrotation=EntityRotation(campiv);\n\t\tcamrotation.X += my + mouseMove.Y*MouseDown(2)*0.5;\n\t\tcamrotation.Y -= mx + mouseMove.X*MouseDown(2)*0.5;\n\t\tRotateEntity(campiv, camrotation);\n \n\t\tPositionEntity(campiv, charpos);\n \n\t\t//Update the world & render\n\t\tUpdateAppTime();\n\t\tUpdateWorld(1);\n\t\tDebugPhysics(KeyDown(KEY_P));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t// 2d drawing\n\t\tSetBlend(BLEND_ALPHA);\n\t\tint line = 0;\n\t\tDrawText(0,14*line,\"FPS: %f, TrisRendered: %d, Light tris: %d [lights are only updated if something moves]\",FPS(),TrisRendered(0),TrisRendered(1));line++;\n\t\tDrawText(0,14*line,\"Hold P to debug Physics.\");line++;\n\t\tDrawText(0,14*line,\"Use WASD to move. SPACE to jump. Character controller airborne?: %s\", ControllerAirborne(character)?\"yes\":\"no\");line++;\n\t\tDrawText(0,14*line,\"Use the arrow keys and the right mouse button + the mouse to move/rotate the camera.\");line++;\n\t\tSetBlend(BLEND_NONE);\n \n\t\t// flip buffers\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      }
    ]
  },
  {
    "name": "Coronas",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/coronas/",
    "members": [
      {
        "name": "CreateCorona",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/coronas/createcorona-r106",
        "description": "Creates a new corona. Coronas are billboards. They are a simple plane mesh that is always automatically rotated to face the camera. You can paste any texture on them using the standard PaintEntity command. They are often used for bright lights like the sun.",
        "c_syntax": "TCorona CreateCorona( TEntity parent=NULL )",
        "cpp_syntax": "Corona::Corona( TEntity ent = NULL, const TEntity parent = NULL )",
        "example": "\n\n"
      },
      {
        "name": "SetCoronaRadius",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/coronas/setcoronaradius-r107",
        "description": "Sets the specified corona's radius. The first radius is the inner circle and the second radius is the outer circle.",
        "c_syntax": "void SetCoronaRadius( TCorona corona, flt radius1, flt radius2 )",
        "cpp_syntax": "void Corona::SetRadius( flt radius1, flt radius2 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Emitters",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/",
    "members": [
      {
        "name": "CreateEmitter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/createemitter-r109",
        "description": "Creates a new emitter entity. An emitter emits a stream of particles for rendering smoke, steam, water, fire, and other gaseous and liquid matter.\nThe optional cycle mode can be used to display different behaviors:\ncyclemode = 0: Looping. The emitter will continue forever.\ncyclemode = 1: = One-shot. The emitter will fire once and then free itself. Use this for explosions or impact dust.\nAll particles of an emitter are drawn in a single pass. A vertex shader is used to make the particles face the camera. This yields very fast rendering speeds, but emitters must be painted with a material that uses the particle vertex shader.",
        "c_syntax": "TEmitter CreateEmitter(int intensity=100, int lifetime=1000, TVec3 &velocity=Vec3(0), int cyclemode=0, TEntity parent=NULL)",
        "cpp_syntax": "Emitter::Emitter( int intensity, int lifetime, const TVec3& velocity, int cycleMode, const TEntity )\nvirtual void Create( int intensity, int lifetime, const TVec3& velocity, int cycleMode, const TEntity )",
        "example": "\n//Creates an emitter\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"CreateEmitter\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(10);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Creates 2 emitters and and paints them with a material.\");\n\t\t\tDrawText(0,15, \"The first emitter is the default emitter.\");\n\t\t\tDrawText(0,30, \"The second emitter is the default emitter with extra parameters (like velocity).\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "EmitterPaused",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/emitterpaused-r112",
        "description": "Indicates whether the specified emitter is paused. If the emitter is paused, True is returned, otherwise False is returned.",
        "c_syntax": "int EmitterPaused( TEmitter emitter )",
        "cpp_syntax": "bool Emitter::IsPaused( void ) const",
        "example": "\n//This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Pausing and resuming emitters\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(20);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(30, 4000,Vec3(0,0.6,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//set the Acceleration for an emitter\n\tSetEmitterAcceleration(emitter1, Vec3(2,0,0));\n\tSetEmitterAcceleration(emitter2, Vec3(-1,-1,0));\n\n\t//Pause emitter2\n\tPauseEmitter(emitter2);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\t//Check emitter 1\n\t\t\tif(EmitterPaused(emitter1))\n\t\t\t\tResumeEmitter(emitter1);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter1);\n\n\t\t\t//Check emitter 2\n\t\t\tif(EmitterPaused(emitter2))\n\t\t\t\tResumeEmitter(emitter2);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter2);\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "PauseEmitter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/pauseemitter-r110",
        "description": "Pauses the specified emitter. This can be used for intermittent effects, or for turning on and off a flame thrower, steam leak, torch, or other effects.",
        "c_syntax": "void PauseEmitter( TEmitter emitter )",
        "cpp_syntax": "void Emitter::Pause( void )",
        "example": "\n//This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Pausing and resuming emitters\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(20);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(30, 4000,Vec3(0,0.6,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//set the Acceleration for an emitter\n\tSetEmitterAcceleration(emitter1, Vec3(2,0,0));\n\tSetEmitterAcceleration(emitter2, Vec3(-1,-1,0));\n\n\t//Pause emitter2\n\tPauseEmitter(emitter2);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\t//Check emitter 1\n\t\t\tif(EmitterPaused(emitter1))\n\t\t\t\tResumeEmitter(emitter1);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter1);\n\n\t\t\t//Check emitter 2\n\t\t\tif(EmitterPaused(emitter2))\n\t\t\t\tResumeEmitter(emitter2);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter2);\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "ResumeEmitter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/resumeemitter-r111",
        "description": "Resumes an emitter. This can be used for intermittent effects, or for turning on and off a flame thrower, steam leak, torch, or other effects.",
        "c_syntax": "void ResumeEmitter( TEmitter emitter )",
        "cpp_syntax": "void Emitter::Pause( void )",
        "example": "\n//This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Pausing and resuming emitters\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(20);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(30, 4000,Vec3(0,0.6,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//set the Acceleration for an emitter\n\tSetEmitterAcceleration(emitter1, Vec3(2,0,0));\n\tSetEmitterAcceleration(emitter2, Vec3(-1,-1,0));\n\n\t//Pause emitter2\n\tPauseEmitter(emitter2);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\t//Check emitter 1\n\t\t\tif(EmitterPaused(emitter1))\n\t\t\t\tResumeEmitter(emitter1);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter1);\n\n\t\t\t//Check emitter 2\n\t\t\tif(EmitterPaused(emitter2))\n\t\t\t\tResumeEmitter(emitter2);\n\t\t\telse\n\t\t\t\tPauseEmitter(emitter2);\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"This program demonstrates pausing and resuming an emitter. Press SPACE to pause and resume the emittes.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetEmitterAcceleration",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemitteracceleration-r114",
        "description": "Sets the acceleration applied to particles each update. This can be used for gravity or wind effects.",
        "c_syntax": "void SetEmitterAcceleration( TEmitter emitter, TVec3 &acceleration )",
        "cpp_syntax": "void Emitter::SetAcceleration( const TVec3& acceleration )Example\n//Set the acceleration for an emitter. This example creates a steam train effect.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterAcceleration\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(20);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(30, 4000,Vec3(0,0.6,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//set the Acceleration for an emitter\n\tSetEmitterAcceleration(emitter1, Vec3(2,0,0));\n\tSetEmitterAcceleration(emitter2, Vec3(-1,-1,0));\n\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the acceleration for an emitter. This",
        "example": "\n//Set the acceleration for an emitter. This example creates a steam train effect.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterAcceleration\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(20);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(30, 4000,Vec3(0,0.6,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//set the Acceleration for an emitter\n\tSetEmitterAcceleration(emitter1, Vec3(2,0,0));\n\tSetEmitterAcceleration(emitter2, Vec3(-1,-1,0));\n\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the acceleration for an emitter. This example creates a steam train effect.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetEmitterArea",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemitterarea-r116",
        "description": "Sets the area around the emitter within which particles are emitted. This can be used to create a wider flame that doesn't emit from only a single point.",
        "c_syntax": "void SetEmitterArea( TEmitter emitter, TVec3 &area )",
        "cpp_syntax": "void Emitter::SetArea( const TVec3& area )Example\n//Set the area for an emitter. This example creates a snow effect.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterArea\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter1 = CreateEmitter(200, 4000,Vec3(0,0.4,0),0);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the waver amount of a particle\n\tSetEmitterWaver(emitter1, 0.5);\n\n\t//Set the velocity amount of a particle\n\tSetEmitterVelocity(emitter1, Vec3(0,-0.2,0));\t\n\n\t//set the area for an emitter\n\tSetEmitterArea(emitter1, Vec3(4,3,2));\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the area for an emitter. This",
        "example": "\n//Set the area for an emitter. This example creates a snow effect.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterArea\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter1 = CreateEmitter(200, 4000,Vec3(0,0.4,0),0);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the waver amount of a particle\n\tSetEmitterWaver(emitter1, 0.5);\n\n\t//Set the velocity amount of a particle\n\tSetEmitterVelocity(emitter1, Vec3(0,-0.2,0));\t\n\n\t//set the area for an emitter\n\tSetEmitterArea(emitter1, Vec3(4,3,2));\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the area for an emitter. This example creates a snow effect.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetEmitterRadius",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemitterradius-r115",
        "description": "Sets the radius of the specified emitter's particles. The particles will grow/shrink during their lifetime from radius1 to radius2.",
        "c_syntax": "void SetEmitterRadius( TEmitter emitter, flt radius1, flt radius2 )",
        "cpp_syntax": "void Emitter::SetRadius( flt radius1, flt radius2 )",
        "example": "//Set the radius for an emitter\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterRadius\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(10);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(10, 2000,Vec3(0.5,0,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the radius of an emitter\n\t//Emitter1 starts small but grows over time\n\tSetEmitterRadius(emitter1, 0.1, 0.4);\n\t\n\t//Emitter2 starts big but shrinks over time\n\tSetEmitterRadius(emitter2, 0.4, 0.1);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the radius for an emitter. Emitters have a starting and ending radius.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n\n"
      },
      {
        "name": "SetEmitterRotationSpeed",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemitterrotationspeed-r117",
        "description": "Sets the rotation speed of emitted particles. Particles alternate rotation directions as they are emitted. A slow rotation helps maintain a random appearance and the illusion of a volumetric mass.",
        "c_syntax": "void SetEmitterRotationSpeed( TEmitter emitter, flt rotationspeed )",
        "cpp_syntax": "void Emitter::SetRotationSpeed( flt rotationSpeed )",
        "example": "\n//Set the rotationspeed for the emitter\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterRotationSpeed\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(10);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(10, 2000,Vec3(0.2,0,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the rotation speed for an emitter\n\tSetEmitterRotationSpeed(emitter1, 0.1f);\n\tSetEmitterRotationSpeed(emitter2, 0.9f);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the rotation speed for an emitter. Every new particle rotates in the other direction.\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetEmitterVelocity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemittervelocity-r113",
        "description": "Sets the velocity of emitted particles. A second optional vector can be used to specify a range of randomness. The emitter velocity only affects new particles as they are emitted. Existing particles will continue along their same path.",
        "c_syntax": "void SetEmitterVelocity(TEmitter emitter, TVec3 &velocity=Vec3(0,1,0), TVec3 &random=Vec3(0))",
        "cpp_syntax": "void Emitter::SetVelocity( const TVec3& velocity )",
        "example": "\n//Set velocity for an emitter\n#include \"engine.h\"\n \nint setEmitterVelocity(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetEmitterVelocity\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(10);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(10, 2000,Vec3(0.4,0,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the rotation speed for an emitter\n\tSetEmitterVelocity(emitter1, Vec3(-0.4, 0.4, 0));\n\tSetEmitterVelocity(emitter2,Vec3(0.4, 0.4, 0), Vec3(0, 2, 0) );\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the velocity for an emitter. Randomness can be add\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetEmitterWaver",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/emitters/setemitterwaver-r118",
        "description": "Sets a random range that is added to particle velocities each update. The higher the value, the more unpredictable the particle paths will be. A non-zero waver value will make particle emitters appear much more natural.",
        "c_syntax": "void SetEmitterWaver( TEmitter emitter, flt waver )",
        "cpp_syntax": "void Emitter::SetWaver( flt waver )",
        "example": "\n//Set the waver amount of a particle\n#include \"engine.h\"\n \nint setwaver(void)\n{\n\tInitialize();\n\tSetAppTitle(\"SetWaver\");\n\tGraphics(640,480);\n \n\tTEntity World = CreateWorld();\n \n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,0,-1) );\n \n\t//Create Emitter\n\tTEmitter emitter1 = CreateEmitter(10);\n\tPaintEntity(emitter1, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//intensity, lifetime (miliseconds), velocity (default is (0,1,0)), cyclemode (Default 0, parent)\n\tTEmitter emitter2 = CreateEmitter(10, 2000,Vec3(0.4,0,0),0);\n\tPaintEntity(emitter2, LoadMaterial(\"abstract::dust.mat\"));\n\n\t//Set the waver amount of a particle\n\tSetEmitterWaver(emitter1, 0.5);\n\tSetEmitterWaver(emitter2, 1 );\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Set the waver amount of a particle\");\n\t\tSetBlend(BLEND_NONE);\n\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      }
    ]
  },
  {
    "name": "Entities",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/",
    "members": [
      {
        "name": "AlignToVector",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/aligntovector-r127",
        "description": "Aligns an entity to a vector on any axis. By default, the Z axis is used (3), which causes the entity to point in the direction of the vector. The optional rate parameter can be used to gradually align the entity, ir used over several frames. The optional roll parameter can be used to control the remaining degree of freedom once the entity is aligned.",
        "c_syntax": "void AlignToVector( TEntity entity, TVec3 &vector, int axis, flt rate, flt roll )",
        "cpp_syntax": "virtual void Entity::AlignToVector( const TVec3& v, const Axis& axis = LEO::Z, flt rate = 1.0f, flt roll = 0.0f ) Where axis one of X, Y or Z",
        "example": "\n\n"
      },
      {
        "name": "CopyEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/copyentity-r119",
        "description": "Duplicates an entity. In the case of meshes, a new instance of the same mesh will be created, and all instances will be rendered in a fast batch. If the optional recursive parameter is set to True, the entire entity sub-hierarchy will be copied. The default value is True.",
        "c_syntax": "TEntity CopyEntity(TEntity entity, int recursive=1)",
        "cpp_syntax": "TEntity Entity::Copy( void ) const",
        "example": "\n//CopyEntity\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"CopyEntity Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\n\t//copy cube\n\tTEntity copycube = CopyEntity(basecube); \n\tPositionEntity(copycube, Vec3(3,3,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Copy an entity.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "CopyEntityKeys",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/copyentitykeys-r120",
        "description": "Copies all keys from one entity to another entity.",
        "c_syntax": "void CopyEntityKeys(TEntity src, TEntity dst)",
        "cpp_syntax": "TEntity Entity::CopyKeys( void ) const",
        "example": "\n\n"
      },
      {
        "name": "CountChildren",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/countchildren-r154",
        "description": "Using CountChildren you can see how many children a TEntity has.",
        "c_syntax": "int CountChildren( TEntity entity )",
        "cpp_syntax": "int Entity::GetCountChildren( void ) const",
        "example": "\n//Count the Children of an entity\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"CountChildren Demo\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tTEntity childcube1 = CreateCube(basecube); \n\tTEntity childcube2 = CreateCube(basecube);\n\tTEntity childcube3 = CreateCube(basecube);\n\tTEntity childcube4 = CreateCube(basecube);\n\n\tfloat amount = CountChildren(basecube);\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Count the children of basecube.\");\n\t\tDrawText(0,15, \"%f\", amount);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "EntityCollisionCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entitycollisioncallback-r176",
        "description": "This will be called when entity0 collides with another entity. The first entity is always the one which the callback was specified for. Note that the function can have any name.",
        "c_syntax": "void _stdcall EntityCollisionCallback( TEntity entity0, TEntity entity1, byte* position, byte* normal, byte* force, flt speed )",
        "cpp_syntax": "[/b]Example\n//This",
        "example": "\n//This example will drop a cube to the floor, report the 4 collisions that occur for the 4 corners of the cube and shut down. No visualization.\n#include \"engine.h\"\n \nbool doAbort = false;\n \nvoid _stdcall EntityCollisionCallback( TEntity entity0, TEntity entity1, byte* position, byte* normal, byte* force, flt speed )\n{\n   char str[256];\n   TVec3 vecPosition; memcpy(&vecPosition, position, sizeof(TVec3));\n   sprintf(str, \"%d collided with %d at %f,%f,%f\", (int)entity0, (int)entity1, vecPosition.X, vecPosition.Y, vecPosition.Z);\n   MessageBox(0, str, \"EntityCollisionCallback called\", 0);\n \n   doAbort = true;\n}\n \nint main(int argc, char** argv)\n{\n   Initialize();\n   Graphics();\n   CreateWorld();\n \n   TEntity floor = CreateBodyBox(10,0.1,10);\n   PositionEntity(floor, Vec3(0, -5, 0));\n   EntityType(floor, 1);\n \n   TEntity body = CreateBodyBox();\n   SetBodyMass(body, 1);\n   EntityType(body, 1);\n   SetEntityCallback(body,(byte*)EntityCollisionCallback,ENTITYCALLBACK_COLLISION);\n \n   Collisions();\n \n   // call UpdateWorld until the box hits the floor\n   while(!doAbort)\n\t  UpdateWorld();\n \n \n   return Terminate();\n}\n"
      },
      {
        "name": "EntityColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entitycolor-r139",
        "description": "Sets the entity color. This affects meshes, emitters, lights, and coronas only.\nEntity specific effects:\nA light's intensity is controllable with it's color by multiplying the components: EntityColor(light,Vec4(2)); makes the light twice as bright as EntityColor(light,Vec4(1));\nFor the other entity types, setting component values higher than 1.0 has no effect.",
        "c_syntax": "void EntityColor( TEntity entity, TVec4 &color, int recursive=0 )",
        "cpp_syntax": "void Entity::SetColor( const TVec4& color, int recursive=0 )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n \n\t// Create a graphics window\n\tGraphics(800,600);\n \n\t// Create a world\n\tif (!CreateWorld())\n\t{\n\t\tMessageBoxA(0,\"Error\",\"Failed to create world.\",0);\n\t\tgoto exitapp;\n\t}\n \n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Create a camera\n\tTEntity cam = CreateCamera();\n\tMoveEntity (cam, Vec3(0,0,-5) );\n \n\t// Create a visual mesh\n\tTEntity mesh = CreateCube();\n \n\t//Create another mesh to cast a shadow on\n\tTMesh ground=CreateCube();\n\tScaleMesh(ground,Vec3(10,0.1,10));\n\tPositionEntity(ground,Vec3(0,-2,0));\n \n\t//Create a spotlight\n\tTLight light=CreateSpotLight();\n\tPositionEntity(light,Vec3(2,2,-2));\n\tRotateEntity(light,Vec3(45,45,0));\n\tAmbientLight(Vec3(0.25));\n \n\t// Set the entity color\n\tEntityColor(light,Vec4(0,0,1,1));\n \n\t// Main program loop\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n \n\t\t// Make the visual mesh spin\n\t\tTurnEntity (mesh, Vec3(0.5f));\n \n\t\t// Update timing and physics\n\t\tUpdateWorld();\n \n \n\t\t//Make our render buffer the current buffer\n\t\tSetBuffer(buffer);\n \n\t\t//Render the world to the render buffer\n\t\tRenderWorld();\n \n\t\t//Make the back buffer the current buffer\n\t\tSetBuffer(BackBuffer());\n \n\t\t//Call the RenderLights command, passing our buffer which \n\t\t//contains color, depth, and normal data\n\t\tRenderLights(buffer);\n \n\t\t//Swap the buffers so we can see what was drawn\n\t\tFlip ();\n\t}\n \n\texitapp:\t\t\n\tTerminate();\n\treturn 0;\n}\n"
      },
      {
        "name": "EntityCulled",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityculled-r147",
        "description": "Returns 0 if the entity is visible from the specified camera, else 1 is returned. Returns True if the specified entity is visible to the camera. There are two typs of culling. Frustrum culling detects whether an entity intersects the bounds of the camera frustrum. Occlusion culling is performed on the GPU, and detects whether any pixels of an object are visible when the object is drawn. Occlusion culling works with the entity's bounding box, so it is only a rough approximation, but it errs on the side of safety; Occlusion culling might say an object is visible when it is not, but it won't say an object is occluded when it is visible.",
        "c_syntax": "int EntityCulled( TEntity entity, TEntity camera )",
        "cpp_syntax": "bool Entity::IsCulled( const Camera& cam ) const",
        "example": "\n\n"
      },
      {
        "name": "EntityDistance",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entitydistance-r137",
        "description": "Returns the distance between two entities. Distance is calculated from the entity global positions.",
        "c_syntax": "flt EntityDistance( TEntity entity1, TEntity entity2 )",
        "cpp_syntax": "flt Entity::GetDistance( const TEntity ent ) const",
        "example": "\n//Entity distance demonstrating\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"Entity Distance\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\n\t//copy cube\n\tTEntity copycube = CopyEntity(basecube); \n\tPositionEntity(copycube, Vec3(3,0,0));\n\n\tfloat distance;\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t{\n\t\t\tMoveEntity(copycube, Vec3(1,0,0));\n\t\t}\n\t\tif(KeyHit(KEY_LEFT))\n\t\t{\n\t\t\tMoveEntity(copycube, Vec3(-1,0,0));\n\t\t}\n\n\t\t//get the distance\n\t\tdistance = EntityDistance(copycube, basecube);\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0, 0, \"Distance between the 2 cubes: %f \", distance);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "EntityExists",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityexists-r151",
        "description": "Returns 1 if the specified entity exists otherwise 0.",
        "c_syntax": "EntityExists( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n//EntityExists demonstrating\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"EntityExists\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(EntityExists(basecube) == 1)\n\t\t{\n\t\t\t//copy cube\n\t\t\tTEntity copycube = CopyEntity(basecube); \n\t\t\tPositionEntity(copycube, Vec3(3,0,0));\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,15, \"Check if the entity basecube exists. If it does, make the copycube.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "EntityHidden",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityhidden-r150",
        "description": "Returns True if an entity is hidden. Hidden entities will not be visible, will not collide, and will not be picked with raycasts. Hiding is recursive; If an entity is hidden, all its children will be as well.",
        "c_syntax": "int EntityHidden( TEntity entity )",
        "cpp_syntax": "bool Entity::IsHidden( void ) const",
        "example": "\n//Check if an entity is hidden\n#include \"engine.h\"\n  \nint hidden(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"EntityHidden\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tHideEntity(basecube);\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(EntityHidden(basecube) == 1)\n\t\t\t{\n\t\t\t\t\tShowEntity(basecube);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,15, \"Press the space key to check if the base cube is hidden. If it is hidden, show it.\");\n\t\tFlip(1);\n\t}\n\n\treturn Terminate();\n\n}\n"
      },
      {
        "name": "EntityOcclusionMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityocclusionmode-r146",
        "description": "Sets the entity occlusion mode. If the occlusion mode is False, the entity will not have occlusion culling performed on it. Occlusion culling should be disabled for small low-cost objects, since performing the occlusion rendering might take more time than just rendering the object. Occlusion culling is enabled for lights, animated meshes and groups by default.\nBoth of these techniques that help avoiding \"out-of-view-drawing\" are supported by Leadwerks Engine.",
        "c_syntax": "void EntityOcclusionMode( TEntity entity, int mode, int resursive=0 )",
        "cpp_syntax": "void Entity::SetOcclusionMode( int mode )",
        "example": "\n\n"
      },
      {
        "name": "EntityOrder",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityorder-r153",
        "description": "Sets the entity order of road nodes. Higher order roads appear on top of lower order roads. The default value for order is 0.",
        "c_syntax": "void EntityOrder( TEntity entity, int order=0, int recursive=0 )",
        "cpp_syntax": "void Entity::SetOrder( Entity parent, int order=0, int recursive=0 )",
        "example": "\n\n"
      },
      {
        "name": "EntityParent",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityparent-r152",
        "description": "Joins an entity as child entity to a parent entity. The child moves with the parent when the parent moves.",
        "c_syntax": "void EntityParent( TEntity entity, TEntity parent, int global=1 )",
        "cpp_syntax": "void Entity::SetParent( Entity parent, const EntityTypes& type = Global ) Where type is Local or Global",
        "example": "\n//Set the parent for an entity\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"EntityParent\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-4,0,0));\n\n\tTEntity basecube2 = CreateCube(0); \n\tPositionEntity(basecube2, Vec3(4,0,0));\n\n\t//Parent basecube2 to basecube\n\tEntityParent(basecube2, basecube);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveEntity(basecube,Vec3(1,0,0));\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space move the left cube. Due to parenting the right cube moves as well.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n\n}\n"
      },
      {
        "name": "EntityPosition",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityposition-r131",
        "description": "ntityPosition retrieves the position of an entity. The optional global parameter can be set to True to return the position in global space, otherwise the position relative to the entity's parent is returned. If the entity has no parent, the local and global position are the same.\nThe function returns a Vec3 object. You can then retrieve the X, Y, or Z components individually.\nTEntity Entity:\nThe entity to retrieve the position from\nTVec3 *Position:\nThe TVec3 to store the position in. Pass variables by reference (&PosVar)\nint Global\t 0 = local space , 1 = global space",
        "c_syntax": "TVec3 EntityPosition( TEntity entity, int global=0 )",
        "cpp_syntax": "TVec3 Entity::GetPosition( const EntityTypes& type = LOCAL ) Where type is either LOCAL or GLOBAL",
        "example": "\n//Retrieve an entities position\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"EntityPosition\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-2,0,0));\n\n\tTEntity basecube2 = CreateCube(0); \n\tPositionEntity(basecube2, Vec3(2,0,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\t//retrieve the position of basecube 2 and use it to position basecube.\n\t\t\tPositionEntity(basecube,EntityPosition(basecube2));\n\t\t}\n\t\t\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space to place the left cube at the same position as the right cube by retrieving the right cube's position.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "EntityQuat",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityquat-r134",
        "description": "EntityQuat retrieves the quaternion rotation of an entity. Quaternions are an advanced method of storing rotations.",
        "c_syntax": "TVec4 EntityQuat(TEntity entity)",
        "cpp_syntax": "TVec4 Entity::GetQuat( void ) const",
        "example": "\n\n"
      },
      {
        "name": "EntityRotation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityrotation-r132",
        "description": "EntityRotation retrieves the rotation of an entity. The optional global parameter can be set to True to return the rotation in global space, otherwise the rotation relative to the entity's parent is returned. If the entity has no parent, the local and global rotation are the same.",
        "c_syntax": "TVec3 EntityRotation( TEntity entity, int global=0 )",
        "cpp_syntax": "TVec3 Entity::GetRotation( const EntityTypes& type = LOCAL ) Where type is either LOCAL or GLOBAL",
        "example": "\n//Retrieve an entities rotation\n#include \"engine.h\"\n  \nint entityrotation(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"Entityrotation\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-4,0,0));\n\tRotateEntity(basecube, Vec3(45,0,0));\n\n\tTEntity basecube2 = CreateCube(0); \n\tPositionEntity(basecube2, Vec3(4,0,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tRotateEntity(basecube2,EntityRotation(basecube));\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space to retrieve the rotation of the left cube and set that rotation to the right cube.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n\n}\n"
      },
      {
        "name": "EntityScale",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityscale-r133",
        "description": "EntityScale retrieves the scale of an entity. The function returns a Vec3 object. You can then retrieve the X, Y, or Z components individually.",
        "c_syntax": "TVec3 EntityScale(TEntity entity)",
        "cpp_syntax": "TVec3 Entity::GetScale( void ) const",
        "example": "\n//Retrieve an entities scale\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"EntityScale\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-4,0,0));\n\tScaleEntity(basecube, Vec3(2,3,2));\n\n\tTEntity basecube2 = CreateCube(0); \n\tPositionEntity(basecube2, Vec3(4,0,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tScaleEntity(basecube2,EntityScale(basecube));\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space to retrieve the scale of the left cube and set that scale to the right cube.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n\n}\n"
      },
      {
        "name": "EntityShadowMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityshadowmode-r142",
        "description": "Sets the entity shadow mode. mode can be any (bitwise-)OR (|) combination of the followingSHADOW_DISABLED (= 0 = No shadows)SHADOW_DYNAMIC (1)SHADOW_STATIC (2)SHADOW_BUFFERED (4)SHADOW_COLOR (8)\nThe default shadow mode for all lights is SHADOW_DYNAMIC|SHADOW_STATIC (3).\nFor point and spot lights, use SHADOW_DISABLED, SHADOW_DYNAMIC, SHADOW_STATIC, SHADOW_DYNAMIC|SHADOW_STATIC or SHADOW_DYNAMIC|SHADOW_STATIC|SHADOW_BUFFERED (7).\nFor global illumination lightmaps, use SHADOW_COLOR.\nThe default shadow mode for terrains is SHADOW_DISABLED. The default shadow mode for all other entities is SHADOW_DYNAMIC.\nFor meshes, models and terrains, you can use either SHADOW_DISABLED, SHADOW_DYNAMIC, or SHADOW_STATIC.",
        "c_syntax": "void EntityShadowMode( TEntity entity, int mode, int recursive=0 )",
        "cpp_syntax": "void Entity::SetShadowMode( int mode, const Recursion& recursive = NonRecursive )",
        "example": "\n\n"
      },
      {
        "name": "EntityShadowRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityshadowrange-r141",
        "description": "Sets the entity shadow distance. If the entity is further away from the camera than the specified range, it will not cast a shadow. The default entity shadow distance is 100.",
        "c_syntax": "void EntityShadowRange( TEntity entity, flt range=100, int recursive=0 )",
        "cpp_syntax": "void Entity::SetShadowRange( flt range, const Recursion& recursive = NonRecursive ) Where recursove is Recursive or NonRecursive",
        "example": "\n\n"
      },
      {
        "name": "EntityType",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entitytype-r138",
        "description": "Sets the entity collision type. If the recursive parameter is set to 1, all children in the entity's hierarchy will be set as well.",
        "c_syntax": "void EntityType( TEntity entity, int collisionType=1, int recursive=0 )",
        "cpp_syntax": null,
        "example": "\n//This programm creates 2 body boxes. By setting an entity type it is easy to collide bodies with each other\n#include \"engine.h\"\n \nint createbodybox(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Setting an entity type.\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,1,1);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Setting an entity type\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "EntityViewRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/entityviewrange-r140",
        "description": "Sets the entity view range. The entity will not be drawn if it is further from the camera than the far view range. Some entities like coronas use a near fade distance to gradually fade from view.If the recursive parameter is set to 1, all children in the entity's hierarchy will be set as well. The entity view range is a number for the view range category from 0 to 3:VIEWRANGE_NEAR = 0 // default: 50 unitsVIEWRANGE_MEDIUM = 1 // default: 125 unitsVIEWRANGE_FAR = 2 // default: 250 unitsVIEWRANGE_INFINITE = 3 // infinite units\nThe entity will not be drawn if it is further from the camera than the view range. If the recursive parameter is set to 1, all children in the entity's hierarchy will be set as well.\nTo change the world's view ranges, use SetWorldCullRange.",
        "c_syntax": "void EntityViewRange( TEntity entity, int range=VIEWRANGE_NEAR, int recursive=0 )",
        "cpp_syntax": "void Entity::SetViewRange( int range=VIEWRANGE_NEAR, const Recursion& recursion = NonRecursive ) Where recursion is Recursive or NonRecursive",
        "example": "\n#include \"engine.h\"\n \n#define VIEWRANGE 10\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tTCamera camera = CreateCamera(); MoveEntity(camera, Vec3(0,0,-3));\n \n\tTEntity cube = CreateCube(); \n\tEntityViewRange(cube,0,VIEWRANGE);\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n \n\t\tif(KeyDown(KEY_UP))MoveEntity(camera, Vec3(0,0,0.1));\n\t\tif(KeyDown(KEY_DOWN))MoveEntity(camera, Vec3(0,0,-0.1));\n \n\t\tDrawText(0,0,\"The cube's view range is %d.\",VIEWRANGE);\n\t\tDrawText(0,15,\"Use the UP/DOWN arrow keys to move the camera.\");\n\t\tDrawText(0,30,\"Distance cube <-> camera = %f\", EntityDistance(cube, camera));\n \n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n\n"
      },
      {
        "name": "FindChild",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/findchild-r156",
        "description": "Finds a child entity of the specified entity by its \"name\" keyvalue. This can be used to find a specific limb in a loaded model to attach an item to.",
        "c_syntax": "TEntity FindChild( TEntity entity, str name )",
        "cpp_syntax": "Entity Entity::FindChild( const_str name )",
        "example": "\n\n"
      },
      {
        "name": "ForEachEntityDo",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/foreachentitydo-r163",
        "description": "Scans all entities in the current world, and calls a user defined function for each entity found. The user defined function must be defined as int _stdcall myfunc( TEntity entity, byte* extra ). \nThe function must return 1 to continue the loop, and may return 0 to stop the loop.",
        "c_syntax": "void ForEachEntityDo(byte* function, byte* extra=NULL, int classes=ENTITY_ALL)",
        "cpp_syntax": "void Entity::ForEachDo( BP function, BP extra = 0, int classes = ENTITY_ALL )",
        "example": "\n\n"
      },
      {
        "name": "ForEachEntityInAABBDo",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/foreachentityinaabbdo-r164",
        "description": "Scans all entities in the current world that are inside the specified region, and calls a user defined function for each entity found. The user defined function must be defined as follows\ncallback is a function pointer to user made function defined as void _stdcall myfunc( TEntity entity, byte* extra)",
        "c_syntax": "void ForEachEntityInAABBDo(TVec6 &aabb, byte* callback, byte* extra=NULL, int entityclass=ENTITY_ALL)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "FreeEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/freeentity-r121",
        "description": "Frees an entity from memory.",
        "c_syntax": "void FreeEntity( TEntity entity )",
        "cpp_syntax": "void Entity::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "FreeEntityCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/freeentitycallback-r173",
        "description": "callbackID: ENTITYCALLBACK_FREE. This will be called when the entity is (manually) freed. Note that the function can of course have any name. See the examples page for more info.",
        "c_syntax": "void _stdcall FreeEntityCallback( TEntity entity )Example\n//This",
        "cpp_syntax": null,
        "example": "\n//This example reserves some memory and stores the pointer to it in the entity's UserData field. It'll be retrived and freed in the free callback.\n#include \"engine.h\"\n \nvoid _stdcall FreeEntityCallback( TEntity entity ) \n{\n\tfloat* someData = (float*)GetEntityUserData(entity);\n \n\tchar str[256];\n\tsprintf(str, \"FreeEntityCallback has been called for %d\\nsomeData was set to: %.3f\", (int)entity, *someData);\n\tMessageBox(0, str, \"FreeEntityCallback called\", 0);\n \n\t// free the memory\n\tdelete someData;\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n \n\tTEntity cube = CreateCube();\n \n\tfloat* someData = new float; // reserve some memory\n\t*someData = 123.456f;\n\tSetEntityUserData(cube, (byte*)someData);\n \n\tSetEntityCallback(cube,(byte*)FreeEntityCallback,ENTITYCALLBACK_FREE); // set the callback\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "GetChild",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getchild-r155",
        "description": "Returns the nth child of the given entity. Children are numbered 1 to CountChildren(). Attempting to access a child out of this range will result in a memory exception.",
        "c_syntax": "TEntity GetChild( TEntity entity, int n=1 )",
        "cpp_syntax": "Entity Entity::GetChild( int index ) const",
        "example": "\n//Get the child of the parent\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"GetChild\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-4,0,0));\n\n\tTEntity basecube2 = CreateCube(0); \n\n\tTEntity basecube3 = CreateCube(0); \n\tPositionEntity(basecube3, Vec3(4,0,0));\n\n\t//Parent basecube2 to basecube\n\tEntityParent(basecube2, basecube);\n\tEntityParent(basecube3, basecube);\n\n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\t//retrieve the middle cube\n\t\t\tMoveEntity(GetChild(basecube, 1) ,Vec3(0,1,0));\n\t\t\t\n\t\t\t//retrieve the right cube\n\t\t\tMoveEntity(GetChild(basecube, 2) ,Vec3(0,2,0));\n\t\t}\n\t\t\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space Retrieve the 2 children of basecube. The middle one and the right one will move up.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n\n}\n"
      },
      {
        "name": "GetEntityAABB",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentityaabb-r136",
        "description": "Retrieves the entity AABB (Axis-Aligned Bounding Box). This is 2 points that store the minimum and maximum extents of the entity's 3D volume, in global space.",
        "c_syntax": "TVec6 GetEntityAABB(TEntity entity)",
        "cpp_syntax": "TVec6 Entity::GetAABB( void ) const",
        "example": "\n#include \"engine.h\"\n#include <math.h>\n \nvoid createBBMarkers(const TVec6& aabb)\n{\n\tTEntity marker[8];\n\tfor(int i = 0; i < 8;i++)\n\t{\n\t\tmarker[i] = CreateSphere();\n\t\tScaleEntity(marker[i], Vec3(0.04));\n\t\tEntityColor(marker[i],Vec4(1,0,0,1));\n\t}\n \n\tPositionEntity(marker[0], Vec3(aabb.X0,aabb.Y0,aabb.Z0));\n\tPositionEntity(marker[1], Vec3(aabb.X1,aabb.Y0,aabb.Z0));\n\tPositionEntity(marker[2], Vec3(aabb.X0,aabb.Y0,aabb.Z1));\n\tPositionEntity(marker[3], Vec3(aabb.X1,aabb.Y0,aabb.Z1));\n \n\tPositionEntity(marker[4], Vec3(aabb.X0,aabb.Y1,aabb.Z0));\n\tPositionEntity(marker[5], Vec3(aabb.X1,aabb.Y1,aabb.Z0));\n\tPositionEntity(marker[6], Vec3(aabb.X0,aabb.Y1,aabb.Z1));\n\tPositionEntity(marker[7], Vec3(aabb.X1,aabb.Y1,aabb.Z1));\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n\tWireframe(1);\n \n\tTCamera camera = CreateCamera(); \n \n\tTEntity mesh = LoadMesh(\"abstract::tree_palm01.gmf\"); \n\tTVec6 aabb = GetEntityAABB(mesh);\n\tcreateBBMarkers(aabb);\n \n\tTEntity bb = CreateCube();\n\tScaleEntity(bb, Vec3(abs(aabb.X1-aabb.X0), abs(aabb.Y1-aabb.Y0), abs(aabb.Z1-aabb.Z0)));\n\tPositionEntity(bb, Vec3(abs(aabb.X1-aabb.X0)/2.0f+aabb.X0, abs(aabb.Y1-aabb.Y0)/2.0f+aabb.Y0, abs(aabb.Z1-aabb.Z0)/2.0f+aabb.Z0));\n\tPositionEntity(camera, Vec3(abs(aabb.X1-aabb.X0)/2.0f+aabb.X0, abs(aabb.Y1-aabb.Y0)/2.0f+aabb.Y0, abs(aabb.Z1-aabb.Z0)/2.0f+aabb.Z0));\n \n\tMoveEntity(camera, Vec3(0,0,-3));\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tUpdateAppTime();\n\t\tRenderWorld();\n \n\t\tif(KeyDown(KEY_UP))MoveEntity(camera, Vec3(0,0,0.1));\n\t\tif(KeyDown(KEY_DOWN))MoveEntity(camera, Vec3(0,0,-0.1));\n \n\t\tDrawText(0,0,\"Creates a bounding box cube around any mesh using GetEntityAABB.\");\n\t\tDrawText(0,15,\"Use the UP/DOWN arrow keys to move the camera.\");\n\t\tDrawText(0,30,\"AABB: %f %f %f  %f %f %f\",aabb.X0,aabb.Y0,aabb.Z0,aabb.X1,aabb.Y1,aabb.Z1);\n \n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "GetEntityKey",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentitykey-r167",
        "description": "Returns the key value for the specified key name. If the key name is not set, the default value will be returned. Some keys are set automatically by the engine (some under specific conditions). See the command's example page for more info on this.",
        "c_syntax": "str GetEntityKey( TEntity entity, str keyname, str defaultvalue=\"\" )",
        "cpp_syntax": "str Entity::GetKey( const_str keyname, const_str defaultvalue = \"\" )",
        "example": "\n\n"
      },
      {
        "name": "GetEntityMaterial",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentitymaterial-r149",
        "description": "Returns the entity's material. This value may be Null.",
        "c_syntax": "TMaterial GetEntityMaterial( TEntity entity )",
        "cpp_syntax": "Material Entity::GetMaterial( void )",
        "example": "\n\n"
      },
      {
        "name": "GetEntityMatrix",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentitymatrix-r135",
        "description": "Retrieves the global entity matrix and recalculates local position, rotation, quaternion, and scale. This is an advanced mathematics command.",
        "c_syntax": "TVec16 GetEntityMatrix(TEntity entity)",
        "cpp_syntax": "TVec16 Entity::GetMatrix( void ) const",
        "example": "\n\n"
      },
      {
        "name": "GetEntityTarget",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentitytarget-r170",
        "description": "Retrieves an entity target. This is a safe way to make entities reference one another. This function may return Null.",
        "c_syntax": "TEntity GetEntityTarget( TEntity entity, int index=0 )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "GetEntityType",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentitytype-r148",
        "description": "Retrieves the entity collision type. Collision types tell the engine how different entities should react when they collide.",
        "c_syntax": "int GetEntityType( TEntity entity )",
        "cpp_syntax": "int Entity::GetType( void ) const",
        "example": "\n//This programm creates 3 body boxes. By setting an entity type it is easy to collide bodies with each other\n//Retrieve the entitype with the GetEntityType command\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Getting an entity type.\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTEntity\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tPositionEntity\t(box, Vec3(0,2,0));\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,2);\n\n\t//Create a body box\n\tTBody\t\t\tbox2 = CreateBodyBox(1,3,2);\n\tPositionEntity\t(box2, Vec3(0,5,0));\n\tSetBodyMass\t\t(box2, 10);\n\tEntityType\t\t(box2, 3);\n\n\t//Create a body box\n\tTBody\t\t\tbox3 = CreateBodyBox(1,3,2);\n\tPositionEntity\t(box3, Vec3(0,8,0));\n\tSetBodyMass\t\t(box3, 10);\n\tEntityType\t\t(box3, 4);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,2,1); //plane and box1\n\tCollisions(1,3,1); //plane and box2\n\tCollisions(1,4,1); //plane and box3\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Getting an entity type. All boxes collide with the floor but not with each other\");\n\t\t\tDrawText(0,15, \"Box 1: %f\", GetEntityType(box));\n\t\t\tDrawText(0,30, \"Box 2: \");\n\t\t\tDrawText(0,40, \"Box 3: \");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "GetEntityUserData",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getentityuserdata-r172",
        "description": "Returns the pointer which was assigned to the entity using SetEntityUserData.",
        "c_syntax": "byte* GetEntityUserData(TEntity entity)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "GetParent",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/getparent-r157",
        "description": "Returns the parent of the specified entity. This function may return Null.",
        "c_syntax": "TEntity GetParent(TEntity entity)",
        "cpp_syntax": "TEntity Entity::GetParent( void ) const",
        "example": "\n\n"
      },
      {
        "name": "HideEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/hideentity-r144",
        "description": "Hides an entity. Hidden entities will not be visible, will not collide, and will not be picked with raycasts. Hiding is recursive; If an entity is hidden, all its children will be as well.",
        "c_syntax": "void HideEntity( TEntity entity )",
        "cpp_syntax": "virtual void Entity::Hide( void )",
        "example": "\n//HideEntity and ShowEntity demonstrating\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"Hide and show entity\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_LEFT))\n\t\t{\n\t\t\tShowEntity(basecube);\n\t\t}\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t{\n\t\t\tHideEntity(basecube);\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,15, \"Press the left key to show the cube, Press the right key to hide the cube.\");\n\t\tFlip(1);\n\t}\n"
      },
      {
        "name": "MessageReceiveCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/messagereceivecallback-r177",
        "description": "CallbackID: ENTITYCALLBACK_MESSAGERECEIVE. This will be called when an entity receives a message. That is, immediately after the message is sent if the delay was 0 or during the first UpdateWorld call after the message was sent in which the delay time is reached. Note that the function can of course have any name. See the examples page for more info.",
        "c_syntax": "void _stdcall MessageReceiveCallback( TEntity entity, str message, byte* extra )",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nvoid _stdcall MessageReceiveCallback( TEntity entity, str message, byte* extra ) \n{\n\tchar str[256];\n\tsprintf(str, \"%d got a message. Message name: \\\"%s\\\"\", (int)entity, message);\n\tMessageBox(0, str, \"MessageReceiveCallback called\", 0);\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n \n\tTEntity cube = CreateCube();\n\tSetEntityCallback(cube,(byte*)MessageReceiveCallback,ENTITYCALLBACK_MESSAGERECEIVE);\n\tSendEntityMessage(cube, \"Hello World!\");\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MoveEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/moveentity-r126",
        "description": "Moves an entity relative to its own axes. This will add the specified vector to the entity's local position and reposition the entity.",
        "c_syntax": "void MoveEntity(TEntity entity, TVec3 &direction=Vec3(1), int global=0)",
        "cpp_syntax": "virtual void Entity::Move( const Vector3& movement )\nvirtual void Entity::Move( flt x, flt y, flt z )",
        "example": "\n\n"
      },
      {
        "name": "PaintEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/paintentity-r143",
        "description": "Sets the entity material. The material parameter may be Null. If the recursive parameter is set to 1, all children in the entity's hierarchy will be painted as well.\nIf this is used on a spot light, the material's texture0 will be used as a projected image (can be used for e.g. spotlight patterns).",
        "c_syntax": "void PaintEntity( TEntity entity, TEntity material, int recursive=0 )",
        "cpp_syntax": "virtual void Entity::Paint( const Material& mat, const Recursion& recursion = NonRecursive )ExampleThis",
        "example": "This example shows how to load a material that comes with the engine and then paint this material onto a cube.\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"PaintEntity Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(3,3,3) ); \n\tTMaterial material = LoadMaterial(\"abstract::oildrum.mat\");\n\tPaintEntity(cube,material);\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(45,45,0), 0);\n \n\tAmbientLight(Vec3(.05,.05,.2));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,0.5,0.2), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "PointEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/pointentity-r129",
        "description": "Points an entity at another entity, along any axis. The axis parameter indicates which axis to align. Use 1 for x, 2 for y, and 3 for the z axis. A rate value of less than 1.0 will gradually change orientation over several frames. The roll value controls the entity's rotation around the vector.",
        "c_syntax": "void PointEntity( TEntity entity1, TEntity entity2, int axis=3, flt rate=1, flt roll=0 )",
        "cpp_syntax": "virtual void Entity::Point( const TEntity ent, const Axis& axis = LEO::Z, flt rate = 1.0f, flt roll = 0.0f ) Where axis is one of X, Y, Z",
        "example": "\n\n"
      },
      {
        "name": "PositionEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/positionentity-r1",
        "description": "PositionEntity will position the specified entity at any specified position in 3d space. If the optional global parameter is set to True the entity will be positioned in global space. The default value of False will position the entity relative to its parent entity. If the entity does not have a parent, the global and local space are the same.",
        "c_syntax": null,
        "cpp_syntax": null,
        "example": "\n//Position an entity\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"PositionEntity\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a cube and scale it\n\tTEntity\t\t\tcube = CreateCube();\n\tPositionEntity\t\t(cube,  Vec3(5,-3, 4) );\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Position an entity.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "RotateEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/rotateentity-r123",
        "description": "RotateEntity will rotate the specified entity at any specified euler angle. If the optional global parameter is set to True the entity will be rotated in global space. The default value of False will rotate the entity relative to its parent entity. If the entity does not have a parent, the global and local space are the same.",
        "c_syntax": "void RotateEntity( TEntity entity, TVec3 &rotation, int global )",
        "cpp_syntax": "void Entity::SetRotation( const TVec3& rot, const EntityTypes& type = LOCAL ) Where type is either LOCAL or GLOBAL\nvoid Entity::SetRotation( flt x, flt y, flt z , const EntityTypes& type = LOCAL )\nvoid Entity::SetRotation( const Entity& ent , const EntityTypes& type = LOCAL ) Same rotation as the other Entity\nvoid Entity::SetRotation( float v, const EntityTypes& type = LOCAL )",
        "example": "\n//Rotate an entity\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"RotateEntity\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a cube and rotate it\n\tTEntity\t\t\tcube = CreateCube();\n\tRotateEntity\t(cube, Vec3(45,0,0));\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Rotate an entity.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "ScaleEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/scaleentity-r124",
        "description": "ScaleEntity will scale an entity along its three axes. This can be used to change the size of an entity. Scaling should not be used with physics bodies.",
        "c_syntax": "void ScaleEntity( TEntity entity, TVec3 &scale )",
        "cpp_syntax": "void Entity::SetScale( const TVec3& scale )\nvoid Entity::SetScale( flt x, flt y, flt z )\nvoid Entity::SetScale( const Entity& ent ) Scale same as the other Entity\nvoid Entity::SetScale( float v )",
        "example": "\n//Scale an entity\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"ScaleEntity\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a cube and scale it\n\tTEntity\t\t\tcube = CreateCube();\n\tScaleEntity\t\t(cube,  Vec3(6,1,10) );\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Scale an entity.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SendEntityMessage",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/sendentitymessage-r166",
        "description": "Sends a message to an entity. If the entity has a callback specified for the message receive event, the callback function will be called. The optional delay value defines a time in milliseconds that will elapse before the message is sent.",
        "c_syntax": "void SendEntityMessage( TEntity entity, str message, int delay=0, byte* extra=0 )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetEntityCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/setentitycallback-r165",
        "description": "Set an entity's callbacks. The following callback IDs may be used:ENTITYCALLBACK_MESSAGERECEIVE - will be called when the entity receives a message.ENTITYCALLBACK_FREE - will be called when the entity is freed.ENTITYCALLBACK_COLLISION - will be called when the entity collides with another entity (bodies and terrain only).ENTITYCALLBACK_UPDATE - will be called once each time UpdateWorld() is called.ENTITYCALLBACK_UPDATEMATRIX - will be called whenever an entity rotates or moves.ENTITYCALLBACK_UPDATEPHYSICS - will be called 60 times a second for each physics body.\nSee here how these functions have to be structed.",
        "c_syntax": "void SetEntityCallback( TEntity entity, byte* callback, int callbackID )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetEntityKey",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/setentitykey-r168",
        "description": "Sets the specified key name to the key value. Key names and values are user-defined properties.",
        "c_syntax": "void SetEntityKey( TEntity entity, str keyname, str keyvalue )",
        "cpp_syntax": "void Entity::SetKey( const_str keyname, const_str keyvalue )",
        "example": "\n\n"
      },
      {
        "name": "SetEntityMatrix",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/setentitymatrix-r130",
        "description": "Sets the global entity matrix and recalculates local position, rotation, quaternion, and scale. This is an advanced mathematics command.",
        "c_syntax": "void SetEntityMatrix( TEntity entity, TVec16 &matrix )",
        "cpp_syntax": "void Entity::SetEntityMatrix( const TVec16& matrix )",
        "example": "\n\n"
      },
      {
        "name": "SetEntityTarget",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/setentitytarget-r169",
        "description": "Sets an entity target. This is a safe way to make entities reference one another. If the target entity is freed, the reference to it will be deleted.",
        "c_syntax": "void SetEntityTarget( TEntity entity, TEntity target, int index=0 )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetEntityUserData",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/setentityuserdata-r171",
        "description": "Use this to point to some memory structure holding object specific data which can be retrieved later. You can e.g. free the allocated memory in the ENTITYCALLBACK_FREE.",
        "c_syntax": "void SetEntityUserData(TEntity entity, byte* data=NULL)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "ShowEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/showentity-r145",
        "description": "Shows an entity. Hidden entities will not be visible, will not collide, and will not be picked with raycasts. Hiding is recursive; If an entity is hidden, all its children will be as well.",
        "c_syntax": "void ShowEntity( TEntity entity )",
        "cpp_syntax": "virtual void Entity::Show( void )",
        "example": "\n//HideEntity and ShowEntity demonstrating\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"Hide and show entity\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\tif(KeyHit(KEY_LEFT))\n\t\t{\n\t\t\tShowEntity(basecube);\n\t\t}\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t{\n\t\t\tHideEntity(basecube);\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,15, \"Press the left key to show the cube, Press the right key to hide the cube.\");\n\t\tFlip(1);\n\t}\n"
      },
      {
        "name": "TFormNormal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/tformnormal-r160",
        "description": "Transforms a normal from the coordinate system of the src entity to the coordinate system of dst entity. Either entities may be Null for global space. This command is the same as TFormVector, except the result is normalized.",
        "c_syntax": "TVec3 TFormNormal(TVec3 &normal, TEntity src, TEntity dst)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TFormPlane",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/tformplane-r162",
        "description": "Transforms a plane from the coordinate system of the src entity to the coordinate system of dst entity. Either entities may be Null for global space.",
        "c_syntax": "TVec4 TFormPlane(TVec3 &plane, TEntity src, TEntity dst)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TFormPoint",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/tformpoint-r158",
        "description": "Transforms a point from the coordinate system of the src entity to the coordinate system of dst entity. Either entities may be Null for global space.",
        "c_syntax": "TVec3 TFormPoint(TVec3 &point, TEntity src, TEntity dst)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TFormQuat",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/tformquat-r161",
        "description": "Transforms a quaternion from the coordinate system of the src entity to the coordinate system of dst entity. Either entities may be Null for global space.",
        "c_syntax": "TVec4 TFormQuat(TVec4 &quaternion, TEntity src, TEntity dst)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TFormVector",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/tformvector-r159",
        "description": "Transforms a vector from the coordinate system of the src entity to the coordinate system of dst entity. Either entities may be Null for global space.",
        "c_syntax": "TVec3 TFormVector(TVec3 &vector, TEntity src, TEntity dst)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TranslateEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/translateentity-r128",
        "description": "Moves an entity along its parent's axes. If the optional global parameter is set to True, the entity will be translated in world space.",
        "c_syntax": "void TranslateEntity( TEntity entity, TVec3 &translation, int global )",
        "cpp_syntax": "virtual void Entity::Translate( const TVec3& position, const EntityTypes& type = LOCAL ) Where type is either LOCAL or GLOBAL\nvirtual void Entity::Translate( flt x, flt y, flt z, const EntityTypes& type = LOCAL )",
        "example": "\n//Translate an entity\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"TranslateEntity\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-2,0,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tTranslateEntity(basecube, Vec3(0.01,0,0));\t\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tTranslateEntity(basecube, Vec3(-0.2,0,0));\t\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press space to translate the cube to the left.\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "TurnEntity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/turnentity-r125",
        "description": "Turns an entity by the given rotation amount in degrees. The optional global parameter can be used to turn an entity in global space.",
        "c_syntax": "void TurnEntity( TEntity entity, TVec3 &rotation, int global=0 )",
        "cpp_syntax": "virtual void Entity::Turn( const Vector3& rotation, const EntityTypes& type = LOCAL ) Where type is either LOCAL or GLOBAL\nvirtual void Entity::Turn( flt x, flt y, flt z , const EntityTypes& type = LOCAL );",
        "example": "\n//Turning an entity\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"TurnEntity\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n\tPositionEntity(basecube, Vec3(-2,0,0));\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tTurnEntity(basecube, Vec3(5,5,5));\t\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Spinning cube\");\n\t\tFlip(1);\n\t}\n\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "UpdateEntityCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/updateentitycallback-r178",
        "description": "CallbackID: ENTITYCALLBACK_UPDATE. This will be called once when the UpdateWorld() command is called. Note that the function can of course have any name. See the examples page for more info.",
        "c_syntax": "void _stdcall UpdateEntityCallback( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nvoid _stdcall UpdateEntityCallback( TEntity entity ) \n{\n\tchar str[256];\n\tsprintf(str, \"UpdateEntityCallback has been called for %d\", (int)entity);\n\tMessageBox(0, str, \"UpdateEntityCallback called\", 0);\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n \n\tTEntity cube = CreateCube();\n\tSetEntityCallback(cube,(byte*)UpdateEntityCallback,ENTITYCALLBACK_UPDATE);\n\tUpdateWorld(); // calls UpdateEntityCallback\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "UpdateMatrixCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/updatematrixcallback-r175",
        "description": "This will be called whenever the entity moves or rotates. Note that the function can have any name.",
        "c_syntax": "void _stdcall UpdateMatrixCallback( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nvoid _stdcall UpdateMatrixCallback( TEntity entity ) \n{\n\tchar str[256];\n\tsprintf(str, \"UpdateMatrixCallback has been called for %d\", (int)entity);\n\tMessageBox(0, str, \"UpdateMatrixCallback called\", 0);\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n \n\tTEntity cube = CreateCube();\n\tSetEntityCallback(cube,(byte*)UpdateMatrixCallback,ENTITYCALLBACK_UPDATEMATRIX);\n\tMoveEntity(cube, Vec3(0)); // every movement/rotation causes a call to the UpdateMatrixCallback function\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "UpdatePhysicsCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/entities/updatephysicscallback-r174",
        "description": "This will be called 60 times per second, regardless of framerate. This should be used for physics updates because the physics simulation will be interpolated and smoothed each frame. The physics callback is performed during the UpdateWorld() routine, but it might not be called each frame, or it might be called multiple times in one frame. Note that the function can have any name.",
        "c_syntax": "void _stdcall UpdatePhysicsCallback( TEntity entity )",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nvoid _stdcall UpdatePhysicsCallback( TEntity entity ) \n{\n\tchar str[256];\n\tsprintf(str, \"UpdatePhysicsCallback has been called for %d\", (int)entity);\n\tMessageBox(0, str, \"UpdatePhysicsCallback called\", 0);\n}\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics();\n\tCreateWorld();\n \n\tTEntity bodyBox = CreateBodyBox();\n\tSetEntityCallback(bodyBox,(byte*)UpdatePhysicsCallback,ENTITYCALLBACK_UPDATEPHYSICS);\n\tSetBodyMass(bodyBox);\n\tCollisions();\n\tUpdateWorld(2); // calls UpdatePhysicsCallback twice, since the stepsize indicates that the game is running at 30 FPS right now\n\t// so two physics updates have to be done in 1 frame\n \n\treturn Terminate();\n}\n"
      }
    ]
  },
  {
    "name": "File System",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/file-system/",
    "members": [
      {
        "name": "AbstractPath",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/file-system/abstractpath-r180",
        "description": "Returns the absolute file name of an abstract file name.",
        "c_syntax": "str AbstractPath( str path )",
        "cpp_syntax": "std::str Engine::GetAbstractPath( const_str path )",
        "example": "\n\n"
      },
      {
        "name": "RegisterAbstractPath",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/file-system/registerabstractpath-r181",
        "description": "Registers the specified path and the entire subdirectory.",
        "c_syntax": "void RegisterAbstractPath( str path )",
        "cpp_syntax": "void Engine::RegisterAbstractPath( const_str path )",
        "example": "\n\n"
      },
      {
        "name": "SetZipStreamPassword",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/file-system/setzipstreampassword-r182",
        "description": "Sets the password for a zip or pak file.",
        "c_syntax": "void SetZipStreamPassword( str url, str password )",
        "cpp_syntax": "void Engine::SetZipStreamPassword( str url, str password )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Framework",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/",
    "members": [
      {
        "name": "CreateFramework",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/createframework-r184",
        "description": "Creates a new Framework object. A graphics window must be opened before the Framework is created.",
        "c_syntax": "TFramework CreateFramework( void )",
        "cpp_syntax": "void Framework::Create()",
        "example": "\n\n"
      },
      {
        "name": "FreeFramework",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/freeframework-r185",
        "description": "Frees a Framework object.This will delete all worlds, buffers, and shaders used by the framework.",
        "c_syntax": "void FreeFramework( TFramework framework )",
        "cpp_syntax": "void Framework::Free()",
        "example": "\n\n"
      },
      {
        "name": "GetFrameworkLayer",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/getframeworklayer-r221",
        "description": "Gets a Layer. The main Layer contains the World which contains the entities of the application, and the Camera of the application. The background Layer contains the World which contains the Skybox, and may also contain entities of a 3D background World. The transparency Layer contains the World which contains transparent entities like water, windows, smoke particle and heat haze materials.\n-1 - background layer\n0 - main layer\n1 - transparency layer",
        "c_syntax": "GetFrameworkLayer( int index )",
        "cpp_syntax": "Layer& Framewerk::GetLayer( int index )\nor Layer Framewerk::background\nor Layer Framewerk::main\nor Layer Framewerk::transparency",
        "example": "\n\n"
      },
      {
        "name": "GetFrameworkListener",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/getframeworklistener-r189",
        "description": "Returns the listener entity associated with the framework object.",
        "c_syntax": "TListener GetFrameworkListener( void )",
        "cpp_syntax": "Listener Framework::listener",
        "example": "\n\n"
      },
      {
        "name": "GetLayerCamera",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/getlayercamera-r222",
        "description": "Gets the camera of the Layer.",
        "c_syntax": "GetLayerCamera( TLayer layer )",
        "cpp_syntax": "Camera& Layer::GetCamera()",
        "example": "\n\n"
      },
      {
        "name": "GetLayerWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/getlayerworld-r223",
        "description": "Gets the world of the Layer.",
        "c_syntax": "GetLayerWorld( TLayer layer )",
        "cpp_syntax": "World& Layer::GetWorld()",
        "example": "\n\n"
      },
      {
        "name": "RenderFramework",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/renderframework-r186",
        "description": "Performs all rendering.",
        "c_syntax": "void RenderFramework( void )",
        "cpp_syntax": "void Framework::Render()",
        "example": "\n\n"
      },
      {
        "name": "ResetFramework",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/resetframework-r188",
        "description": "Resets the framework, and deletes all entities.",
        "c_syntax": "void ResetFramework( void )",
        "cpp_syntax": "void Framework::Reset()",
        "example": "\n\n"
      },
      {
        "name": "SetAntialias",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setantialias-r195",
        "description": "Sets the antialias mode.",
        "c_syntax": "void SetAntialias( int mode )",
        "cpp_syntax": "void Framework::renderer::SetAntialias( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetBackgroundColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setbackgroundcolor-r193",
        "description": "Sets the background color. This will only be used if the background mode is set to one.",
        "c_syntax": "void SetBackgroundColor( TVec4 &color )",
        "cpp_syntax": "void Framework::renderer::SetBackgroundColor( TVec4 &color )",
        "example": "\n\n"
      },
      {
        "name": "SetBackgroundMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setbackgroundmode-r192",
        "description": "Sets the background mode.\n0 - none (no color clearing)\n1 - solid color",
        "c_syntax": "void SetBackgroundMode( int mode )",
        "cpp_syntax": "void Framewerk::SetBackgroundMode( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetBloom",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setbloom-r202",
        "description": "Sets the mode for the bloom effect.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetBloom( int mode )",
        "cpp_syntax": "void Framework::renderer::SetBloom( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetBrightness",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setbrightness-r200",
        "description": "Sets the renderer brightness level.",
        "c_syntax": "void SetBrightness( flt brightness )",
        "cpp_syntax": "void Framework::renderer::SetBrightness( flt brightness )",
        "example": "\n\n"
      },
      {
        "name": "SetContrast",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setcontrast-r201",
        "description": "Sets the renderer contrast level.",
        "c_syntax": "void SetContrast( flt contrast )",
        "cpp_syntax": "void Framework::renderer::SetContrast( flt contrast )",
        "example": "\n\n"
      },
      {
        "name": "SetDistanceFog",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setdistancefog-r203",
        "description": "Sets the mode for the distance fog effect.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetDistanceFog( int mode )",
        "cpp_syntax": "void Framework::renderer::SetDistanceFog( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetDistanceFogAngle",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setdistancefogangle-r205",
        "description": "Sets the angle of the distance fog effect in the background. The begin angle is the angle at which the fog starts fading on the horizon. The end angle is where the fog will be completely faded out. This can be used to control how high on the horizon the distance fog effect appears.",
        "c_syntax": "void SetDistanceFogAngle( flt beginangle, flt endangle )",
        "cpp_syntax": "void Framework::renderer::SetDistanceFogAngle( flt beginangle, flt endangle )",
        "example": "\n\n"
      },
      {
        "name": "SetDistanceFogColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setdistancefogcolor-r204",
        "description": "Sets the color of the distance fog.",
        "c_syntax": "void SetDistanceFogColor( TVec4 &color )",
        "cpp_syntax": "void Framework::renderer::SetDistanceFogColor( TVec4 &color )",
        "example": "\n\n"
      },
      {
        "name": "SetDistanceFogRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setdistancefogrange-r206",
        "description": "Sets the range of the distance fog effect in the background. The begin range is the distance at which the fog starts appearing. The end range is where the fog will appear at maximum strength.",
        "c_syntax": "void SetDistanceFogRange( flt beginrange, flt endrange )",
        "cpp_syntax": "void Framework::renderer::SetDistanceFogRange( flt beginrange, flt endrange )",
        "example": "\n\n"
      },
      {
        "name": "SetFarDOF",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setfardof-r210",
        "description": "Sets the mode for the far depth of field effect.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetFarDOF( int mode )",
        "cpp_syntax": "void Framework::renderer::SetFarDOF( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetFarDOFRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setfardofrange-r212",
        "description": "Sets the range of the far depth of field effect. The begin range is the distance at which the effect starts appearing. The end range is where the effect will appear at maximum strength.",
        "c_syntax": "void SetFarDOFRange( flt beginrange, flt endrange )",
        "cpp_syntax": "void Framework::renderer::SetFarDOFRange( flt beginrange, flt endrange )",
        "example": "\n\n"
      },
      {
        "name": "SetFarDOFStrength",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setfardofstrength-r211",
        "description": "Sets the strength of the far depth of field effect. The strength parameter should be a number between zero and one.",
        "c_syntax": "void SetFarDOFStrength( flt strength )",
        "cpp_syntax": "void Framework::renderer::SetFarDOFStrength( flt strength )",
        "example": "\n\n"
      },
      {
        "name": "SetGodRays",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setgodrays-r197",
        "description": "Sets the mode for the volumetric light scattering effect. This effect will only be displayed if a directional light is present.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetGodRays( int mode )",
        "cpp_syntax": "void Framework::renderer::SetGodRays( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetHDR",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/sethdr-r198",
        "description": "Sets the mode for HDR and the iris adjustment effect.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetHDR( int mode )",
        "cpp_syntax": "void Framework::renderer::SetHDR( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetNearDOF",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setneardof-r207",
        "description": "Sets the mode for the near depth of field effect.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetNearDOF( int mode )",
        "cpp_syntax": "void Framework::renderer::SetNearDOF( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetNearDOFRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setneardofrange-r209",
        "description": "Sets the range of the near depth of field effect. The begin range is the distance at which the effect starts appearing. The end range is where the effect will appear at maximum strength.",
        "c_syntax": "void SetNearDOFRange( flt beginrange, flt endrange )",
        "cpp_syntax": "void Framework::renderer::SetNearDOFRange( flt beginrange, flt endrange )",
        "example": "\n\n"
      },
      {
        "name": "SetNearDOFStrength",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setneardofstrength-r208",
        "description": "Sets the strength of the near depth of field effect. The strength parameter should be a number between zero and one.",
        "c_syntax": "void SetNearDOFStrength( flt strength )",
        "cpp_syntax": "void Framework::renderer::SetNearDOFStrength( flt strength )",
        "example": "\n\n"
      },
      {
        "name": "SetReflectionElements",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setreflectionelements-r215",
        "description": "Sets the components which should be renderered in the water reflection. The default value is ENTITY_TERRAIN, so only terrain is rendered. Settings this to ENTITY_RENDERABLE renders everything, but causes also the heaviest GPU load. See RenderWorld for a list of all renderable components.",
        "c_syntax": "void SetReflectionElements( int mode )",
        "cpp_syntax": "void Framework::renderer::SetReflectionElements( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetSaturation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setsaturation-r199",
        "description": "Sets the renderer saturation level.",
        "c_syntax": "void SetSaturation( flt saturation )",
        "cpp_syntax": "void Framework::renderer::SetSaturation( flt saturation )",
        "example": "\n\n"
      },
      {
        "name": "SetSkybox",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setskybox-r194",
        "description": "Sets the skybox material. If the material is Null, no skybox will be used. A skybox should be used together with background mode zero.",
        "c_syntax": "void SetSkybox( TMaterial material )",
        "cpp_syntax": "void Framework::renderer::SetSkybox( Material& material )",
        "example": "\n\n"
      },
      {
        "name": "SetSSAO",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setssao-r196",
        "description": "Sets the SSAO mode.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetSSAO( int mode )",
        "cpp_syntax": "void Framework::renderer::SetSSAO( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetStats",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setstats-r190",
        "description": "Sets the statistics mode.\n0 - No statistics\n1 - Show frame rate\n2 - Full statistics",
        "c_syntax": "void SetStats( int mode )",
        "cpp_syntax": "void Framework::SetStats( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetWater",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwater-r213",
        "description": "Sets the water mode. When water is enabled, an infinite plane of liquid will appear and affect buoyant objects.\n0 - Disabled\n1 - Enabled",
        "c_syntax": "void SetWater( int mode )",
        "cpp_syntax": "void Framework::renderer::SetWater( int mode )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterAmplitude",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwateramplitude-r214",
        "description": "Sets the water's wave amplitude. Higher amplitudes make the water more calm. Lower amplitudes make more ripples to the water.",
        "c_syntax": "void SetWaterAmplitude( flt amplitude )",
        "cpp_syntax": "void Framework::renderer::SetWaterAmplitude( flt amplitude )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwatercolor-r218",
        "description": "Sets the water surface and underwater fog (\"submersion\") color.",
        "c_syntax": "void SetWaterColor( TVec4 &color, TVec4 &submersioncolor )",
        "cpp_syntax": "void Framework::renderer::SetWaterColor( TVec4 &color, TVec4 &submersioncolor )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwaterheight-r219",
        "description": "Sets the water height in meters.",
        "c_syntax": "void SetWaterHeight( flt height )",
        "cpp_syntax": "void Framework::renderer::SetWaterHeight( flt height )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterSoftness",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwatersoftness-r217",
        "description": "Sets the water softness. Water softness is the alpha transparency of the water.",
        "c_syntax": "void SetWaterSoftness( flt softness )",
        "cpp_syntax": "void Framework::renderer::SetWaterSoftness( flt softness )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterVisibility",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwatervisibility-r216",
        "description": "Sets the water visibility range.",
        "c_syntax": "void SetWaterVisibility( flt beginrange, flt endrange )",
        "cpp_syntax": "void Framework::renderer::SetWaterVisibility( flt beginrange, flt endrange )",
        "example": "\n\n"
      },
      {
        "name": "SetWaterWaveSpeed",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setwaterwavespeed-r220",
        "description": "Sets the water wave speed.",
        "c_syntax": "SetWaterWaveSpeed( flt speed )",
        "cpp_syntax": "void Framework::renderer::SetWaterWaveSpeed( flt speed )",
        "example": "\n\n"
      },
      {
        "name": "SetZoom",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/setzoom-r191",
        "description": "Sets the camera zoom level for the Framework object.",
        "c_syntax": "void SetZoom( flt zoom )",
        "cpp_syntax": "void Framewerk::SetZoom( flt zoom )",
        "example": "\n\n"
      },
      {
        "name": "UpdateFramework",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/framework/updateframework-r187",
        "description": "Updates timing, behavior, and physics.",
        "c_syntax": "void UpdateFramework( void )",
        "cpp_syntax": "void Framework::Update()",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Graphics",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/",
    "members": [
      {
        "name": "DebugEntities",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/debugentities-r234",
        "description": "DebugEntities will show a wireframe representation of all entity bounding boxes. If mode is set to 1 entity debugging will be enabled. All entity bounding boxes will be rendered in wireframe.",
        "c_syntax": "void DebugEntities( int mode=1 )",
        "cpp_syntax": "void Engine::DebugEntities( int mode=1 )",
        "example": "\n//Press space to turn on or off entity debugging.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DebugEntities\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tDebugEntities(1);\n\tCollisions(1,1,1);\n \n\tbool debugEntitiesOn = true;\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\t//press space to toggle DebugEntities\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(debugEntitiesOn)\n\t\t\t{\n\t\t\t\tdebugEntitiesOn = false;\n\t\t\t\tDebugEntities(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdebugEntitiesOn = true;\n\t\t\t\tDebugEntities(1);\n\t\t\t}\n\t\t}\n\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press space to turn on or off Entity debugging.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "DebugLighting",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/debuglighting-r548",
        "description": "If mode is set to 1 light debugging will be enabled. Light shapes, ranges, and rays will be drawn.",
        "c_syntax": "void DebugLights( int mode=1 )",
        "cpp_syntax": "void DebugLights( int mode )Example\n//This",
        "example": "\n//This example demonstrates Lights debugging\n//Press Space to toggle on and off Light debugging\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Spot Light Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create the spot light\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tbool debugLights = false;\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n\n\t\t//Press space for debugging lights\n\t\tif(KeyHit(KEY_SPACE))\n\t\t\tif(debugLights)\n\t\t\t{\n\t\t\t\tdebugLights = false;\n\t\t\t\tDebugLights(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdebugLights = true;\n\t\t\t\tDebugLights(1);\n\t\t\t}\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,30, \"Press Space to toggle light debugging.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "DebugPhysics",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/debugphysics-r233",
        "description": "If mode is set to 1 light debugging will be enabled. Light shapes, ranges, and rays will be drawn. DebugLights will show a wireframe representation of each light's range, shape, and direction.",
        "c_syntax": "void DebugLights( int mode=1 )",
        "cpp_syntax": "void DebugLights( int mode )",
        "example": "\n//Press space to turn on or off physics debugging.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DebugPhysics\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tCollisions(1,1,1);\n \n\tbool debugPhysicsOn = true;\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\t//press space to toggle DebugPhysics\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(debugPhysicsOn)\n\t\t\t{\n\t\t\t\tdebugPhysicsOn = false;\n\t\t\t\tDebugPhysics(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdebugPhysicsOn = true;\n\t\t\t\tDebugPhysics(1);\n\t\t\t}\n\t\t}\n\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press space to turn on or off physics debugging.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "DebugSceneGraph",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/debugscenegraph-r235",
        "description": "DebugSceneGraph will show a wireframe representation of the scene graph. If mode is set to 1 scenegraph debugging will be enabled. A wireframe visualization of the scenegraph will be drawn. This draws a frame around all groups.",
        "c_syntax": "void DebugSceneGraph( int mode=1 )",
        "cpp_syntax": "void Engine::DebugSceneGraph( int mode=1 )",
        "example": "\n//Press space to turn on or off Scene graph debugging debugging.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DebugSceneGraph\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,6,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(10,0.1,10) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//Create a body box\n\tTBody\t\t\tbox = CreateBodyBox(1,3,2);\n\tSetBodyMass\t\t(box, 10);\n\tEntityType\t\t(box,1);\n\n\t//set up lights\n\tTEntity\t\t\t\tlight  = CreateDirectionalLight();\n\tRotateEntity\t\t(light,  Vec3(40,45,0), 0);\n\tSetShadowmapSize\t(light,1024);\n\tAmbientLight\t\t(Vec3(0.05,0.05,0.1));\n\n\t//physics view is enabled\n\tDebugPhysics(1);\n\tDebugEntities(1);\n\tCollisions(1,1,1);\n \n\tbool debugSceneGraph = false;\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\t//press space to toggle DebugEntities\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(debugSceneGraph)\n\t\t\t{\n\t\t\t\tdebugSceneGraph = false;\n\t\t\t\tDebugSceneGraph(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdebugSceneGraph = true;\n\t\t\t\tDebugSceneGraph(1);\n\t\t\t}\n\t\t}\n\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press space to turn on or off Scene Graph debugging.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "Flip",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/flip-r228",
        "description": "Flips the front and back buffers. Value of 1 locks the update speed to the refresh rate of your monitor. Value of 0 disables Vsync. Value of -1 uncaps the update speed. Flip simply flips the back buffer to the front buffer, effectively drawing all of the frame's updates to the window/screen. It must be included in the program loop every frame.Flip(0) - Won't use VSync so the framerate won't be limited by the monitor refresh rate. Make sure you use AppSpeed in all of your time dependent values such as movement, and you should use UpdateWorld(AppSpeed()) as well.Flip(1) - Uses VSync to make sure the buffer is flipped at the same frequency as your monitor's refresh rate.Flip(-1) - Uncaps the buffer update rate.",
        "c_syntax": "void Flip(int sync=1)",
        "cpp_syntax": "void Engine::Flip( int vsync=1 )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics(640, 480);\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tFlip();\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "GetGraphicsVendor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/getgraphicsvendor-r231",
        "description": "Returns the vendor of the user's graphics card. Possible values are:VENDOR_NVIDIAVENDOR_ATIVENDOR_UNKNOWN",
        "c_syntax": "int GetGraphicsVendor(void)",
        "cpp_syntax": null,
        "example": "\n//This program shows your computer's capabilities (in the console window).\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Your computer's capabilities\");\n\tGraphics(640,480); ShowWindow(GetActiveWindow(),SW_HIDE);\n\tCreateWorld();\n\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tprintf(\"\\n\\n==Computer capabilities==\\n\");\n\tprintf(\"MaxTextureUnits() = %d\\n\",MaxTextureUnits());\n\tprintf(\"MaxColorBuffers() = %d\\n\",MaxColorBuffers());\n\tprintf(\"MaxAFilter() = %d\\n\",MaxAFilter());\n\tprintf(\"ShaderModel = %d\\n\",GetShaderModel());\n \n\tchar gvendor[] = \"VENDOR_UNKNOWN\"; int gvendorID = GetGraphicsVendor();\n\tif(gvendorID == VENDOR_NVIDIA)strcpy(gvendor,\"VENDOR_NVIDIA\");\n\tif(gvendorID == VENDOR_ATI)strcpy(gvendor,\"VENDOR_ATI\");\n\tprintf(\"GraphicsVendor = %s\\n\",gvendor);\n \n\tprintf(\"\\n\\n\");\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n \n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "GetShaderModel",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/getshadermodel-r232",
        "description": "Returns the shader model of the user's graphics card.",
        "c_syntax": "int GetShaderModel(void)",
        "cpp_syntax": null,
        "example": "\n//This program shows your computer's capabilities (in the console window).\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Your computer's capabilities\");\n\tGraphics(640,480); ShowWindow(GetActiveWindow(),SW_HIDE);\n\tCreateWorld();\n\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tprintf(\"\\n\\n==Computer capabilities==\\n\");\n\tprintf(\"MaxTextureUnits() = %d\\n\",MaxTextureUnits());\n\tprintf(\"MaxColorBuffers() = %d\\n\",MaxColorBuffers());\n\tprintf(\"MaxAFilter() = %d\\n\",MaxAFilter());\n\tprintf(\"ShaderModel = %d\\n\",GetShaderModel());\n \n\tchar gvendor[] = \"VENDOR_UNKNOWN\"; int gvendorID = GetGraphicsVendor();\n\tif(gvendorID == VENDOR_NVIDIA)strcpy(gvendor,\"VENDOR_NVIDIA\");\n\tif(gvendorID == VENDOR_ATI)strcpy(gvendor,\"VENDOR_ATI\");\n\tprintf(\"GraphicsVendor = %s\\n\",gvendor);\n \n\tprintf(\"\\n\\n\");\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n \n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "Graphics",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/graphics-r225",
        "description": "Creates the graphics instance, window, and the backbuffer with the specified parameters. Returns 1 if successful, else returns 0 if failed. If the depth is set to 0 the desktop depth will be used, and a windowed graphics context will be created. If the depth is specified (this is the usual bits per pixel value, 32 is recommended), a fullscreen graphics context will be created. This command can be called multiple times during program execution, to change the screen resolution.\nNote: Calling this a second time will only have a resizing effect on the back buffer, the other fullscreen buffers should be deleted and recreated with a resolution matching the new one (= resizing).",
        "c_syntax": "int Graphics(int width=640, int height=480, int depth=0, int hertz=60, int flags=GRAPHICS_BACKBUFFER",
        "cpp_syntax": "Engine::Engine( void )\nEngine::Engine( const std::string& appTitle, int width, int height, int depth = 0, int hertz = 0, int flags = GRAPHICS_BACKBUFFER",
        "example": "\n//This program creates a window sized 640x480. The window will be emtpy since nothing is rendered to it and the back-& front buffers aren't switched. (see Flip which implements the switching)\n#include \"engine.h\"\nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics(640,480);\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "GraphicsHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/graphicsheight-r227",
        "description": "Returns the current height of the graphics window (created using the 'Graphics' command).",
        "c_syntax": "int GraphicsHeigth( void )",
        "cpp_syntax": "int Engine::GetHeigth( void ) const",
        "example": "\n//Get the graphics height\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"GraphicsHeight\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsHeight() / 2, GraphicsWidth() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen.\");\n\t\tDrawText(0,15,\"This is done by retrieving the width and the height of the screen. These values are then divided by 2.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "GraphicsWidth",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/graphicswidth-r226",
        "description": "Returns the current width of the graphics window (created using the 'Graphics' command).",
        "c_syntax": "int GraphicsWidth( void )",
        "cpp_syntax": "int Engine::GetWidth( void ) const",
        "example": "\n//Get the graphics width\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"GraphicsWidth\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsHeight() / 2, GraphicsWidth() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen.\");\n\t\tDrawText(0,15,\"This is done by retrieving the width and the height of the screen. These values are then divided by 2.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "OcclusionCulling",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/occlusionculling-r229",
        "description": "If mode is set to 1 hardware occlusion culling will be enabled, if it is supported on the user's system. Occlusion culling is enabled by default. Because occlusion queries are calculated with the depth buffer, occlusion culling will not work with wireframe rendering. Occlusion culling hides objects that are completely covered by others.",
        "c_syntax": "void OcclusionCulling( int mode=1 )",
        "cpp_syntax": "void Engine::SetOcclusionCulling( bool enable )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Demonstrating OcclusionCulling()\");\n\tGraphics(640, 480);\n\tCreateWorld();\n\tCreateCamera();\n \n\t// the movable cube\n\tTMesh cube = CreateCube();\n\tScaleEntity(cube,Vec3(2));\n\tPositionEntity(cube,Vec3(0,0,5),1);\n \n\t// the fixed sphere with a plane to visualize the padding/oc box\n\tTMesh fsphere = CreateSphere();\n\tScaleEntity(fsphere,Vec3(2));\n \n\tTMesh visplane = CreatePlane();\n\tRotateEntity(visplane,Vec3(-90,0,0));\n\tScaleEntity(visplane,Vec3(2)); // unscaled planes are 2x2 in size, so scaling it by 2 will make it 4x4, that's 2m padding to the cube\n\tEntityColor(visplane,Vec4(1,0,0,1));\n\tEntityParent(visplane, fsphere);\n \n\tPositionEntity(fsphere,Vec3(0,0,14),1);\n \n\tbool occlusionCulling = true;\n\tOcclusionCulling(occlusionCulling);\n \n\t// oc is disabled for most entity types by default\n\t// using/enabling oc for single object isn't too good since every oc test adds 12 triangles (an uninstanced aabb box with some padding)\n\t// better use groups\n\tEntityOcclusionMode(cube,true);\n\tEntityOcclusionMode(fsphere,true);\n \n\tSetColor(0,1,0,1);\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tWireframe(KeyDown(KEY_F));\n \n\t\tif(KeyDown(KEY_UP))MoveEntity(cube,Vec3(0,0.02f,0));\n\t\tif(KeyDown(KEY_DOWN))MoveEntity(cube,Vec3(0,-0.02f,0));\n\t\tif(KeyDown(KEY_RIGHT))MoveEntity(cube,Vec3(0.02f,0,0));\n\t\tif(KeyDown(KEY_LEFT))MoveEntity(cube,Vec3(-0.02f,0,0));\n \n\t\tif(KeyHit(KEY_SPACE)) {\n\t\t\tocclusionCulling = !occlusionCulling;\n\t\t\tOcclusionCulling(occlusionCulling);\n\t\t}\n \n\t\tUpdateAppTime();\n\t\tRenderWorld();\n \n\t\tDrawText(0,0,\"Geometry and oc test tris rendered: %d.\",TrisRendered(0));\n\t\tDrawText(0,12,\"OcclusionCulling state: '%s', SPACE to change.\",occlusionCulling?\"on\":\"off\");\n\t\tDrawText(0,24,\"Hold F to enable wireframe (oc won't work then).\");\n\t\tDrawText(0,36,\"The read border visualizes the oc test box' padding of 1-2 units.\");\n\t\tDrawText(0,48,\"Move the closer cube with the arrow keys.\");\n \n\t\tFlip(1);\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "TrisRendered",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/trisrendered-r230",
        "description": "Returns the number of triangles rendered in the last RenderWorld() call. This includes shadow and occlusion test triangles as well as visible surfaces.",
        "c_syntax": "int TrisRendered(int mode)",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Demonstrating OcclusionCulling()\");\n\tGraphics(640, 480);\n\tCreateWorld();\n\tCreateCamera();\n \n\t// the movable cube\n\tTMesh cube = CreateCube();\n\tScaleEntity(cube,Vec3(2));\n\tPositionEntity(cube,Vec3(0,0,5),1);\n \n\t// the fixed sphere with a plane to visualize the padding/oc box\n\tTMesh fsphere = CreateSphere();\n\tScaleEntity(fsphere,Vec3(2));\n \n\tTMesh visplane = CreatePlane();\n\tRotateEntity(visplane,Vec3(-90,0,0));\n\tScaleEntity(visplane,Vec3(2)); // unscaled planes are 2x2 in size, so scaling it by 2 will make it 4x4, that's 2m padding to the cube\n\tEntityColor(visplane,Vec4(1,0,0,1));\n\tEntityParent(visplane, fsphere);\n \n\tPositionEntity(fsphere,Vec3(0,0,14),1);\n \n\tbool occlusionCulling = true;\n\tOcclusionCulling(occlusionCulling);\n \n\t// oc is disabled for most entity types by default\n\t// using/enabling oc for single object isn't too good since every oc test adds 12 triangles (an uninstanced aabb box with some padding)\n\t// better use groups\n\tEntityOcclusionMode(cube,true);\n\tEntityOcclusionMode(fsphere,true);\n \n\tSetColor(0,1,0,1);\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tWireframe(KeyDown(KEY_F));\n \n\t\tif(KeyDown(KEY_UP))MoveEntity(cube,Vec3(0,0.02f,0));\n\t\tif(KeyDown(KEY_DOWN))MoveEntity(cube,Vec3(0,-0.02f,0));\n\t\tif(KeyDown(KEY_RIGHT))MoveEntity(cube,Vec3(0.02f,0,0));\n\t\tif(KeyDown(KEY_LEFT))MoveEntity(cube,Vec3(-0.02f,0,0));\n \n\t\tif(KeyHit(KEY_SPACE)) {\n\t\t\tocclusionCulling = !occlusionCulling;\n\t\t\tOcclusionCulling(occlusionCulling);\n\t\t}\n \n\t\tUpdateAppTime();\n\t\tRenderWorld();\n \n\t\tDrawText(0,0,\"Geometry and oc test tris rendered: %d.\",TrisRendered(0));\n\t\tDrawText(0,12,\"OcclusionCulling state: '%s', SPACE to change.\",occlusionCulling?\"on\":\"off\");\n\t\tDrawText(0,24,\"Hold F to enable wireframe (oc won't work then).\");\n\t\tDrawText(0,36,\"The read border visualizes the oc test box' padding of 1-2 units.\");\n\t\tDrawText(0,48,\"Move the closer cube with the arrow keys.\");\n \n\t\tFlip(1);\n\t}\n\treturn Terminate();\n}\n"
      },
      {
        "name": "Wireframe",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/graphics/wireframe-r236",
        "description": "Draws every model in wireframe. If mode is set to 1 all meshes will be drawn as hidden-line triangle wireframes.",
        "c_syntax": "void Wireframe( int mode=1 )",
        "cpp_syntax": "void Engine::Wireframe( int mode=1 )",
        "example": "\n//Demonstration of the wireframe modus\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Wireframe\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera and place it in the scene\n\tTEntity\t\t\tcamera = CreateCamera();\n\tMoveEntity\t\t(camera, Vec3(0,4,-8) );\n\tRotateEntity\t(camera, Vec3(45,0,0) );\n\n\tTLight sun = CreateDirectionalLight();\n\tRotateEntity(sun, Vec3(45,45,0));\n  \n\t//Create a plane\n\tTBody\t\t\tplaneBody = CreateBodyBox();\n\tScaleEntity\t\t(planeBody,  Vec3(30,0.1,30) );\n\tPositionEntity\t(planeBody, Vec3(0,-5,0));\n\tEntityType\t\t(planeBody, 1);\n \n\t//load several models\n\tfor( int i = 0; i < 10; i++)\n\t{\n\t\tTModel oildrum = LoadModel(\"abstract::oildrum.gmf\");\n\t\tPositionEntity(oildrum, Vec3(0,5 * i,0));\n\t}\n\n\t//physics view is enabled\n\tDebugPhysics(0);\n\tCollisions(1,1,1);\n \n\tbool wireframe = false;\n\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(wireframe)\n\t\t\t{\n\t\t\t\tWireframe(0);\n\t\t\t\twireframe = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWireframe(1);\n\t\t\t\twireframe = true;\n\t\t\t}\n\t\t}\n\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press space to toggle on and off the wireframe modus.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      }
    ]
  },
  {
    "name": "Input",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/",
    "members": [
      {
        "name": "FlushKeys",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/flushkeys-r241",
        "description": "Clears all keyboard events. This is especially needed when using GetChar(), because else GetChar() returns all earlier pressed keys during the time before GetChar() was called.",
        "c_syntax": "void FlushKeys()",
        "cpp_syntax": "static void Keyboard::Flush() const",
        "example": "\n\n"
      },
      {
        "name": "FlushMouse",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/flushmouse-r250",
        "description": "Clears all Mouse button events. This is especially needed when switching a mouse check routine which uses MouseDown() to a routine which uses MouseHit() (for example when switching from an autofire weapon to a single fire weapon).",
        "c_syntax": "void FlushMouse( void )",
        "cpp_syntax": "static void Mouse::Flush( void )",
        "example": "\n\n"
      },
      {
        "name": "GetChar",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/getchar-r240",
        "description": "Returns the last character that was typed. Reacts correctly when the user holds a key for some time, resulting in multiple keystrokes.",
        "c_syntax": "int GetChar()",
        "cpp_syntax": "static int Keyboard::GetChar() const",
        "example": "\n//Getting the last Character that was typed\n//Setting al characters in a string.\n#include \"engine.h\"\n#include <string>\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"GetChar\")\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tstd::string keyboardString = \"\";\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tSetColor(0,0,0);\n\t\tClearBuffer();\n\t\tSetColor(1,1,1);\n \n\t\tu_char c = GetChar();\n\t\tif(c >= 32)keyboardString += c; // only add displayable characters\n\t\tif(c == VK_BACK && keyboardString.size() >= 1)\n\t\t\tkeyboardString.erase(--keyboardString.end());\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n\n \n\t\tDrawText(0,0,\"LastChar: %c\", c);\n\t\tDrawText(0,15,\"Write some text here: %s\", keyboardString.c_str());\n \n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "HideMouse",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/hidemouse-r248",
        "description": "Hides the mouse cursor.",
        "c_syntax": "void HideMouse( void )",
        "cpp_syntax": "static void Mouse::Hide( void )",
        "example": "\n//Hiding and showing the mouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"hide and show mouse\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_LEFT))\n\t\t{\n\t\t\tHideMouse();\n\t\t}\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t{\n\t\t\tShowMouse();\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press left arrow to hide the mouse. Press right arrow to show the mouse.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "KeyDown",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/keydown-r238",
        "description": "Returns 1 if the specified key is being held down, else returns 0.",
        "c_syntax": "int KeyDown( int key = KEY_ESCAPE )",
        "cpp_syntax": "static bool Keyboard::IsDown( int key = KEY_ESCAPE ) const",
        "example": "\n//A keydown event\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"KeyDown\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyDown(KEY_SPACE))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(0.1,0,0));\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"If you hold down the space key, the cube moves slowly to the right.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "KeyHit",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/keyhit-r239",
        "description": "Returns 1 if the specified key has been pressed since the last call to KeyHit(), else returns 0.",
        "c_syntax": "int KeyHit( int key )",
        "cpp_syntax": "static bool Keyboard::IsHit( int key = KEY_ESCAPE ) const",
        "example": "\n//A keyhit event\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"KeyHit\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(1,0,0),1);\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"If you hit the space key, the cube moves 1 space to the right.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MouseDown",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/mousedown-r245",
        "description": "Returns 1 if the specified mouse button is being held down, else returns 0.",
        "c_syntax": "int MouseDown( int button )",
        "cpp_syntax": "static bool Mouse::IsDown( const MouseButton& rButton = Left ) Where MouseButton is one of LEFT, RIGHT or MIDDLE",
        "example": "\n//Holding the mouse buttons down\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"MouseDown\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//left mouse button\n\t\tif(MouseDown(1))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(0.1,0,0));\n\t\t}\n\t\t//right mouse button\n\t\telse if(MouseDown(2))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(-0.1,0,0));\n\t\t}\n\t\t//middle mouse button (scroller)\n\t\telse if(MouseDown(3))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(0,0.1,0));\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Hold down the left mouse button, the cube moves slowly to the right.\");\n\t\tDrawText(0,15, \"Hold down the right mouse button, the cube moves slowly to the left.\");\n\t\tDrawText(0,30, \"Hold down the middle mouse button, the cube moves slowly up.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MouseHit",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/mousehit-r246",
        "description": "Returns 1 if the specified mouse button has been pressed since the last call to MouseHit(), else returns 0.",
        "c_syntax": "int MouseHit( int button )",
        "cpp_syntax": "static bool Mouse::IsHit( const MouseButton& rButton = Left ) Where MouseButton is one of LEFT, RIGHT or MIDDLE",
        "example": "\n//Clicking with your mouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"MouseHit\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// base cube\n\tTEntity basecube = CreateCube(0); \n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//left mouse button\n\t\tif(MouseHit(1))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(-1,0,0));\n\t\t}\n\t\t//right mouse button\n\t\telse if(MouseHit(2))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(1,0,0));\n\t\t}\n\t\t//middle mouse button (scroller)\n\t\telse if(MouseHit(3))\n\t\t{\n\t\t\tMoveEntity(basecube, Vec3(0,0.5,0));\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Click with the left button, the cube moves slowly to the left.\");\n\t\tDrawText(0,15, \"Click with the right button, the cube moves slowly to the right.\");\n\t\tDrawText(0,30, \"Click with the midlle button, the cube moves slowly upwards.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MouseX",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/mousex-r242",
        "description": "Returns the current mouse X position.",
        "c_syntax": "int MouseX()",
        "cpp_syntax": "static int Mouse::GetX( void ) const",
        "example": "\n//Press SPACE to center the MoveMouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"MouseX\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\tfloat mousex;\n\tfloat mousey;\n\tfloat mousez;\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//Update mouse positions\n\t\tmousex = MouseX();\n\t\tmousey = MouseY();\n\t\tmousez = MouseZ();\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsHeight() / 2, GraphicsWidth() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen. Use the scroller to change the Z value\");\n\t\tDrawText(0,15, \"Mouse x: %f\", mousex);\n\t\tDrawText(0,30, \"Mouse y: %f\", mousey);\n\t\tDrawText(0,45, \"Mouse z: %f\", mousez);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MouseY",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/mousey-r243",
        "description": "Returns the current mouse Y position.",
        "c_syntax": "int MouseY()",
        "cpp_syntax": "static int Mouse::GetY( void ) const",
        "example": "\n//Press SPACE to center the MoveMouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"MouseY\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\tfloat mousex;\n\tfloat mousey;\n\tfloat mousez;\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//Update mouse positions\n\t\tmousex = MouseX();\n\t\tmousey = MouseY();\n\t\tmousez = MouseZ();\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsHeight() / 2, GraphicsWidth() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen. Use the scroller to change the Z value\");\n\t\tDrawText(0,15, \"Mouse x: %f\", mousex);\n\t\tDrawText(0,30, \"Mouse y: %f\", mousey);\n\t\tDrawText(0,45, \"Mouse z: %f\", mousez);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MouseZ",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/mousez-r244",
        "description": "Returns the mouse's current Z position. This is the delta value of the mouse wheel.",
        "c_syntax": "int MouseZ()",
        "cpp_syntax": "static int Mouse::GetZ( void ) const",
        "example": "\n//Press SPACE to center the MoveMouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"MouseZ\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\tfloat mousex;\n\tfloat mousey;\n\tfloat mousez;\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//Update mouse positions\n\t\tmousex = MouseX();\n\t\tmousey = MouseY();\n\t\tmousez = MouseZ();\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsHeight() / 2, GraphicsWidth() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen. Use the scroller to change the Z value\");\n\t\tDrawText(0,15, \"Mouse x: %f\", mousex);\n\t\tDrawText(0,30, \"Mouse y: %f\", mousey);\n\t\tDrawText(0,45, \"Mouse z: %f\", mousez);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MoveMouse",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/movemouse-r247",
        "description": "Moves the mouse to the specified screen coordinates.",
        "c_syntax": "void MoveMouse( int x, int y )",
        "cpp_syntax": "static void Mouse::Move( int x, int y )",
        "example": "\n//Hiding and showing the mouse\n#include \"engine.h\"\n  \nint main(void)\n{\n//Press SPACE to center the Mouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"Movemouse\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\tfloat mousex;\n\tfloat mousey;\n\tfloat mousez;\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//Update mouse positions\n\t\tmousex = MouseX();\n\t\tmousey = MouseY();\n\t\tmousez = MouseZ();\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tMoveMouse(GraphicsWidth() / 2, GraphicsHeight() / 2); \n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press SPACE to center the mouse to the screen. Use the scroller to change the Z value\");\n\t\tDrawText(0,15, \"Mouse x: %f\", mousex);\n\t\tDrawText(0,30, \"Mouse y: %f\", mousey);\n\t\tDrawText(0,45, \"Mouse z: %f\", mousez);\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "ShowMouse",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/input/showmouse-r249",
        "description": "Shows the mouse cursor.",
        "c_syntax": "void ShowMouse( void )",
        "cpp_syntax": "static void Mouse::Show( void )",
        "example": "\n//Hiding and showing the mouse\n#include \"engine.h\"\n  \nint main(void)\n{\n\t// init\n\tInitialize();\n\tSetAppTitle(\"hide and show mouse\");\n\tGraphics(640,480);\n \n\t// world & buffer\n\tTWorld World = CreateWorld();\n\tTBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t   \n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t   \n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n\n\t// Main Programm\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t\t\n\t{\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_LEFT))\n\t\t{\n\t\t\tHideMouse();\n\t\t}\n\t\t//left mouse button\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t{\n\t\t\tShowMouse();\n\t\t}\n\n\t\tUpdateWorld();\n\t\tRenderWorld();\n \n\t\t// text\n\t\tDrawText(0,0, \"Press left arrow to hide the mouse. Press right arrow to show the mouse.\");\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      }
    ]
  },
  {
    "name": "Joints",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/",
    "members": [
      {
        "name": "here",
        "href": "http://www.newtondynamics.com/wiki/index.php5?title=Joints",
        "description": null,
        "c_syntax": null,
        "cpp_syntax": null,
        "example": null
      },
      {
        "name": "CreateJointBall",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointball-r252",
        "description": "Creates a new ball joint between the specified parent and child at the given location.",
        "c_syntax": "TJoint CreateJointBall( TEntity parent, TEntity child, TVec3 &pos )",
        "cpp_syntax": "BallJoint::BallJoint( TEntity ent = 0 )\nBallJoint::BallJoint( const TEntity parent, const TEntity child, const TVec3& pos )\nvirtual void BallJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos )",
        "example": "\n#include \"engine.h\"\n#include \"time.h\"\n \nint main(void)\n{\n\t srand ( time(NULL) ); // To make the rand() more natural\n \n\t Initialize();\n\t Graphics\t (640,480, 0, 0, 0);\n \n\t TEntity\t   World  = CreateWorld();\n\t TEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t TEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\t MoveEntity\t(Camera, Vec3(0,40,-30) );\n\t RotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t TEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\t MoveEntity   (Light, Vec3(0,10,0) );\n\t RotateEntity (Light, Vec3(45,45,0) ,0);\n\t EntityColor  (Light, Vec4(1));\n\t AmbientLight (Vec3(.2,.2,.3));\n \n\t TEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\t TEntity\t\t groundphy = CreateBodyBox(100,100,100,0);\n\t EntityParent   (ground,\tgroundphy,0);\n\t ScaleEntity\t(ground,\tVec3(100,100,100));\n\t MoveEntity\t (groundphy, Vec3(0,-50,0));\n\t SetBodyMass\t(groundphy, 0);\n\t EntityType\t (groundphy, 1, 1);\n \n\t TEntity\t\t crane\t= CreateCube(0);\n\t TEntity\t\t cranephy = CreateBodyBox(100,2,2,0);\n\t EntityParent   (crane,\tcranephy,0);\n\t ScaleEntity\t(crane,\tVec3(100,2,2));\n\t MoveEntity\t (cranephy, Vec3(0,30,0));\n\t SetBodyMass\t(cranephy, 0);\n\t EntityType\t (cranephy, 1, 1);\n \n\t TEntity cubePhy[10];\n\t for(int i=1; i<=10; i++)\n\t {\n\t\t TEntity cube  = CreateCube(0);\t\t\t//Boxes\n\t\t cubePhy[i-1]  = CreateBodyBox(2,2,2,0);\n\t\t EntityParent   (cube,\tcubePhy[i-1],1);\n\t\t ScaleEntity\t(cube,\tVec3(2,2,2));\n\t\t SweptCollision (cubePhy[i-1], 1);\n\t\t MoveEntity\t (cubePhy[i-1], Vec3(0,i*2-1+10,0));\n\t\t SetBodyMass\t(cubePhy[i-1], 1);\n\t\t EntityType\t (cubePhy[i-1], 1,0);\n \n\t\t if(i==10)TEntity Joint = CreateJointBall( cranephy,cubePhy[i-1], Vec3(0,29,0));\n\t\t if(i>1)TEntity Joint = CreateJointBall( cubePhy[i-1],cubePhy[i-2], Vec3(0,i*2-2+10,0));\n\t }\n \n\t Collisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n \n \n \n\t while(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t\t// Main Program\n\t {\n\t\t if(KeyHit(KEY_SPACE))AddBodyForce(cubePhy[rand()%10],Vec3(10000,0,10000),0);\t// Apply force\n \n\t\t UpdateAppTime();\n\t\t UpdateWorld(AppSpeed());\n \n\t\t SetBuffer(buffer);\n\t\t RenderWorld();\n\t\t SetBuffer(BackBuffer());\n\t\t RenderLights(buffer);\n \n\t\t SetBlend   (BLEND_ALPHA);\n\t\t DrawText   (0,0,\"Press SPACE to apply force to one of the boxes!\");\n\t\t SetBlend   (0);\n\t\t Flip\t   (1);\n\t }\n \n\t return Terminate();\n}\n"
      },
      {
        "name": "CreateJointCorkscrew",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointcorkscrew-r255",
        "description": "Creates a new corkscrew joint between the specified parent and child at the given location.",
        "c_syntax": "TJoint CreateJointCorkscrew( TEntity parent, TEntity child, TVec3 &pos, TVec3 &pin )",
        "cpp_syntax": "CorkscrewJoint::CorkscrewJoint( TEntity ent = 0 )\nCorkscrewJoint::CorkscrewJoint( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin )\nvirtual void CorkscrewJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin )",
        "example": "\n\n"
      },
      {
        "name": "CreateJointFixed",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointfixed-r257",
        "description": "Creates a new fixed joint between the specified parent and child at the given location.",
        "c_syntax": "TJoint CreateJointFixed( TEntity parent, TEntity child, TVec3 &pos )",
        "cpp_syntax": "FixedJoint::FixedJoint( TEntity ent = 0 )\nFixedJoint::FixedJoint( const TEntity parent, const TEntity child, const TVec3& pos )\nvirtual void FixedJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos )",
        "example": "\n\n"
      },
      {
        "name": "CreateJointHinge",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointhinge-r253",
        "description": "Creates a new hinge joint between the specified parent and child at the given location. The position parameter tells where the hinge is located relative to the parent body, and the pin parameter tells in which direction the hinge is aligned, it's good to use a normal vector for pin.",
        "c_syntax": "TJoint CreateJointHinge( TEntity parent, TEntity child, TVec3 &pos, TVec3 &pin )",
        "cpp_syntax": "HingleJoint::HingleJoint( TEntity ent = 0 )\nHingleJoint::HingleJoint( const TEntity parent, const TEntity child, const TVec3& pos )\nvirtual void HingleJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos )",
        "example": "\n#include \"engine.h\"\n #include \"time.h\"\n \n int main(void)\n {\n\t srand ( time(NULL) ); // To make the rand() more natural\n \n\t Initialize();\n\t Graphics\t (640,480, 0, 0, 0);\n \n\t TEntity\t   World  = CreateWorld();\n\t TEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t TEntity\t\tCamera = CreateCamera(0);\t\t\t\t// Camera\n\t MoveEntity\t(Camera, Vec3(0,40,-30) );\n\t RotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t TEntity\t   Light = CreateDirectionalLight(0);\t\t// Create light\n\t MoveEntity   (Light, Vec3(0,10,0) );\n\t RotateEntity (Light, Vec3(45,45,0) ,0);\n\t EntityColor  (Light, Vec4(1));\n\t AmbientLight (Vec3(.2,.2,.3));\n \n\t TEntity\t\t ground\t= CreateCube(0);\t\t\t\t// Ground\n\t TEntity\t\t groundphy = CreateBodyBox(100,100,100,0);\n\t EntityParent   (ground,\tgroundphy,0);\n\t ScaleEntity\t(ground,\tVec3(100,100,100));\n\t MoveEntity\t (groundphy, Vec3(0,-50,0));\n\t SetBodyMass\t(groundphy, 0);\n\t EntityType\t (groundphy, 1, 1);\n \n\t TEntity\t\t crane\t= CreateCube(0);\n\t TEntity\t\t cranephy = CreateBodyBox(100,2,2,0);\n\t EntityParent   (crane,\tcranephy,0);\n\t ScaleEntity\t(crane,\tVec3(100,2,2));\n\t MoveEntity\t (cranephy, Vec3(0,30,0));\n\t SetBodyMass\t(cranephy, 0);\n\t EntityType\t (cranephy, 1, 1);\n \n\t TEntity cubePhy[10];\n\t for(int i=1; i<=10; i++)\n\t {\n\t\t TEntity cube  = CreateCube(0);\t\t\t//Boxes\n\t\t cubePhy[i-1]  = CreateBodyBox(2,2,2,0);\n\t\t EntityParent   (cube,\tcubePhy[i-1],1);\n\t\t ScaleEntity\t(cube,\tVec3(2,2,2));\n\t\t SweptCollision (cubePhy[i-1], 1);\n\t\t MoveEntity\t (cubePhy[i-1], Vec3(0,i*2-1+10,0));\n\t\t SetBodyMass\t(cubePhy[i-1], 1);\n\t\t EntityType\t (cubePhy[i-1], 1,0);\n \n\t\t if(i==10)TEntity Joint = CreateJointHinge( cranephy,cubePhy[i-1], Vec3(0,29,0),Vec3(0,0,1));\n \t\tif(i>1)TEntity Joint = CreateJointHinge( cubePhy[i-1],cubePhy[i-2], Vec3(0,i*2-2+10,0),Vec3(0,0,1));\n\t }\n \n\t Collisions(1,1,1);\t\t\t\t\t\t\t\t\t\t// Important! Enable collision between bodys of type 1\n \n \n \n\t while(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t\t// Main Program\n\t {\n\t\t if(KeyHit(KEY_SPACE))AddBodyForce(cubePhy[rand()%10],Vec3(3000,0,0),0);\t// Apply force\n \n\t\t UpdateWorld(1);\n \n\t\t SetBuffer(buffer);\n\t\t RenderWorld();\n\t\t SetBuffer(BackBuffer());\n\t\t RenderLights(buffer);\n \n\t\t SetBlend   (BLEND_ALPHA);\n\t\t leDrawText (\"Press SPACE to apply force to one of the boxes!\",0,0);\n\t\t SetBlend   (0);\n\t\t Flip\t   (1);\n\t }\n \n\t Terminate();\n\t return(0);\n }"
      },
      {
        "name": "CreateJointSlider",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointslider-r254",
        "description": "Creates a new slider joint between the specified parent and child at the given location.",
        "c_syntax": "TJoint CreateJointSlider( TEntity parent, TEntity child, TVec3 &pos, TVec3 &pin )",
        "cpp_syntax": "SliderJoint::SliderJoint( TEntity ent = 0 )\nSliderJoint::SliderJoint( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin )\nvirtual void SliderJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin )",
        "example": "\n\n"
      },
      {
        "name": "CreateJointUniversal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/createjointuniversal-r256",
        "description": "Creates a new universal joint between the specified parent and child at the given location.",
        "c_syntax": "TJoint CreateJointUniversal( TEntity parent, TEntity child, TVec3 &pos, TVec3 &pin1, TVec3 &pin2 )",
        "cpp_syntax": "UniversalJoint::UniversalJoint( TEntity ent = 0 )\nUniversalJoint::UniversalJoint( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin1, const TVec3& pin2 )\nvirtual void UniversalJoint::Create( const TEntity parent, const TEntity child, const TVec3& pos, const TVec3& pin1, const TVec3& pin2 )",
        "example": "\n\n"
      },
      {
        "name": "FreeJoint",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/freejoint-r262",
        "description": "Frees the specified joint from memory. If a body connected to a joint is freed, the joint will automatically be freed.",
        "c_syntax": "void FreeJoint( TJoint joint )",
        "cpp_syntax": "void Joint::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "SetBallJointLimits",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/setballjointlimits-r260",
        "description": "Sets the rotation limits for the specified ball joint. The pin vector should be a normailized vector which defines the rotation (twist) axis.",
        "c_syntax": "void SetBallJointLimits( TJoint joint, TVec3 &pin=Vec3(0), flt maxConeAngle=0, flt maxTwistAngle=0)",
        "cpp_syntax": "void BallJoint::SetLimits( const Vector3& pin, flt maxConeAngle, flt maxTwistAngle )",
        "example": "\n\n"
      },
      {
        "name": "SetHingeJointLimits",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/sethingejointlimits-r258",
        "description": "Sets hinge joint limits. The default values are -180 and 180, for no joint limits. The angle is based on the angle between the parent and child bodies, which is considered 0 degrees.",
        "c_syntax": "void SetHingeJointLimits( TJoint, flt minangle, flt maxangle )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetJointCollisionMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/setjointcollisionmode-r261",
        "description": "If mode is set to 1, the bodys attached to the joint will collide with each other.",
        "c_syntax": "void SetJointCollisionMode(TJoint joint, int mode=1)",
        "cpp_syntax": "",
        "example": "\n\n"
      },
      {
        "name": "SetSliderJointLimits",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/joints/setsliderjointlimits-r259",
        "description": "Sets the slider joint's limits.",
        "c_syntax": "void SetSliderJointLimits(TJoint joint, flt mindistance=0, flt maxdistance=1)",
        "cpp_syntax": null,
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Lights",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/",
    "members": [
      {
        "name": "AmbientLight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/ambientlight-r278",
        "description": "Sets the flat ambient light level that will be used when RenderLights() is called.",
        "c_syntax": "void AmbientLight( TVec3 &color )",
        "cpp_syntax": "void World::SetAmbientLight( const TVec3& color )Example\n//This",
        "example": "\n//This example demonstrates AmbientLight settings.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AmbientLight\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create the camera\n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,2,-6) );\n  \n\t//Create a plane\n\tTEntity box1  = CreateCube();\n\tMoveEntity   (box1,  Vec3(-1,1,0) );\n\n\t//Create a plane\n\tTEntity box2  = CreateCube();\n\tMoveEntity   (box2,  Vec3(1,1,0) );\n\n\t//Create a plane\n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Creates a directional light\n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(60,45,0), 0);\n\tSetShadowmapSize(light,1024);\n\tAmbientLight(Vec3(0.05,0.05,0.1));\n \n\tfloat ambient = 0.5;\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tif(KeyHit(KEY_LEFT))\n\t\t\tAmbientLight(Vec3(ambient -= 0.1));\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t\tAmbientLight(Vec3(ambient += 0.1));\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press the left and right arrow keys to raise or lower the Ambient light setting.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "CreateDirectionalLight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/createdirectionallight-r266",
        "description": "Creates a directional light. Directional lights are used for outdoor lighting. Directional lights are relatively expensive to render, because they must draw the entire scene multiple times.\nSetLightRange() does not alter the distance allocation of a directional light, but only the z-depth over which the shadows are rendered relative to the light view.",
        "c_syntax": "TLight CreateDirectionalLight(TEntity parent=NULL)",
        "cpp_syntax": "DirectionalLight::DirectionalLight( const CreateMode& rCreateMode, const TEntity parent = 0 ) Set rCreateMode to CREATENOW for immediate creation\nvirtual void DirectionalLight::Create( const TEntity = 0 )Example\n//This",
        "example": "\n//This example demonstrates the creation of a directional light.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DirectionalLight\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create the camera\n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,2,-8) );\n  \n\t//Create a plane\n\tTEntity box1  = CreateCube();\n\tMoveEntity   (box1,  Vec3(-1,2,0) );\n\n\t//Create a plane\n\tTEntity box2  = CreateCube();\n\tMoveEntity   (box2,  Vec3(1,2,0) );\n\n\t//Create a plane\n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Creates a directional light\n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(60,45,0), 0);\n\tSetShadowmapSize(light,1024);\n\tAmbientLight(Vec3(0.05,0.05,0.1));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(light, Vec3(0.2 * AppSpeed(), 0, 1 * AppSpeed()));\n\n\t\tUpdateAppTime();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"This creates a directional light. The main loop rotates the light around.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "CreatePointLight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/createpointlight-r264",
        "description": "Creates a point light. Point lights can be fairly expensive to render in scene with a lot of moving objects, because each point light shadow map is made of 6 images.",
        "c_syntax": "TLight CreatePointLight( flt range=10, TEntity parent=NULL )",
        "cpp_syntax": "PointLight::PointLight::Create( flt range, TEntity parent = 0 )\nvoid PointLight::Create( flt range=10.0f, TEntity parent = 0 )",
        "example": "\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Point Light Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreatePointLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n\n"
      },
      {
        "name": "CreateSpotLight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/createspotlight-r265",
        "description": "Creates a spot light. Spot lights are relatively low-cost to render.",
        "c_syntax": "TLight CreateSpotLight( flt range=10, TEntity parent=NULL )",
        "cpp_syntax": "SpotLight::SpotLight( flt range, const TEntity = 0 )\nvirtual void SpotLight::Create( flt range, const TEntity = 0 )Example\n//This",
        "example": "\n//This example demonstrates the creation of a spot light. \n//The spot light is then painted with a texture which will be projected over the light to create a flashligh-like pattern.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"Textured Spot Light Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "GetLightRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/getlightrange-r274",
        "description": "Gets a light's range.",
        "c_syntax": "flt GetLightRange( TLight light )",
        "cpp_syntax": "virtual flt Light::GetRange( void )Example\n//This",
        "example": "\n//This example demonstrates the creation of a spot light. \n//Press the left and right key to adjust the light range of the spot light\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"LightRange\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat range = 15;\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\n\t\t//Press the left and right key to adjust the light range of the spot light\n\t\tif(KeyHit(KEY_LEFT))\n\t\t\tLightRange(light, range--  );\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t\tLightRange(light, range++);\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press the left and right key to adjust the light range of the spot light\");\n\t\t\tDrawText(0,15, \"LightRange: %f\", GetLightRange(light)  );\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "GetShadowQuality",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/getshadowquality-r277",
        "description": "Returns the quality of shadow maps. 1 is the highest quality, 3 is the lowest quality. 0 means that shadows are off.",
        "c_syntax": "int GetShadowQuality( void )",
        "cpp_syntax": "ShadowQuality Engine::GetShadowQual( void ) Where ShadowQuality is NoShadow, LowShadow, MediumShadow or HighShadowExample\n//This",
        "example": "\n//This example demonstrates Shadow quality.\n//Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"LightRange\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat range = 15;\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\n\t\t//Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\n\t\tif(KeyHit(KEY_1))\n\t\t\tSetShadowQuality(0);\n\t\telse if(KeyHit(KEY_2))\n\t\t\tSetShadowQuality(3);\n\t\telse if(KeyHit(KEY_3))\n\t\t\tSetShadowQuality(2);\n\t\telse if(KeyHit(KEY_4))\n\t\t\tSetShadowQuality(1);\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\");\n\t\t\tDrawText(0,15, \"ShadowQuality: %i\", GetShadowQuality()  );\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n\n"
      },
      {
        "name": "LightConeAngles",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/lightconeangles-r269",
        "description": "Sets the inner and outer light cone angles of a spotlight. These control the light volume and focus of the light.",
        "c_syntax": "int LightConeAngles( TLight light, flt innerangle, flt outerangle )",
        "cpp_syntax": "void SpotLight::SetConeAngles( flt innerAngle, flt outerAngle )Example\n//This",
        "example": null
      },
      {
        "name": "LightFalloff",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/lightfalloff-r268",
        "description": "Toggles light square falloff inversion. 0 means no invert, 1 means invert. Basically just makes the light (point or spot) a bit brighter because the light strength reduces slower (you invert the square falloff with this command, resulting in less reduction in the beginning and more in the end).",
        "c_syntax": "void LightFalloff(TLight light, int inversesquarefalloff)",
        "cpp_syntax": null,
        "example": "\n//These images show a spot light. The light on the second picture second has inverted falloff.\n#include \"engine.h\"\n#include \"math.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tSetShadowQuality(1);\n \n\tTEntity camera = CreateCamera(0);\n\tTEntity cube   = CreateCube(0);\t\t// In LE2.1, the cubes size is 1x1x1\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTEntity plane  = CreateCube(0);\n\tTEntity light  = CreatePointLight(15,0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n \n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n\tint falloff = 0;LightFalloff(light,falloff);\n \n\tAmbientLight(Vec3(.05));\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tif (KeyHit(KEY_ENTER))\n\t\t{\n\t\t\tfalloff = !falloff;\n\t\t\tLightFalloff(light,falloff);\n\t\t}\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tDrawText(32,32,\"Press enter to toggle light falloff (current : %d).\", falloff);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "LightRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/lightrange-r267",
        "description": "Sets the range of a light.",
        "c_syntax": "void LightRange( TLight light, flt range = 10 )",
        "cpp_syntax": "virtual void Light::SetRange( flt range = 10 )Example\n//This",
        "example": "\n//This example demonstrates the creation of a spot light. \n//Press the left and right key to adjust the light range of the spot light\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"LightRange\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat range = 15;\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\n\t\t//Press the left and right key to adjust the light range of the spot light\n\t\tif(KeyHit(KEY_LEFT))\n\t\t\tLightRange(light, range--  );\n\t\tif(KeyHit(KEY_RIGHT))\n\t\t\tLightRange(light, range++);\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press the left and right key to adjust the light range of the spot light\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "RenderLights",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/renderlights-r275",
        "description": "Renders all lights of the current world into the current buffer, using the given buffer for geometry data. The current buffer is usually set before the RenderLights() command as BackBuffer(). Usually the given buffer was previously rendered using RenderWorld(). When using post-shaders, the current buffer is set before the RenderLights() command to a postbuffer instead of the BackBuffer().",
        "c_syntax": "void RenderLights( TBuffer buffer )",
        "cpp_syntax": "void Engine::RenderLights( TBuffer buffer )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n \n\t// Create a graphics window\n\tGraphics(800,600);\n \n\t// Create a world\n\tif (!CreateWorld())\n\t{\n\t\tMessageBoxA(0,\"Error\",\"Failed to create world.\",0);\n\t\tgoto exitapp;\n\t}\n \n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Create a camera\n\tTEntity cam = CreateCamera();\n\tMoveEntity (cam, Vec3(0,0,-5) );\n \n\t// Create a visual mesh\n\tTEntity mesh = CreateCube();\n \n\t//Create another mesh to cast a shadow on\n\tTMesh ground=CreateCube();\n\tScaleMesh(ground,Vec3(10,0.1,10));\n\tPositionEntity(ground,Vec3(0,-2,0));\n \n\t//Create a spotlight\n\tTLight light=CreateSpotLight();\n\tPositionEntity(light,Vec3(2,2,-2));\n\tRotateEntity(light,Vec3(45,45,0));\n \n\t// Main program loop\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n \n\t\t// Make the visual mesh spin\n\t\tTurnEntity (mesh, Vec3(0.5f));\n \n\t\t// Update timing and physics\n\t\tUpdateWorld();\n \n \n\t\t//Make our render buffer the current buffer\n\t\tSetBuffer(buffer);\n \n\t\t//Render the world to the render buffer\n\t\tRenderWorld();\n \n\t\t//Make the back buffer the current buffer\n\t\tSetBuffer(BackBuffer());\n \n\t\t//Call the RenderLights command, passing our buffer which \n\t\t//contains color, depth, and normal data\n\t\tRenderLights(buffer);\n \n\t\t//Swap the buffers so we can see what was drawn\n\t\tFlip ();\n\t}\n \n\texitapp:\t\t\n\tTerminate();\n\treturn 0;\n}\n\n"
      },
      {
        "name": "SetShadowDistance",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/setshadowdistance-r273",
        "description": "Sets the distance of each stage of a directional light.\nThe default distances are as follows:viewrange[0]=8viewrange[1]=40viewrange[2]=80",
        "c_syntax": "void SetShadowDistance( TLight light, flt range, int stage = 0 )",
        "cpp_syntax": "void Light::SetShadowDistance( flt range, int stage )Example\n//This",
        "example": "\n//This example demonstrates the creation of a directional light.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"DirectionalLight\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create the camera\n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,2,-8) );\n  \n\t//Create a plane\n\tTEntity box1  = CreateCube();\n\tMoveEntity   (box1,  Vec3(-1,2,0) );\n\n\t//Create a plane\n\tTEntity box2  = CreateCube();\n\tMoveEntity   (box2,  Vec3(1,2,0) );\n\n\t//Create a plane\n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Creates a directional light\n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(60,45,0), 0);\n\tSetShadowmapSize(light,1024);\n\tAmbientLight(Vec3(0.05,0.05,0.1));\n\t\n\t//setting the shadow distance\n\tSetShadowDistance(light,5,0);\n\tSetShadowDistance(light,9,1);\n\tSetShadowDistance(light,14,2);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(light, Vec3(0.2 * AppSpeed(), 0, 1 * AppSpeed()));\n\n\t\tUpdateAppTime();\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"This creates a directional light. The main loop rotates the light around.\");\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetShadowmapSize",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/setshadowmapsize-r270",
        "description": "Sets a light's shadowmap resolution. Power-of-two sizes should be used. Decreasing shadowmap resolution can improve performance, but will lower quality.",
        "c_syntax": "void SetShadowmapSize( TLight light, int size )",
        "cpp_syntax": "virtual void Light::SetShadowmapSize( int size )",
        "example": "\n#include \"engine.h\"\n#include \"math.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tSetShadowQuality(1);\n \n \n\tTEntity camera = CreateCamera(0);\n\tMoveEntity   (camera, Vec3(6,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity plane  = CreateCube(0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tint shadowmapsize = 8;\n\t// Light1\n\tTEntity light1  = CreateSpotLight(15,0);\n\tMoveEntity   (light1,  Vec3(0,5,0) );\n\tRotateEntity (light1,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light1,20,30);\n\tSetShadowSoftness(light1,0);\n \n\tTEntity cube1   = CreateCube();\t\t\n\tScaleEntity  (cube1,  Vec3(2,2,2) ); \n\tMoveEntity   (cube1,  Vec3(0,0,0) );\n \n\t// Light2\n\tTEntity light2  = CreateSpotLight(25,0);\n\tMoveEntity   (light2,  Vec3(6,5,0) );\n\tRotateEntity (light2,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light2,20,30);\n\tSetShadowSoftness(light2,2);\n \n\tTEntity cube2   = CreateCube();\t\t\n\tScaleEntity  (cube2,  Vec3(2,2,2) ); \n\tMoveEntity   (cube2,  Vec3(6,0,0) );\n \n\t// Light3\n\tTEntity light3  = CreateSpotLight(35,0);\n\tMoveEntity   (light3,  Vec3(12,5,0) );\n\tRotateEntity (light3,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light3,20,30);\n\tSetShadowSoftness(light3,4);\n \n\tTEntity cube3   = CreateCube();\t\t\n\tScaleEntity  (cube3,  Vec3(2,2,2) ); \n\tMoveEntity   (cube3,  Vec3(12,0,0) );\n \n\t// Set shadowmap\n\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n \n \n\tAmbientLight(Vec3(.05));\n \n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity   (camera, Vec3(6+6*cos(AppTime()/1000.0),3,-4) );\n \n\t\tUpdateAppTime();\n\t\tTurnEntity(cube1, Vec3(0.1,0.2,0.3), 0);\n\t\tTurnEntity(cube2, Vec3(0.1,0.2,0.3), 0);\n\t\tTurnEntity(cube3, Vec3(0.1,0.2,0.3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tif(KeyHit(KEY_NUMADD))\n\t\t{\n\t\t\tshadowmapsize++;\n\t\t\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n\t\t}\n\t\tif(KeyHit(KEY_NUMSUBTRACT))\n\t\t{\n\t\t\tshadowmapsize--;\n\t\t\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n\t\t}\n \n\t\tSetBlend   (BLEND_ALPHA);\n\t\tleDrawText (\"ShadowSoftness (l.to r.): 0,2,4\",0,0);\n\t\tleDrawText (\"Use the add/subtract keys to change the shadowmapsize.\",0,20);\n\t\tchar s[256];\n\t\tsprintf_s(s,256,\"Shadowmapsize: %d\", int(pow(2.f,shadowmapsize)) );\n\t\tleDrawText (s,0,40);\n\t\tSetBlend   (0);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetShadowOffset",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/setshadowoffset-r271",
        "description": "Sets a light's shadowmap offset. This is a small value by which the shadow depth is adjusted. If the shadowmap offset is too little, shadow acne may appear. The stage parameter can be used to adjust each of the 4 stages of a directional light. The stage parameter should be set to 0 for point and spot lights.Point lights:\n0.0 linear and 0.96 multiplicative. // point light linear offset should always be 0 so the edges match.\nWhat this means if the camera is offset 0 units and the camera range when rendering shadows is actually the light range * 0.96. So it renders a little less than the full range and stretches the shadow depth out by the full range. Use a lower number like 0.92 to eliminate shadow acne.Spot lights:\n0.01,1.0\nDirectional lights:\n0.31, 1.0 - stage 1\n0.40, 1.0 - stage 2\n0.70, 1.0 - stage 3\n1.50, 1.0 - stage 4\nNotice as the stages progress and pixels cover larger areas, the offset has to be increased.",
        "c_syntax": "void SetShadowOffset( TLight light, flt linearOffset, flt exponentialOffset, int stage=0 )Example\n//This",
        "cpp_syntax": null,
        "example": "\n//This example demonstrates ShadowOffset\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"ShadowOffset\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tSetShadowOffset(light, 0.01, 1.0);\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetShadowQuality",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/setshadowquality-r276",
        "description": "Sets the quality of shadow maps. 1 is the highest quality, 3 is the lowest quality. 0 turns shadows off. There are constants defined for the possible values:SHADOW_QUALITY_DISABLEDSHADOW_QUALITY_HIGHSHADOW_QUALITY_MEDIUMSHADOW_QUALITY_LOW",
        "c_syntax": "void SetShadowQuality( int quality )",
        "cpp_syntax": "void Engine::SetShadowQual( const ShadowQuality& quality ) Where quality is NoShadow, LowShadow, MediumShadow or HighShadowExample\n//This",
        "example": "\n//This example demonstrates Shadow quality.\n//Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"LightRange\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat range = 15;\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\n\t\t//Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\n\t\tif(KeyHit(KEY_1))\n\t\t\tSetShadowQuality(0);\n\t\telse if(KeyHit(KEY_2))\n\t\t\tSetShadowQuality(3);\n\t\telse if(KeyHit(KEY_3))\n\t\t\tSetShadowQuality(2);\n\t\telse if(KeyHit(KEY_4))\n\t\t\tSetShadowQuality(1);\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Press 0 to turn shadows of. Press 1, 2 and 3 to set the quality\");\n\t\t\tDrawText(0,15, \"ShadowQuality: %i\", GetShadowQuality()  );\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n\n"
      },
      {
        "name": "SetShadowSoftness",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/lights/setshadowsoftness-r272",
        "description": "Sets the overall softness of a light's shadow. Values under 5 are recommended.",
        "c_syntax": "void SetShadowSoftness(TLight light, flt softness)",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n#include \"math.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tSetShadowQuality(1);\n \n \n\tTEntity camera = CreateCamera(0);\n\tMoveEntity   (camera, Vec3(6,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity plane  = CreateCube(0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tint shadowmapsize = 8;\n\t// Light1\n\tTEntity light1  = CreateSpotLight(15,0);\n\tMoveEntity   (light1,  Vec3(0,5,0) );\n\tRotateEntity (light1,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light1,20,30);\n\tSetShadowSoftness(light1,0);\n \n\tTEntity cube1   = CreateCube();\t\t\n\tScaleEntity  (cube1,  Vec3(2,2,2) ); \n\tMoveEntity   (cube1,  Vec3(0,0,0) );\n \n\t// Light2\n\tTEntity light2  = CreateSpotLight(25,0);\n\tMoveEntity   (light2,  Vec3(6,5,0) );\n\tRotateEntity (light2,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light2,20,30);\n\tSetShadowSoftness(light2,2);\n \n\tTEntity cube2   = CreateCube();\t\t\n\tScaleEntity  (cube2,  Vec3(2,2,2) ); \n\tMoveEntity   (cube2,  Vec3(6,0,0) );\n \n\t// Light3\n\tTEntity light3  = CreateSpotLight(35,0);\n\tMoveEntity   (light3,  Vec3(12,5,0) );\n\tRotateEntity (light3,  Vec3(90,0,0), 0);\n \n\tLightConeAngles(light3,20,30);\n\tSetShadowSoftness(light3,4);\n \n\tTEntity cube3   = CreateCube();\t\t\n\tScaleEntity  (cube3,  Vec3(2,2,2) ); \n\tMoveEntity   (cube3,  Vec3(12,0,0) );\n \n\t// Set shadowmap\n\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n \n \n\tAmbientLight(Vec3(.05));\n \n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity   (camera, Vec3(6+6*cos(AppTime()/1000.0),3,-4) );\n \n\t\tUpdateAppTime();\n\t\tTurnEntity(cube1, Vec3(0.1,0.2,0.3), 0);\n\t\tTurnEntity(cube2, Vec3(0.1,0.2,0.3), 0);\n\t\tTurnEntity(cube3, Vec3(0.1,0.2,0.3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tif(KeyHit(KEY_NUMADD))\n\t\t{\n\t\t\tshadowmapsize++;\n\t\t\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n\t\t}\n\t\tif(KeyHit(KEY_NUMSUBTRACT))\n\t\t{\n\t\t\tshadowmapsize--;\n\t\t\tSetShadowmapSize(light1,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light2,pow(2.f,shadowmapsize));\n\t\t\tSetShadowmapSize(light3,pow(2.f,shadowmapsize));\n\t\t}\n \n\t\tSetBlend   (BLEND_ALPHA);\n\t\tleDrawText (\"ShadowSoftness (l.to r.): 0,2,4\",0,0);\n\t\tleDrawText (\"Use the add/subtract keys to change the shadowmapsize.\",0,20);\n\t\tchar s[256];\n\t\tsprintf_s(s,256,\"Shadowmapsize: %d\", int(pow(2.f,shadowmapsize)) );\n\t\tleDrawText (s,0,40);\n\t\tSetBlend   (0);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      }
    ]
  },
  {
    "name": "Listeners",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/listeners/",
    "members": [

    ]
  },
  {
    "name": "Materials",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/",
    "members": [
      {
        "name": "CreateMaterial",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/creatematerial-r282",
        "description": "Creates a new material.",
        "c_syntax": "TMaterial CreateMaterial(void)",
        "cpp_syntax": "void Material::Create( void )Example\n//This",
        "example": "\n//This example shows how to create a material trough code and then paint this material onto a cube.\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"CreateMaterial Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(3,3,3) ); \n\tTMaterial material = CreateMaterial();\n\tSetMaterialShader(material, LoadShader(\"abstract::mesh.vert\",\"abstract::mesh_diffuse.frag\"));\n\tSetMaterialTexture(material, LoadTexture(\"abstract::oildrum.dds\"));\n\tPaintEntity(cube,material);\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(45,45,0), 0);\n \n\tAmbientLight(Vec3(.05,.05,.2));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,0.5,0.2), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "DisableMaterialCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/disablematerialcallback-r296",
        "description": "This will be called whenever the material is disabled. That is, when drawing with this material ends.",
        "c_syntax": "void DisableMaterialCallback( TMaterial material )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "EnableMaterialCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/enablematerialcallback-r294",
        "description": "This will be called whenever the material is enabled. That is, when drawing with this material is started.",
        "c_syntax": "void EnableMaterialCallback( TMaterial material )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "FreeMaterial",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/freematerial-r292",
        "description": "Frees the specified material from memory.",
        "c_syntax": "void FreeMaterial(TMaterial material)",
        "cpp_syntax": "void Material::Free(void) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "GetMaterialKey",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/getmaterialkey-r286",
        "description": "Returns the value of a material key as a string.",
        "c_syntax": "str GetMaterialKey(TMaterial material, str key)",
        "cpp_syntax": "str Material::GetKey( const_str key )",
        "example": "\n\n"
      },
      {
        "name": "GetMaterialShader",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/getmaterialshader-r285",
        "description": "Returns a handle to the shader of the specified material.",
        "c_syntax": "TShader GetMaterialShader(TMaterial material, int shadow=0)",
        "cpp_syntax": "Shader Material::GetShader( bool shadow ) const",
        "example": "\n\n"
      },
      {
        "name": "GetMaterialTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/getmaterialtexture-r287",
        "description": "Retrieves the material's texture for the specified texture unit, if it exists.",
        "c_syntax": "TTexture GetMaterialTexture( TMaterial material, int stage )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "LoadMaterial",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/loadmaterial-r283",
        "description": "Loads a material from a file. If a material with this filename has already been loaded, it'll return a reference to that to avoid loading assets twice.",
        "c_syntax": "TMaterial LoadMaterial( str filepath )",
        "cpp_syntax": "virtual void Material::Load( const_str filepath )Example\nThis",
        "example": "\nThis example shows how to load a material that comes with the engine and then paint this material onto a cube.\n\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"PaintEntity Demo\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(3,3,3) ); \n\tTMaterial material = LoadMaterial(\"abstract::oildrum.mat\");\n\tPaintEntity(cube,material);\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\tTEntity light  = CreateDirectionalLight();\n\tRotateEntity (light,  Vec3(45,45,0), 0);\n \n\tAmbientLight(Vec3(.05,.05,.2));\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tUpdateAppTime();\n \n\t\tTurnEntity(cube, Vec3(1,0.5,0.2), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "MaterialDrawCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/materialdrawcallback-r295",
        "description": "Gets called for every instance that is drawn that has this material. Using this will disable fast instanced rendering for any entities with that material.",
        "c_syntax": "void MaterialDrawCallback( TMaterial material );",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "MaterialName",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/materialname-r284",
        "description": "Returns the name of the specified material.",
        "c_syntax": "str MaterialName( TMaterial material )",
        "cpp_syntax": "std::string Material::GetName( void ) const",
        "example": "\n\n"
      },
      {
        "name": "SetMaterialCallback",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/setmaterialcallback-r293",
        "description": "Sets a callback function for the material. callbackID can be one of the following (links to how the functions has to be declared, see below):MATERIALCALLBACK_ENABLEMATERIALCALLBACK_DRAWMATERIALCALLBACK_DISABLE",
        "c_syntax": "void SetMaterialCallback(TMaterial material, byte* callback, int callbackID )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetMaterialColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/setmaterialcolor-r290",
        "description": "Sets the material's color.",
        "c_syntax": "void SetMaterialColor( TMaterial material, TVec4& color )",
        "cpp_syntax": "void Material::SetColor( const TVec4& color )",
        "example": "\n\n"
      },
      {
        "name": "SetMaterialKey",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/setmaterialkey-r291",
        "description": "Sets a material's key and its value.",
        "c_syntax": "void SetMaterialKey( TMaterial material, str key, str value )",
        "cpp_syntax": "void Material::SetKey( const_str key, const_str value )",
        "example": "\n\n"
      },
      {
        "name": "SetMaterialShader",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/setmaterialshader-r289",
        "description": "Sets the material's shader. Use the shadow parameter to tell if you want to set the 'shadowshader' (1) or just the 'shader' (0).",
        "c_syntax": "void SetMaterialShader( TMaterial material, TShader shader, int shadow=0 )",
        "cpp_syntax": "void Material::SetShader( const Shader& rShader, bool shadow )",
        "example": "\n\n"
      },
      {
        "name": "SetMaterialTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/materials/setmaterialtexture-r288",
        "description": "Sets the individual textures for a material the same way as the .mat file does with texture0, texture1, texture2, texture3.",
        "c_syntax": "void SetMaterialTexture( TMaterial material, TTexture texture, int stage )",
        "cpp_syntax": "void Material::SetTexture( const Texture& rTexture, int stage = 0 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Meshes",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/",
    "members": [
      {
        "name": "AddMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/addmesh-r308",
        "description": "Adds a mesh to another mesh.",
        "c_syntax": "void AddMesh(TMesh src, TMesh dst)",
        "cpp_syntax": "void Mesh::Add( const Mesh& m )",
        "example": "\n\n"
      },
      {
        "name": "AddMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/addmesh-r309",
        "description": "Adds a mesh to another mesh.",
        "c_syntax": "void AddMesh(TMesh src, TMesh dst)",
        "cpp_syntax": "void Mesh::Add( const Mesh& m )",
        "example": "\n\n"
      },
      {
        "name": "CountSurfaces",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/countsurfaces-r315",
        "description": "Returns the number of surfaces in a mesh.",
        "c_syntax": "long CountSurfaces(TMesh mesh)",
        "cpp_syntax": "long Mesh::GetCountSurfaces( void ) const",
        "example": "\n\n"
      },
      {
        "name": "CreateCone",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createcone-r302",
        "description": "Creates a cone with diameter and height 2. The number of segments can be raised to make a rounder cone, usually 16 is round enough, and 32 is very round, but requires also more computing power.",
        "c_syntax": "TMesh CreateCone( int segments=16, int closed=1, TEntity parent=NULL )",
        "cpp_syntax": "Cube::Cone( int segments , bool closed = true, const TEntity = 0 )\nvirtual void Cube::Create( int segments = 8, bool closed = true, const TEntity = 0 )",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include <math.h>\n \nTMesh MyCreateCone(int segments = 8, int solid = 1, TEntity parent = 0)\n{\n\tfloat radius = 1.0f, height = 2.0f;\n\tfloat upVector = cos(atan(height/radius));\n \n\tTMesh\t\tMesh\t= CreateMesh();\n\tTSurface\tsurface = CreateSurface(Mesh);\n \n\t// coat vertices\n\tfor(int i = 0; i <= segments; i++)\n\t{\n\t\tfloat angle = ((2 * M_PI) / segments) * i;\n\t\tAddVertex(surface,\n\t\t   Vec3(cos(angle) * radius, -height/2.0f, sin(angle) * radius),\n\t\t   Vec3(cos(angle), upVector, sin(angle))\n\t\t   );\n\t}\n \n\t// top vertex\n\tlong topVert = segments + 1;\n\tAddVertex(surface,\n\t\t   Vec3(0, height/2.0f, 0),\n\t\t   Vec3(0, 1, 0)\n\t\t   );\n \n\t// bottom vertices\n\tlong downVerts = segments + 2;\n\tfor(int i = 0; i <= segments; i++)\n\t{\n\t\tfloat angle = ((2 * M_PI) / segments) * i;\n\t\tAddVertex(surface,\n\t\t\tVec3(cos(angle) * radius, -height/2.0f, sin(angle) * radius),\n\t\t\tVec3(0, -1, 0)\n\t\t\t);\n\t}\n \n\t// coat triangles\n\tfor(int i = 0; i < segments; i++)\n\t{\n\t\tAddTriangle(surface, i, topVert, i + 1);\t\n\t}\n \n\t// bottom triangles\n\tfor(int i = 1; i < segments; i++)\n\t{\n\t\tAddTriangle(surface, downVerts, downVerts + i, downVerts + i + 1);\n\t}\n \n\tUpdateMesh(Mesh);\n\tif(parent != NULL)EntityParent(Mesh, parent);\n \n\treturn Mesh;\n}\n"
      },
      {
        "name": "CreateCube",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createcube-r300",
        "description": "Creates a cube of size 1x1x1.",
        "c_syntax": "TMesh CreateCube( TEntity parent=NULL )",
        "cpp_syntax": "Cube::Cube( const CreateMode& createMode, const TEntity parent = 0 ) Set createMode = CREATENOW for immediate creation\nvirtual void Cube::Create( const TEntity parent = 0 )",
        "example": "\n#include \"engine.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tTEntity world = CreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTEntity plane  = CreateCube(0);\n\tTEntity light  = CreateSpotLight(15,0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n\tMoveEntity   (camera, Vec3(0,0,-5) );\n\tMoveEntity   (light,  Vec3(-1,5,-4) );\n\tRotateEntity (light,  Vec3(45,0,0), 0);\n \n\tSetShadowmapSize(light,512);\n \n\tAmbientLight(Vec3(.05));\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "CreateCylinder",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createcylinder-r301",
        "description": "Creates a cylinder with diameter and height 1. The number of segments can be raised to make a rounder cone, usually 16 is round enough, and 32 is very round, but requires also more computing power.",
        "c_syntax": "TMesh CreateCylinder(int segments=8, int height=1, TEntity parent=NULL)",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera(0);\n\tTEntity cylinder1 = CreateCylinder(16,1,0);\n\tMoveEntity\t\t(cylinder1,Vec3(-2,0,0));\n\tScaleEntity\t\t(cylinder1,  Vec3(2) );\n \n\tTEntity cylinder2 = CreateCylinder(32,1,0);  //More detailed one\n\tMoveEntity\t\t(cylinder2,Vec3(1,0,0));\n\tScaleEntity\t\t(cylinder2,  Vec3(2) );\n \n \n\tTEntity plane  = CreateCube(0);\n\tTEntity light  = CreateSpotLight(15,0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n\tMoveEntity   (camera, Vec3(0,0,-5) );\n\tMoveEntity   (light,  Vec3(-1,2,-4) );\n\tRotateEntity (light,  Vec3(25,0,15), 0);\n\tAmbientLight(Vec3(.05));\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(cylinder1, Vec3(1,2,3), 0);\n\t\tTurnEntity(cylinder2, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "CreateDecal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createdecal-r305",
        "description": "Generates a mesh exactly aligned to the specified surface. This can be used for decals. The decal should afterwards be parented to the entity which was hit/whose surface was hit.",
        "c_syntax": "TMesh\tCreateDecal(TSurface surface, TVec3 &position, flt radius, int maxtris=0)",
        "cpp_syntax": "TMesh Surface::CreateDecal( const TVec3& pos, flt radius, int matrix = 0 ) const",
        "example": "\nTPick _Picked;\nCameraPick( &_Picked, Camera ( framework camera here ), Vec3(GraphicsWidth() / 2, GraphicsHeight() / 2, 100), 0);\n \nTMesh _Decal = CreateDecal(_Picked.surface, TFormPoint(Vec3(_Picked.X, _Picked.Y, _Picked.Z), NULL, _Picked.entity), 20.0/16.0, 32);\n \n \nEntityParent(_Decal , _Picked.entity, 0);\nPaintEntity(_Decal , LoadMaterial(\"abstract::bullethole.mat\"));\n \nAddMesh(_Decal , _Picked.entity);\n"
      },
      {
        "name": "CreateMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createmesh-r299",
        "description": "Creates an empty mesh.",
        "c_syntax": "TMesh CreateMesh( TEntity parent )",
        "cpp_syntax": "virtual void Mesh::Create( const TEntity parent = 0 )\nMesh::Mesh( CreateNow )",
        "example": "\n\n"
      },
      {
        "name": "CreatePlane",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createplane-r304",
        "description": "Creates a plane.",
        "c_syntax": "TMesh CreatePlane( TEntity parent=NULL )",
        "cpp_syntax": "Plane::Plane( const CreateMode& rCreateMode, const TEntity parent = 0 )\nvirtual void Plane::Create( const TEntity = 0 )",
        "example": "\n#include \"engine.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera(0);\n\tTEntity plane   = CreatePlane(0);\n\tTEntity ground  = CreateCube(0);\n\tTEntity light  = CreateSpotLight(15,0);\n\tScaleEntity  (ground,  Vec3(100,1,100) );\n\tMoveEntity   (ground,  Vec3(0,-5,0) );\n\tMoveEntity   (camera, Vec3(0,0,-5) );\n\tMoveEntity   (light,  Vec3(-1,2,-4) );\n\tRotateEntity (light,  Vec3(25,0,15), 0);\n\tAmbientLight(Vec3(.05));\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(plane, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "CreateSphere",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createsphere-r303",
        "description": "Creates a sphere with diameter 2. The number of segments can be raised to make a rounder sphere, usually 16 is round enough, and 32 is very round, but requires also more computing power.",
        "c_syntax": "TMesh CreateSphere( int segments=8, TEntity parent=NULL )",
        "cpp_syntax": "Sphere::Sphere( int segments , const TEntity = 0 )\nvirtual void SphereCreate( int segments = 8, const TEntity = 0 )",
        "example": "\n#include \"engine.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tTEntity world  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tSetShadowQuality(1);\n \n\tTEntity camera = CreateCamera(0);\n\tTEntity sphere1 = CreateSphere(8,0);\n\tMoveEntity\t\t(sphere1,Vec3(-2,0,0));\n \n\tTEntity sphere2 = CreateSphere(16,0);  //More detailed one\n\tMoveEntity\t\t(sphere2,Vec3(1,0,0));\n \n \n\tTEntity plane  = CreateCube(0);\n\tTEntity light  = CreateSpotLight(15,0);\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n\tMoveEntity   (camera, Vec3(0,0,-5) );\n\tMoveEntity   (light,  Vec3(-1,2,-4) );\n\tRotateEntity (light,  Vec3(25,0,15), 0);\n \n\tSetShadowmapSize(light,512);\n\tSetShadowSoftness(light,1);\n \n\tAmbientLight(Vec3(.05));\n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(sphere1, Vec3(1,2,3), 0);\n\t\tTurnEntity(sphere2, Vec3(1,2,3), 0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n\n"
      },
      {
        "name": "CreateSurface",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/createsurface-r314",
        "description": "Creates a new surface and adds it to the specified mesh.",
        "c_syntax": "TSurface CreateSurface( TMesh mesh )",
        "cpp_syntax": "Surface Mesh::CreateSurface( const Material& material )",
        "example": "\n\n"
      },
      {
        "name": "FindSurface",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/findsurface-r317",
        "description": "Finds a surface in the mesh provided with the given material.",
        "c_syntax": "TSurface FindSurface(TMesh mesh, TMaterial material=NULL)",
        "cpp_syntax": "Surface Mesh::FindSurface( const Material& material ) const",
        "example": "\n\n"
      },
      {
        "name": "FlipMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/flipmesh-r310",
        "description": "Reverses the triangle order of all surfaces in the mesh.",
        "c_syntax": "void FlipMesh( TMesh mesh )",
        "cpp_syntax": "void Mesh::Flip( void )",
        "example": "\n\n"
      },
      {
        "name": "GetSurface",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/getsurface-r316",
        "description": "Returns the surface number INDEX of the MESH. Surfaces are numbered 1 to CountSurfaces().",
        "c_syntax": "TSurface GetSurface(TMesh mesh, long index=1)",
        "cpp_syntax": "Surface Mesh::GetSurface( long index ) const",
        "example": "\n\n"
      },
      {
        "name": "LoadMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/loadmesh-r298",
        "description": "Loads a mesh from the specified file. If a mesh with the specified filename has already been loaded, it'll return a reference to that to avoid loading assets twice.",
        "c_syntax": "TMesh LoadMesh(str name, TEntity parent=NULL)",
        "cpp_syntax": "Mesh::Mesh( const_str filepath, const TEntity = 0 )\nvoid Mesh::Load( str filepath )",
        "example": "\n\n"
      },
      {
        "name": "MeshName",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/meshname-r306",
        "description": "Returns the name of the mesh.",
        "c_syntax": "str MeshName( TEntity mesh )",
        "cpp_syntax": "std::string Mesh::GetName( void ) const",
        "example": "\n\n"
      },
      {
        "name": "RotateMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/rotatemesh-r312",
        "description": "Rotates the mesh by rotating all of it's vertices. (This does not do the same as RotateEntity, which just alters the entity's transformation matrix!)",
        "c_syntax": "void RotateMesh(TMesh mesh, TVec3 &rotation)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "ScaleMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/scalemesh-r311",
        "description": "Scales the mesh by scaling all of it's vertices. (This does not do the same as ScaleEntity, which just alters the entity's matrix!)",
        "c_syntax": "void ScaleMesh(TMesh mesh, TVec3 &scale=Vec3(1))",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TranslateMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/translatemesh-r313",
        "description": "Translates the mesh by moving all of it's vertices. (This does not do the same as TranslateEntity/PositionEntity, which just alters the entity's matrix!)",
        "c_syntax": "void TranslateMesh(TMesh mesh, TVec3 &position)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "UpdateMesh",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/meshes/updatemesh-r307",
        "description": "Updates the mesh AABB, vertex arrays, and collision. This should be called any time a mesh is modified.",
        "c_syntax": "void UpdateMesh( TMesh mesh )",
        "cpp_syntax": "void Mesh::Update( void )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Models",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/",
    "members": [
      {
        "name": "Lua script reference",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/script/",
        "description": null,
        "c_syntax": null,
        "cpp_syntax": null,
        "example": null
      },
      {
        "name": "GetModelDetail",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/getmodeldetail-r323",
        "description": "This returns the current model detail level. This is the value specified when calling ModelDetail(detail). Default is 0.",
        "c_syntax": "int GetModelDetail(void)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "LoadModel",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/loadmodel-r319",
        "description": "Loads a model from the specified path or name. Models can be loaded by specifying the full or relative file path. Models can also be loaded from registered directories by specifying just the file name, with no extension and the prefix \"abstract::\". For example, C:\\Program Files\\Leadwerks\\Engine\\Meshes\\oildrum.md3 and abstract::oildrum.gmf will both load the same file. (See File System)\nIf a model with the specified filename has already been loaded, it'll return a reference to that to avoid loading assets twice.",
        "c_syntax": "TModel LoadModel( str name, TEntity parent = NULL )",
        "cpp_syntax": "Model::Model( const_str path, const TEntity = 0 )\nvirtual void Model::Load( const_str path, const TEntity = 0 )",
        "example": "\n\n"
      },
      {
        "name": "ModelDetail",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/modeldetail-r322",
        "description": "This adds the specified number to any calculated LoD level. E.g using 1 makes the second-highest LOD level the highest (the \"...LOD1.gmf\" mesh will be used when the camera is being in the lowest LOD distance).\nThis can be used to reduce model detail when rendering reflections or as a global setting (that could be exposed to the end user) for model detail.\nDefault is 0.",
        "c_syntax": "void ModelDetail(int detail)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "ModelName",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/modelname-r321",
        "description": "Retrieves a model's loading path. This is not necessarily the one the user specified, but rather the corrected unique path the engine assigns.",
        "c_syntax": "str ModelName( TModel model )",
        "cpp_syntax": "std::string Model::GetModelName( void ) const",
        "example": "\n\n"
      },
      {
        "name": "SetModelLODDistance",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/models/setmodelloddistance-r320",
        "description": "Sets the distance at which the LOD meshes are substituted. The index parameter (values 0-7) tells which LOD level is to be set.",
        "c_syntax": "void SetModelLODDistance( TModel model, flt distance, int index=0 )",
        "cpp_syntax": "void Model::SetLODDistance( flt distance, int index )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Networking",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/",
    "members": [
      {
        "name": "BroadcastPacket",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/broadcastpacket-r332",
        "description": "Broadcasts a packet to all peers of a host. C/C++: The packet will be freed from memory and cannot be reused.",
        "c_syntax": "void BroadcastPacket( THost host, TPacket packet, int channel=0, int flags=PACKET_SEQUENCED )",
        "cpp_syntax": "The packet will be freed from memory and cannot be reused.SyntaxC:\nvoid BroadcastPacket( THost host, TPacket packet, int channel=0, int flags=PACKET_SEQUENCED )C++:\nvoid Host::BroadcastPacket( const Packet& packet, int channel = 0, int flags = PACKET_SEQUENCED )",
        "example": "\n\n"
      },
      {
        "name": "ConnectHost",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/connecthost-r327",
        "description": "Connects to a host, and returns a peer object.",
        "c_syntax": "TPeer ConnectHost( THost host, int ip, int port )",
        "cpp_syntax": "TPeer Host::Connect( const_str ip, int port )",
        "example": "\n\n"
      },
      {
        "name": "CreateHost",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/createhost-r326",
        "description": "Creates a network host. A host is the local computer.",
        "c_syntax": "THost CreateHost( int ip=0, int port=7777, int players=32)",
        "cpp_syntax": "Host::Host( const THost host = 0 )\nHost::Host( int ip = 0, int port = 7777, int players = 32 );\nvirtual bool Host::Create( int ip = 0, int port = 7777, int players = 32 )",
        "example": "\n\n"
      },
      {
        "name": "CreatePacket",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/createpacket-r337",
        "description": "Creates a new packet. A packet is a chunk of data one computer sends to another.",
        "c_syntax": "TPacket CreatePacket( void )",
        "cpp_syntax": "Packet::Packet( const TPacket p = 0 )\nPacket::Packet( const CreateMode& mode )\nvirtual bool Packet::Create( void )",
        "example": "\n\n"
      },
      {
        "name": "DisconnectHost",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/disconnecthost-r330",
        "description": "Disconnects a peer from a host.",
        "c_syntax": "void DisconnectHost( THost host, TPeer peer, int force=false )",
        "cpp_syntax": "void Host::Disconnet( TPeer peer, bool force = false )",
        "example": "\n\n"
      },
      {
        "name": "Eof",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/eof-r351",
        "description": "Returns 1 if the stream position is at the end of the stream.",
        "c_syntax": "int Eof( TPacket packet )",
        "cpp_syntax": "bool Stream::IsEof( void ) const",
        "example": "\n\n"
      },
      {
        "name": "FreeHost",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/freehost-r334",
        "description": "Frees a host from memory.",
        "c_syntax": "void FreeHost(THost host)",
        "cpp_syntax": "void Host::Free()\nHost::~Host(void)",
        "example": "\n\n"
      },
      {
        "name": "FreePacket",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/freepacket-r338",
        "description": "Frees a packet. Only received packets need to be freed. Packets sent to other computers are freed automatically when sent or broadcast.",
        "c_syntax": "TPacket FreePacket( void )",
        "cpp_syntax": "void Packet::Free( void ) Note: See below: The destructor deals with this\nPacket::~Packet( void )",
        "example": "\n\n"
      },
      {
        "name": "GetHostIP",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/gethostip-r328",
        "description": "Returns the IP of a host.",
        "c_syntax": "int GetHostIP( THost host )",
        "cpp_syntax": "int Host::GetIP(void) const",
        "example": "\n\n"
      },
      {
        "name": "GetHostPort",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/gethostport-r329",
        "description": "Returns the port of a host.",
        "c_syntax": "int GetHostPort( THost host )",
        "cpp_syntax": "int Host::GetPort(void) const",
        "example": "\n\n"
      },
      {
        "name": "GetPeerIP",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/getpeerip-r335",
        "description": "Returns the IP of a peer. A peer is a remote computer.",
        "c_syntax": "int GetPeerIP( peer:TPeer )",
        "cpp_syntax": "int Peer::GetIP( void ) const",
        "example": "\n\n"
      },
      {
        "name": "GetPeerPort",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/getpeerport-r336",
        "description": "Returns the port of a peer.",
        "c_syntax": "int GetPeerPort( peer:TPeer )",
        "cpp_syntax": "int Peer::GetPort( void ) const",
        "example": "\n\n"
      },
      {
        "name": "PublishHost",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/publishhost-r339",
        "description": "Publishes a host on a public server list.",
        "c_syntax": "int PublishHost( THost host, str url, str name, str game=\"\" )",
        "cpp_syntax": "bool Host::Publish( const_str curl, const_str name, const_str game = \"\" )",
        "example": "\n\n"
      },
      {
        "name": "ReadByte",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/readbyte-r346",
        "description": "Reads a byte from a packet.",
        "c_syntax": "byte ReadByte( TPacket packet )",
        "cpp_syntax": "unsigned char Stream::ReadByte( void ) const",
        "example": "\n\n"
      },
      {
        "name": "ReadFloat",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/readfloat-r349",
        "description": "Reads a float (=4 byte float) from a packet.",
        "c_syntax": "float ReadFloat( TPacket packet )",
        "cpp_syntax": "float Stream::ReadFloat( void ) const",
        "example": "\n\n"
      },
      {
        "name": "ReadInt",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/readint-r348",
        "description": "",
        "c_syntax": "int ReadInt( TPacket packet )",
        "cpp_syntax": "int Stream::ReadInt( void ) const",
        "example": "\n\n"
      },
      {
        "name": "ReadLine",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/readline-r350",
        "description": "Reads a text line from a packet.",
        "c_syntax": "str ReadLine( TPacket packet )",
        "cpp_syntax": "str Stream::ReadLine( void ) const",
        "example": "\n\n"
      },
      {
        "name": "ReadShort",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/readshort-r347",
        "description": "Reads a short (=2 byte integer) from a packet.",
        "c_syntax": "short ReadShort( TPacket packet )",
        "cpp_syntax": "short int Stream::ReadShort( void ) const",
        "example": "\n\n"
      },
      {
        "name": "RequestServers",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/requestservers-r340",
        "description": "Retrieves the servers listed on a public server list.",
        "c_syntax": "str RequestServers( str url, str game=\"\" )",
        "cpp_syntax": "static std::string Engine::RequestServers( const_str curl, const_str cgame = \"\" )",
        "example": "\n\n"
      },
      {
        "name": "SendPacket",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/sendpacket-r331",
        "description": "Sends a packet from a peer to a host. C/C++: The packet will be freed from memory and cannot be reused.",
        "c_syntax": "int SendPacket( THost host, TPeer peer, TPacket packet, int channel=0, int flags=PACKET_SEQUENCED )",
        "cpp_syntax": "The packet will be freed from memory and cannot be reused.SyntaxC:\nint SendPacket( THost host, TPeer peer, TPacket packet, int channel=0, int flags=PACKET_SEQUENCED )C++:\nbool Host::SendPacket( const Peer& peer, const Packet& packet, int channel = 0, int flags = PACKET_SEQUENCED )",
        "example": "\n\n"
      },
      {
        "name": "WaitNetwork",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/waitnetwork-r333",
        "description": "Waits for the network to return an event.",
        "c_syntax": "TEvent WaitNetwork( THost host, int timeout=1000 )",
        "cpp_syntax": "void Host::WaitForEvent( Event& ev, int timeout = 1000 )",
        "example": "\n\n"
      },
      {
        "name": "WriteByte",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/writebyte-r341",
        "description": "Write a byte into a packet. These commands can be used to read from and write to packets.",
        "c_syntax": "void WriteByte( TPacket packet, byte data)",
        "cpp_syntax": "void Stream::WriteByte( byte data)",
        "example": "\n\n"
      },
      {
        "name": "WriteFloat",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/writefloat-r344",
        "description": "Writes a float (=4 byte float) into a packet.",
        "c_syntax": "void WriteFloat( TPacket packet, float data)",
        "cpp_syntax": "void Stream::WriteFloat( float data)",
        "example": "\n\n"
      },
      {
        "name": "WriteInt",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/writeint-r343",
        "description": "Write a int (=4 byte integer) into a packet.",
        "c_syntax": "void WriteInt( TPacket packet, int data)",
        "cpp_syntax": "void Stream::WriteInt( int data)",
        "example": "\n\n"
      },
      {
        "name": "WriteLine",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/writeline-r345",
        "description": "Writes a text line (=zero terminated string with Linefeed) into a packet.",
        "c_syntax": "void WriteLine( TPacket packet, str data)",
        "cpp_syntax": "void Stream::WriteLine( const_str data)",
        "example": "\n\n"
      },
      {
        "name": "WriteShort",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/networking/writeshort-r342",
        "description": "Write a short (=2 byte integer) into a packet.",
        "c_syntax": "void WriteShort( TPacket packet, short data)",
        "cpp_syntax": "void Stream::WriteShort( short data)",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Pivots",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/pivots/",
    "members": [
      {
        "name": "CreateBodyPivot",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/pivots/createbodypivot-r354",
        "description": "Creates a body pivot.",
        "c_syntax": "TBody CreateBodyPivot( TEntity parent=NULL )",
        "cpp_syntax": "Body Pivot::CreateBodyPivot(const TEntity parent = 0 )",
        "example": "\n\n"
      },
      {
        "name": "CreatePivot",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/pivots/createpivot-r353",
        "description": "Creates a new pivot entity. Pivots are standard entities that are invisible. They can be used as placeholders, parents for other entities, or other various purposes.",
        "c_syntax": "TPivot CreatePivot( TEntity parent=NULL )",
        "cpp_syntax": "Pivot::Pivot( const CreateMode& rCreateMode, const TEntity parent = 0 ) Set rCreateMode = CreateNow for instant creation\nvirtual void PivotCreate( const TEntity = 0 )",
        "example": "\n#include \"engine.h\"\nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480,0,0,0);\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity cam=CreateCamera(0);\n\tMoveEntity(cam,Vec3(0,3,-15));\n\tTurnEntity(cam,Vec3(15,0,0),0);\n \n\tTEntity Light=CreateSpotLight(150,0);\n\tEntityColor(Light,Vec4(.5,0,.9,1.0));\n\tMoveEntity(Light,Vec3(0,10,-6));\n\tTurnEntity(Light,Vec3(75,0,0),0);\n\tSetShadowmapSize(Light,1024);\n \n\tAmbientLight(Vec3(0.1));\n \n\tTEntity Pivot=CreatePivot(0);\n \n\tTEntity Box=CreateCube(0);\n\tScaleEntity(Box,Vec3(2));\n\tEntityParent(Box,Pivot,0);\n\tfor(int i=1;i<=22;i++)\n\t{\n\t\tBox=CopyEntity(Box);\n\t\tPositionEntity(Box,Vec3(0),0);\n\t\tTurnEntity(Box,Vec3(0,15,0),0);\n\t\tMoveEntity(Box,Vec3(0,0,10),1);\n\t\tEntityParent(Box,Pivot,0);\n\t}\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tTurnEntity(Pivot,Vec3(.9,1,.4),0);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tDrawText(0,0,\"FPS: %f\",FPS());\n\t\tFlip(1);\n\t}\n \n\treturn Terminate();\n}\n\n"
      }
    ]
  },
  {
    "name": "Raycasting",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/",
    "members": [
      {
        "name": "CameraPick",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/camerapick-r360",
        "description": "Performs a ray test from the specified camera screen position, and returns the closest collision. If nothing is hit, 0 will be returned. The collisionType parameter can be used to control what collision types affect the ray test. If collisionType is 0 all pickable entities will affect the ray test. The z component of the position will specify how far the ray should be cast.",
        "c_syntax": "int CameraPick(TPick *pick, TCamera camera, TVec3 &position, flt radius=0, int collisionType=0, BP pickfilter=NULL)",
        "cpp_syntax": "bool Camera::GetPick( Pick& pick, const TVec3& pos, flt radius = 0.0f, const CollisionType& type = 0, *Byte filter = 0 ) const",
        "example": "\n\n"
      },
      {
        "name": "EntityPick",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/entitypick-r359",
        "description": "Performs a ray test in front of the specified entity, and returns the closest collision. If nothing is hit, Null will be returned. The collisionType parameter can be used to control what collision types affect the ray test. If collisionType is 0 all pickable entities will affect the ray test. In BlitzMax this will return a list of all collisions that occured. In Leadwerks Script and C++ this will return the first hit entity.",
        "c_syntax": "int EntityPick(TPick *pick, TEntity entity, flt range=100, flt radius=0, int collisionType=0, BP pickfilter=NULL)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "EntityVisible",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/entityvisible-r357",
        "description": "Returns 1 is the specified entities have a clear line of sight, else 0 is returned. The collisionType parameter can be used to control what collision types affect the ray test. If collisionType is 0 all pickable entities will affect the ray test.",
        "c_syntax": "int EntityVisible(TEntity entity1, TEntity entity2, flt radius=0, int collisionType=0, BP pickfilter=NULL)",
        "cpp_syntax": "bool Entity::IsVisible( const Entity& ent, flt radius = 0, int collisionType = 0, Filter filter = 0 ) const",
        "example": "\n\n"
      },
      {
        "name": "Filter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/filter-r362",
        "description": "The optional Filter() [BP pickfilter argument] callback can be used for precise control of which entities are pickable. Return 1 to proceed with a pick test or 0 to skip.",
        "c_syntax": "int _stdcall Filter( TEntity entity ) \n{\n\treturn (/*entity should be tested*/) ? 1 : 0;\n}",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "LinePick",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/linepick-r358",
        "description": "Performs a ray test from point 1 to 2. If nothing is hit, 0 will be returned, otherwise 1 will be returned and the results filled into the supplied TPick object. The collisionType parameter can be used to control what collision types affect the ray test. If collisionType is 0 all pickable entities will affect the ray test. In BlitzMax this will return a TPick object.",
        "c_syntax": "int LinePick(TPick *pick, TVec3 &point1, TVec3 &point2, flt radius=0, int collisionType=0, BP pickfilter=NULL)",
        "cpp_syntax": "bool Draw::GetPick( Pick& pick, const TVec3& point1, const TVec3& point2, flt radius = 0 , const CollisionType& type = 0, *Byte filter = 0 ) const",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics(800,600);\n\tCreateWorld();\n \n\t//Create a render buffer\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a camera\n\tTCamera cam=CreateCamera();\n\tCameraClearColor(cam,Vec4(0,0,1,1));\n\tMoveEntity(cam,Vec3(0,0,-5));\n \n\t//Create a light\n\tTLight light=CreateDirectionalLight();\n\tRotateEntity(light,Vec3(65,45,0));\n \n\t//Create a mesh\n\tTMesh cube=CreateCube();\n \n\tint result;\n\tTVec3 point0;\n\tTVec3 point1;\n\tTPick pick;\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) \n\t{\n\t\t//Move the cube with arrow keys\n\t\tif (KeyDown(KEY_UP))   { MoveEntity(cube,Vec3(0,0.01,0)); }\n\t\tif (KeyDown(KEY_DOWN)) { MoveEntity(cube,Vec3(0,-0.01,0)); }\n \n\t\t//Update the world\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n\t\t//Render the scene and lighting\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t//Test and display visibility between two points\n\t\tif (LinePick(&pick,Vec3(4,0,0),Vec3(-4,0,0))) {\n\t\t\t//Display the tested line\n\t\t\tpoint0=CameraUnproject(cam,Vec3(4,0,0));\n\t\t\tpoint1=CameraUnproject(cam,Vec3(pick.X,pick.Y,pick.Z));\n\t\t\tSetColor(Vec4(1,0,0,1));\n\t\t\tDrawLine(point0.X,point0.Y,point1.X,point1.Y);\n\t\t\tSetColor(Vec4(1));\n\t\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0,\"Picked position: %f,%f,%f\",pick.X,pick.Y,pick.Z);\n\t\t\tSetBlend(BLEND_NONE);\n\t\t}\n\t\telse {\n\t\t\tpoint0=CameraUnproject(cam,Vec3(4,0,0));\n\t\t\tpoint1=CameraUnproject(cam,Vec3(-4,0,0));\n\t\t\tSetColor(Vec4(1,0,0,1));\n\t\t\tDrawLine(point0.X,point0.Y,point1.X,point1.Y);\n\t\t\tSetColor(Vec4(1));\n\t\t}\n \n\t\t//Swap the front and back buffer\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "PointVisible",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/pointvisible-r356",
        "description": "Returns 1 is the specified points have a clear line of sight, else 0 is returned. The collisionType parameter can be used to control what collision types affect the ray test. If collisionType is 0 all pickable entities will affect the ray test.",
        "c_syntax": "int PointVisible(TVec3 &point1, TVec3 &point2, flt radius=0, int collisionType=0, BP pickfilter=NULL)",
        "cpp_syntax": "bool Vector3::IsVisible( const TVec3& p1, const TVec3& p2, flt radius, int collisionType, Filter filter = 0 )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n \n\t//Create a graphics context\n\tGraphics(800,600);\n \n\t//Create a world\n\tif (!CreateWorld()) {\n\t\tMessageBoxA(0,\"Failed to create world.\",\"Error\",0);\n\t\tgoto exitapp;\n\t}\n \n\t//Create a camera\n\tTCamera cam=CreateCamera();\n\tCameraClearColor(cam,Vec4(0,0,1,1));\n\tMoveEntity(cam,Vec3(0,0,-5));\n \n\t//Create a light\n\tTLight light=CreateDirectionalLight();\n\tRotateEntity(light,Vec3(65,45,0));\n \n\t//Create a render buffer\n\tTBuffer buffer=CreateBuffer(800,600,BUFFER_COLOR|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t//Create a mesh\n\tTMesh cube=CreateCube();\n \n\tchar temp[100];\n\tint result;\n\tTVec3 point0;\n\tTVec3 point1;\n \n\t//Main loop\n\twhile(!KeyHit(KEY_ESCAPE)) {\n \n\t\t//Move the cube with arrow keys\n\t\tif (KeyDown(KEY_UP)) { MoveEntity(cube,Vec3(0,0.01,0)); }\n\t\tif (KeyDown(KEY_DOWN)) { MoveEntity(cube,Vec3(0,-0.01,0)); }\n \n\t\t//Update the world\n\t\tUpdateWorld();\n \n\t\t//Render the scene\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n \n\t\t//Render lighting\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\t//Test and display visibility between two points\n\t\tresult=PointVisible(Vec3(4,0,0),Vec3(-4,0,0));\n\t\tsprintf(temp,\"Visible: %d\",result);\n\t\tDrawText(0,0,temp);\n \n\t\t//Display the tested line\n\t\tpoint0=CameraUnproject(cam,Vec3(4,0,0));\n\t\tpoint1=CameraUnproject(cam,Vec3(-2,0,0));\n\t\tSetColor(Vec4(1,0,0,1));\n\t\tDrawLine(point0.X,point0.Y,point1.X-point0.X,point1.Y-point0.Y);\n\t\tSetColor(Vec4(1));\n \n\t\t//Swap the front and back buffer\n\t\tFlip();\n\t}\n \n\texitapp:\n\treturn Terminate();\n}\n"
      },
      {
        "name": "TPick",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/raycasting/tpick-r361",
        "description": "",
        "c_syntax": "struct TPick\n{\n\tTEntity entity;\n\tTEntity surface; // This may be null if the picked entity is not a mesh (e.g. a terrain).\n\tflt X, Y, Z;\n\tflt NX, NY, NZ;\n\tint triangle; // the number of the picked triangle\n}",
        "cpp_syntax": "struct Pick : public TPick\n{\nTVec3 GetPosition( void ) const; \nTVec3 GetNormal( void ) const;\n}",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Script",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/script/",
    "members": [

    ]
  },
  {
    "name": "Shaders",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/shaders/",
    "members": [
      {
        "name": "FreeShader",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/shaders/freeshader-r367",
        "description": "Frees the specified shader from memory.",
        "c_syntax": "void FreeShader( TShader shader )",
        "cpp_syntax": "void Shader::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "LoadShader",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/shaders/loadshader-r364",
        "description": "This command loads a shader using the specified vert and fragment files. Defines can be used to pass any special parameters to the shader. The defines string will be added to the beginning of both shader source codes. It is not necessary to specify a fragment shader path if no fragment program is needed, as is the case for most shadow shaders.\nThe defines parameter is simply a string which will be appended at the start of both vertex and fragment program source codes. This is typically used for specifying GLSL defines to load different versions of the same shader. Defines must be in the following format:#define foo value~n\n\nIt is important that the \"~n\" tag (in BlitzMax) or an end-of-line character be added at the end of each define. Multiple defines can be specified as follows:#define foo value~n#define foo2 value2~n\n\nIt is not necessary to specify a value for the define if none is needed:#define foo~n",
        "c_syntax": "TShader LoadShader ( str vertpath, str fragpath, str defines=\"\" )",
        "cpp_syntax": "Shader::Shader( const_str vertpath, const_str fragpath, const_str defines = \"\" )\nvoid Shader::Load( const_str vertpath, const_str fragpath, const_str defines = \"\" )",
        "example": "#define foo value~n"
      },
      {
        "name": "SetShader",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/shaders/setshader-r365",
        "description": "Sets the specified shader as the active shader.",
        "c_syntax": "void SetShader( TShader shader )",
        "cpp_syntax": "void Shader::Set( void )",
        "example": "\n\n"
      },
      {
        "name": "SetShader...",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/shaders/setshader-r366",
        "description": "The SetShader... command set is used to pass a value to a shader uniform. Uniforms are stored in a map associated with the shader. A GPU sync is only required the first time a uniform is set. If the uniform does not exist in the shader, a warning will be written to the application log.",
        "c_syntax": "void SetShaderFloat(TShader shader, str uniform, float x )\nvoid SetShaderFloatArray(TShader shader, str name, flt* ar, int count=1)\nvoid SetShaderVec2(TShader shader, str uniform, TVec2 v )\nvoid SetShaderVec3(TShader shader, str uniform, TVec3 v )\nvoid SetShaderVec4(TShader shader, str uniform, TVec4 v )\nvoid SetShaderInt(TShader shader, str uniform, int i )\nvoid SetShaderIntArray(TShader shader, str name, int* ar, int count=1)\nvoid SetShaderMat3(TShader shader, str uniform, mat3 mat )\nvoid SetShaderMat4(TShader shader, str uniform, mat4 mat )",
        "cpp_syntax": "void Shader::Set( const_str name, int value );\nvoid Shader::Set( const_str name, flt value );\nvoid Shader::Set( const_str name, const TVec2& value, int count=1 );\nvoid Shader::Set( const_str name, const TVec3& value, int count=1 );\nvoid Shader::Set( const_str name, const TVec4& value, int count=1 );\nvoid Shader::Set( const_str name, const TVec9& value, int count=1 );\nvoid Shader::Set( const_str name, const TVec16& value, int count=1 );\nvoid Shader::Set( const_str name, const int* pArray, int count=1 );\nvoid Shader::Set( const_str name, const flt* pArray, int count=1 );",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Sound",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/",
    "members": [
      {
        "name": "CreateListener",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/createlistener-r280",
        "description": "Creates a new listener entity.",
        "c_syntax": "TListener CreateListener( TEntity parent=NULL )",
        "cpp_syntax": "Listener::Listener( const CreateMode& rCreateMode, const TEntity parent = 0 )\nvirtual void Listener::Create( const TEntity parent = 0 )",
        "example": "\n\n"
      },
      {
        "name": "CreateSource",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/createsource-r372",
        "description": "Creates a source with the specified sound and returns it without playing the sound. This allows you to set advanced properties before playing the sound. Possible flags/modes are:SOURCE_EAX (makes the sound play one single time)SOURCE_LOOP (makes the sound loop)",
        "c_syntax": "TSource CreateSource( TSound sound, int flags=SOURCE_EAX )",
        "cpp_syntax": "void Create( const Sound& sound, int mode )",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics (640,480, 0, 0, 0);\n \n\tTEntity   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTCamera Camera = CreateCamera(0);// Camera\n\tMoveEntity   (Camera, Vec3(0,2,-2) );\n\tRotateEntity (Camera, Vec3(20,0,0) ,0);\n \n\tTEntity   Light = CreateDirectionalLight(0);// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n \n\tfloat anglepos = 0;\n\tfloat dist = 10;\n \n\tTEntity cube   = CreateCube(0); \n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTSound sound = LoadSound(\"abstract::ambient_lighthum.ogg\"); // Sound\n \n\tTSource source = CreateSource(sound,SOURCE_LOOP);//Source\n\tPlaySource(source);\n\tSetSourceRange(source,25);\n \n\tTListener listener = CreateListener(Camera);//Listener\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity(cube, Vec3(sin(anglepos*M_PI/180.0)*dist,0,cos(anglepos*M_PI/180.0)*dist));\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tanglepos -= 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tanglepos += 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_UP)){\n\t\t\tdist += 0.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tdist -= 0.2;\n\t\t}\n \n\t\tSetSourcePosition(source,EntityPosition(cube));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n \n\t\tDrawText (0,0,\"Use the arrow keys to move the cube playing a sound.\");\n\t\tSetBlend   (0);\n\t\tFlip   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "EAXEffect",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/eaxeffect-r383",
        "description": "Enables an EAX effect, as listed below:EAX_NORMAL = 0EAX_GENERIC = 1EAX_PADDEDCELL = 2EAX_ROOM = 3EAX_BATHROOM = 4EAX_LIVINGROOM = 5EAX_STONEROOM = 6EAX_AUDITORIUM = 7EAX_CONCERTHALL = 8EAX_CAVE = 9EAX_ARENA = 10EAX_HANGAR = 11EAX_CARPETTEDHALLWAY = 12EAX_HALLWAY = 13EAX_STONECORRIDOR = 14EAX_ALLEY = 15EAX_FOREST = 16EAX_CITY = 17EAX_MOUNTAINS = 18EAX_QUARRY = 19EAX_PLAIN = 20EAX_PARKINGLOT = 21EAX_SEWERPIPE = 22EAX_UNDERWATER = 23EAX_DRUGGED = 24EAX_DIZZY = 25EAX_PSYCHOTIC = 26",
        "c_syntax": "void EAXEffect( int effect, flt gain=1.0 )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "EAXSupported",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/eaxsupported-r382",
        "description": "This command checks to see if EAX is supported on the user's machine, and returns the result.",
        "c_syntax": "int EAXSupported( void )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "EmitSound",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/emitsound-r370",
        "description": "This command plays a sound which originates from the position of an entity. The sound must be loaded into the engine using the LoadSound command. The range parameter specifies the range in which the sound can be heard and the volume parameter specifies the volume at which the sound should play. Only mono sounds can be spatialized. Flags are:SOURCE_EAX (makes the sound play one single time)SOURCE_LOOP (makes the sound loop)",
        "c_syntax": "void EmitSound( TEntity entity, TEntity sound, flt range=10.0, flt volume=1.0, int flags=SOURCE_EAX )",
        "cpp_syntax": "void Entity::EmitSound( const Sound& sound, flt range, flt volume, int flags )",
        "example": "\n\n"
      },
      {
        "name": "GetSourceState",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/getsourcestate-r377",
        "description": "Returns the current state the specified source. Return values are:SOURCE_STOPPEDSOURCE_PLAYINGSOURCE_PAUSED",
        "c_syntax": "int GetSourceState(TSource source)",
        "cpp_syntax": "SourceState Source::GetState( void ) const",
        "example": "\n\n"
      },
      {
        "name": "LoadSound",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/loadsound-r368",
        "description": "This command loads a sound from an audio file. The formats that the engine can load are OGG and WAV. The LoadSound function will return a handle to any previously loaded sound from the same file to avoid loading assets twice.",
        "c_syntax": "TSound LoadSound( str filename )",
        "cpp_syntax": "Sound( const std::string& filename )\nvirtual void Sound::Load( const std::string& filename )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics\t (640,480);\n \n\tTWorld\tWorld  = CreateWorld();\n \n\tTSound sound = LoadSound(\"abstract::confused.ogg\"); // Sound\n\tPlaySound(sound);\n \n\twhile(!KeyHit()) {\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "PauseSource",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/pausesource-r374",
        "description": "Pauses the specified source.",
        "c_syntax": "void PauseSource(TSource source)",
        "cpp_syntax": "void Source::Pause( void )",
        "example": "\n\n"
      },
      {
        "name": "PlaySound",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/playsound-r369",
        "description": "This command plays a sound that is loaded into the engine, using the LoadSound command. For convenience PlaySound does not return a source in the DLL, because this source would have to be freed everytime a sound was played.",
        "c_syntax": "void PlaySound(TSound sound)",
        "cpp_syntax": "void Sound::Play( void )",
        "example": "\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tGraphics\t (640,480);\n \n\tTWorld\tWorld  = CreateWorld();\n \n\tTSound sound = LoadSound(\"abstract::confused.ogg\"); // Sound\n\tPlaySound(sound);\n \n\twhile(!KeyHit()) {\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "PlaySource",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/playsource-r373",
        "description": "Plays the sound of the specified source.",
        "c_syntax": "void PlaySource(TSource source)",
        "cpp_syntax": "void Source::Play( void )",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics (640,480, 0, 0, 0);\n \n\tTEntity   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTCamera Camera = CreateCamera(0);// Camera\n\tMoveEntity   (Camera, Vec3(0,2,-2) );\n\tRotateEntity (Camera, Vec3(20,0,0) ,0);\n \n\tTEntity   Light = CreateDirectionalLight(0);// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n \n\tfloat anglepos = 0;\n\tfloat dist = 10;\n \n\tTEntity cube   = CreateCube(0); \n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTSound sound = LoadSound(\"abstract::ambient_lighthum.ogg\"); // Sound\n \n\tTSource source = CreateSource(sound,SOURCE_LOOP);//Source\n\tPlaySource(source);\n\tSetSourceRange(source,25);\n \n\tTListener listener = CreateListener(Camera);//Listener\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity(cube, Vec3(sin(anglepos*M_PI/180.0)*dist,0,cos(anglepos*M_PI/180.0)*dist));\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tanglepos -= 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tanglepos += 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_UP)){\n\t\t\tdist += 0.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tdist -= 0.2;\n\t\t}\n \n\t\tSetSourcePosition(source,EntityPosition(cube));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n \n\t\tDrawText (0,0,\"Use the arrow keys to move the cube playing a sound.\");\n\t\tSetBlend   (0);\n\t\tFlip   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "ResumeSource",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/resumesource-r375",
        "description": "Resumes (= starts from current position) the specified source.",
        "c_syntax": "void ResumeSource(TSource source)",
        "cpp_syntax": "void Source::Resume( void)",
        "example": "\n\n"
      },
      {
        "name": "SetSourcePitch",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/setsourcepitch-r379",
        "description": "Sets the pitch of the specified source.",
        "c_syntax": "void SetSourcePitch(TSource source, flt pitch=1)",
        "cpp_syntax": "void Source::SetPitch( flt pitch )",
        "example": "\n\n"
      },
      {
        "name": "SetSourcePosition",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/setsourceposition-r381",
        "description": "Sets the position of the specified source.",
        "c_syntax": "void SetSourcePosition(TSource source, TVec3 &position=Vec3(0))",
        "cpp_syntax": "void Source::SetPosition( const TVec3& pos )",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics (640,480, 0, 0, 0);\n \n\tTEntity   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTCamera Camera = CreateCamera(0);// Camera\n\tMoveEntity   (Camera, Vec3(0,2,-2) );\n\tRotateEntity (Camera, Vec3(20,0,0) ,0);\n \n\tTEntity   Light = CreateDirectionalLight(0);// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n \n\tfloat anglepos = 0;\n\tfloat dist = 10;\n \n\tTEntity cube   = CreateCube(0); \n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTSound sound = LoadSound(\"abstract::ambient_lighthum.ogg\"); // Sound\n \n\tTSource source = CreateSource(sound,SOURCE_LOOP);//Source\n\tPlaySource(source);\n\tSetSourceRange(source,25);\n \n\tTListener listener = CreateListener(Camera);//Listener\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity(cube, Vec3(sin(anglepos*M_PI/180.0)*dist,0,cos(anglepos*M_PI/180.0)*dist));\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tanglepos -= 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tanglepos += 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_UP)){\n\t\t\tdist += 0.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tdist -= 0.2;\n\t\t}\n \n\t\tSetSourcePosition(source,EntityPosition(cube));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n \n\t\tDrawText (0,0,\"Use the arrow keys to move the cube playing a sound.\");\n\t\tSetBlend   (0);\n\t\tFlip   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetSourceRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/setsourcerange-r380",
        "description": "Sets the range of the specified source.",
        "c_syntax": "void SetSourceRange(TSource source, flt range=50)",
        "cpp_syntax": "void Source::SetRange( flt range )",
        "example": "\n#include \"engine.h\"\n \n#define _USE_MATH_DEFINES\n#include \"math.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics (640,480, 0, 0, 0);\n \n\tTEntity   World  = CreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTCamera Camera = CreateCamera(0);// Camera\n\tMoveEntity   (Camera, Vec3(0,2,-2) );\n\tRotateEntity (Camera, Vec3(20,0,0) ,0);\n \n\tTEntity   Light = CreateDirectionalLight(0);// Create light\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n \n\tfloat anglepos = 0;\n\tfloat dist = 10;\n \n\tTEntity cube   = CreateCube(0); \n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n \n\tTSound sound = LoadSound(\"abstract::ambient_lighthum.ogg\"); // Sound\n \n\tTSource source = CreateSource(sound,SOURCE_LOOP);//Source\n\tPlaySource(source);\n\tSetSourceRange(source,25);\n \n\tTListener listener = CreateListener(Camera);//Listener\n \n\twhile(!KeyHit(KEY_ESCAPE))\n\t{\n\t\tPositionEntity(cube, Vec3(sin(anglepos*M_PI/180.0)*dist,0,cos(anglepos*M_PI/180.0)*dist));\n \n\t\tif(KeyDown(KEY_LEFT)){\n\t\t\tanglepos -= 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_RIGHT)){\n\t\t\tanglepos += 1.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_UP)){\n\t\t\tdist += 0.2;\n\t\t}\n \n\t\tif(KeyDown(KEY_DOWN)){\n\t\t\tdist -= 0.2;\n\t\t}\n \n\t\tSetSourcePosition(source,EntityPosition(cube));\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tSetBlend   (BLEND_ALPHA);\n \n\t\tDrawText (0,0,\"Use the arrow keys to move the cube playing a sound.\");\n\t\tSetBlend   (0);\n\t\tFlip   (1);\n\t}\n \n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "SetSourceVolume",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/setsourcevolume-r378",
        "description": "Sets the volume of the specified source. A volume of 0.0 is silent and a volume of 1.0 is normal.",
        "c_syntax": "void SetSourceVolume(TSource source, flt volume )",
        "cpp_syntax": "void Source::SetVolume( flt volume )",
        "example": "\n\n"
      },
      {
        "name": "StopSource",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/sound/stopsource-r376",
        "description": "Stops the specified source.",
        "c_syntax": "void StopSource(TSource source)",
        "cpp_syntax": "void Source::Stop( void )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "String",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/string/",
    "members": [

    ]
  },
  {
    "name": "Surfaces",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/",
    "members": [
      {
        "name": "AddTriangle",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/addtriangle-r390",
        "description": "Adds a triangle to the surface and returns the triangle index. Triangle indices are 0-based.",
        "c_syntax": "int AddTriangle( TSurface surface, int v0, int v1, int v2 )",
        "cpp_syntax": "int Surface::AddTriangle( int v0, int v1, int v2 )",
        "example": "\n\n"
      },
      {
        "name": "AddVertex",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/addvertex-r389",
        "description": "Adds a vertex to the surface and returns the vertex index. Vertex indices are 0-based.",
        "c_syntax": "int AddVertex( TSurface surface, TVec3 &position, TVec3 &normal, TVec2 &texcoord )",
        "cpp_syntax": "int Surface::AddVertex( const TVec3& pos, const TVec3& normal = Vec3(0,0,0), const TVec2& texCoord = Vec2(0,0,0) )",
        "example": "\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include \"engine.h\"\n \nTEntity CreateMeshCylinder(int segments = 16, bool closed = true, float radius = 0.5f, float height = 1.0f)\n{\n   TEntity Mesh   = CreateMesh(0);\n   TEntity surface = CreateSurface(Mesh);\n \n   // coat vertices\n\tfor(int i = 0; i <= segments; i++)\n   {\n\t  float angle = ((2 * M_PI) / segments) * i;\n\t  AddVertex(   surface,\n\t\t\t   Vec3(cos(angle) * radius, -height/2.0f, sin(angle) * radius),\n\t\t\t   Vec3(cos(angle), 0, sin(angle))\n\t\t\t   );\n \n\t  AddVertex(   surface,\n\t\t\t   Vec3(cos(angle) * radius,  height/2.0f, sin(angle) * radius),\n\t\t\t   Vec3(cos(angle), 0, sin(angle))\n\t\t\t   );\n   }\n \n   // top & bottom vertices\n   long downVerts = (segments + 1) * 2;\n\tfor(int i = 0; i <= segments; i++)\n   {\n\t  float angle = ((2 * M_PI) / segments) * i;\n\t  AddVertex(   surface,\n\t\t\t   Vec3(cos(angle) * radius, -height/2.0f, sin(angle) * radius),\n\t\t\t   Vec3(0, -1, 0)\n\t\t\t   );\n   }\n \n   long upVerts = (segments + 1) * 3;\n   for(int i = 0; i <= segments; i++)\n   {\n\t  float angle = ((2 * M_PI) / segments) * i;\n\t  AddVertex(   surface,\n\t\t\t   Vec3(cos(angle) * radius,  height/2.0f, sin(angle) * radius),\n\t\t\t   Vec3(0, 1, 0)\n\t\t\t   );\n   }\n \n   // middle vertices\n   long middleVert = 2 * ((segments + 1) * 2);\n   AddVertex(   surface,\n\t\t\tVec3(0, -height/2.0f, 0),\n\t\t\tVec3(0, -1, 0)\n\t\t   );\n \n   AddVertex(   surface,\n\t\t\tVec3(0, height/2.0f, 0),\n\t\t\tVec3(0, 1, 0)\n\t\t   );\n \n   // coat triangles\n   for(int i = 0; i < segments; i++)\n   {\n\t  long tri = i * 2;\n\t  AddTriangle(surface, tri + 0, tri + 1, tri + 2);\n\t  AddTriangle(surface, tri + 2, tri + 1, tri + 3);\n   }\n \n   // top triangles\n \n   for(int i = 0; i < segments; i++)\n   {\n\t  long tri = i;\n \n\t  AddTriangle(surface, middleVert, downVerts + tri, downVerts + tri + 1);\n \n\t  AddTriangle(surface, middleVert + 1, upVerts + tri + 1, upVerts + tri);\n   }\n \n \n\tUpdateMesh(Mesh);\n \n   return Mesh;\n}\n \n \nint main(void)\n{\n   // init\n   Initialize();\n   SetAppTitle(\"AddVertex Demo\");\n   Graphics(640,480);\n \n   // world & buffer\n   TWorld World = CreateWorld();\n   TBuffer buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n   // Camera\n   TEntity\t\tCamera = CreateCamera(0);\t\t\t   \n   MoveEntity\t(Camera, Vec3(0,0,-5) );\n \n   // Create light\n   TEntity\t   Light = CreateDirectionalLight(0);\t   \n   MoveEntity   (Light, Vec3(0,10,0) );\n   RotateEntity (Light, Vec3(45,45,0) ,0);\n   EntityColor  (Light, Vec4(1));\n   AmbientLight (Vec3(.2,.2,.3));\n \n   SetShadowQuality(0);\n   // mesh\n   TEntity cylinder = CreateMeshCylinder();\n \n   // Main Program\n   while(!KeyHit(KEY_ESCAPE) && !AppTerminate())\t\t\t\t\t\t\t   \n   {\n\t  TurnEntity(cylinder, Vec3(0.5,1,0.3));\n \n\t  // update\n\t  UpdateAppTime();\n \n\t  // render\n\t  SetBuffer(buffer);\n\t  RenderWorld(ENTITY_ALL);\n\t  SetBuffer(BackBuffer());\n\t  RenderLights(buffer);\n \n\t  // text\n\t  DrawText(0,0, \"Demonstrating AddVertex\");\n\t  // end render\n\t  Flip(1);\n   }\n \n   return Terminate();\n}\n"
      },
      {
        "name": "CountTriangles",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/counttriangles-r388",
        "description": "Returns the number of triangle in a surface.",
        "c_syntax": "int CountTriangles( TSurface surface )",
        "cpp_syntax": "int Surface::GetCountTriangles( void ) const",
        "example": "\n\n"
      },
      {
        "name": "CountVertices",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/countvertices-r387",
        "description": "Returns the number of vertices in a surface.",
        "c_syntax": "int CountVertices( TSurface surface )",
        "cpp_syntax": "int Surface::GetCountVertices( void ) const",
        "example": "\n\n"
      },
      {
        "name": "GetSurfaceMaterial",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/getsurfacematerial-r401",
        "description": "Returns the material of the specified surface.",
        "c_syntax": "TMaterial GetSurfaceMaterial(TSurface surface)",
        "cpp_syntax": "Material Surface::GetMaterial( void ) const",
        "example": "\n\n"
      },
      {
        "name": "GetVertexColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/getvertexcolor-r394",
        "description": "Retrieves a vertex diffuse color.",
        "c_syntax": "TVec4 GetVertexColor(TSurface surface, int vertex=1)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "GetVertexNormal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/getvertexnormal-r392",
        "description": "Retrieves a vertex normal.",
        "c_syntax": "TVec3 GetVertexNormal(TSurface surface, long vertex=1)",
        "cpp_syntax": "TVec3 Surface::GetVertexNormal( long index ) const",
        "example": "\n\n"
      },
      {
        "name": "GetVertexPosition",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/getvertexposition-r391",
        "description": "Retrieves a vertex position.",
        "c_syntax": "TVec3 GetVertexPosition(TSurface surface, long vertex=1)",
        "cpp_syntax": "TVec3 Surface::GetVertexPosition( long index ) const",
        "example": "\n\n"
      },
      {
        "name": "GetVertexTexCoords",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/getvertextexcoords-r393",
        "description": "Retrieves a vertex texcoords. Texcoordset can be 0 or 1.",
        "c_syntax": "TVec2 GetVertexTexCoords(TSurface surface, long vertex=1, int texcoordset=0)",
        "cpp_syntax": "TVec2 Surface::GetVertexTexCoords( long index, int texCoordSet = 0 ) const",
        "example": "\n\n"
      },
      {
        "name": "PaintSurface",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/paintsurface-r399",
        "description": "Paints the surface with the specified material.",
        "c_syntax": "void PaintSurface(TSurface surface, TMaterial material=NULL)",
        "cpp_syntax": "void Surface::Paint( const Material& material )",
        "example": "\n\n"
      },
      {
        "name": "SetVertexColor",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/setvertexcolor-r398",
        "description": "Sets a vertex' diffuse color.",
        "c_syntax": "void SetVertexColor(TSurface surface, int vertex=1, const TVec4 &color=Vec4(1))",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetVertexNormal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/setvertexnormal-r396",
        "description": "Sets a vertex normal.",
        "c_syntax": "void SetVertexNormal( TSurface surface, int index, TVec3 &normal )",
        "cpp_syntax": "void Surface::SetVertexNormal( long index, const TVec3& normal )\nvoid Surface::SetVertexNormal( long index, flt x, flt y, flt z )",
        "example": "\n\n"
      },
      {
        "name": "SetVertexPosition",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/setvertexposition-r395",
        "description": "Sets a vertex position.",
        "c_syntax": "void SetVertexPosition( TSurface surface, int index, TVec3 &position )",
        "cpp_syntax": "void Surface::SetVertexPosition( long index, const TVec3& pos )\nvoid Surface::SetVertexPosition( long index, flt x, flt y, flt z )",
        "example": "\n\n"
      },
      {
        "name": "SetVertexTexCoords",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/setvertextexcoords-r397",
        "description": "Sets a vertex texcoords. Texcoordset can be 0 or 1.",
        "c_syntax": "void SetVertexTexCoords( TSurface surface, int index, TVec2 &texcoords, int texcoordset=0 )",
        "cpp_syntax": "void Surface::SetVertexTexCoords( long index, const TVec2& texCoords, int texCoordSet = 0 )\nvoid Surface::SetVertexTexCoords( long index, flt x, flt y, int texCoordSet = 0 )",
        "example": "\n\n"
      },
      {
        "name": "TriangleVertex",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/surfaces/trianglevertex-r400",
        "description": "Returns the index of the vertex assigned the specified triangles' corner.",
        "c_syntax": "long TriangleVertex(TSurface surface, int triangle=0, int corner=0)",
        "cpp_syntax": "long Surface::TriangleVertex( int triangle = 0 , int corner = 0 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Terrain",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/",
    "members": [
      {
        "name": "BlendTerrainTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/blendterraintexture-r412",
        "description": "Sets the alpha blend for the specified layer at the given terrain point.",
        "c_syntax": "void BlendTerrainTexture(TTerrain terrain, int x, int y, flt a, int layer)",
        "cpp_syntax": "void Terrain::BlendTexture( int x, int y, flt a, int layer )",
        "example": "\n\n"
      },
      {
        "name": "CreateTerrain",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/createterrain-r403",
        "description": "Creates a new terrain. A power-of-two size must be used for the resolution or the command will fail and return Null. To further scale the terrain, use the ScaleEntity command.",
        "c_syntax": "TTerrain CreateTerrain( int resolution=2048 )",
        "cpp_syntax": "Terrain::Terrain( TEntity ent )\nTerrain::Terrain( int resolution = 2048 )\nvirtual void Create( int resolution = 2048 )",
        "example": "\n\n"
      },
      {
        "name": "LoadTerrainAlphamap",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/loadterrainalphamap-r405",
        "description": "Loads an alpha map onto the terrain and returns 1 is successful. Alpha maps can be .dds, .png, .bmp, .jpg, or .tga format. If the index parameter is 0, the alpha map RGBA channels will be used to control the alpha levels of the first four terrain layers. If an index value greater then 0 is used, the alpha map will be loaded onto nth terrain layer.",
        "c_syntax": "int LoadTerrainAlphamap( TEntity terrain, str path, int index )",
        "cpp_syntax": "virtual bool Terrain::LoadAlphamap(const std::string& path )",
        "example": "\n\n"
      },
      {
        "name": "LoadTerrainHeightmap",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/loadterrainheightmap-r404",
        "description": "Loads a heightmap onto the terrain and returns 1 is successful. Heightmaps can be in .png, .bmp, .jpg, .tga, or 16-bit .raw format. RAW files provide the greatest precision, but must be the same dimensions as the terrain resolution. Other images will be resized to fit the terrain.",
        "c_syntax": "int LoadTerrainHeightmap( TEntity terrain, str path )",
        "cpp_syntax": "virtual bool Terrain::LoadHeightmap( const std::string& path )",
        "example": "\n\n"
      },
      {
        "name": "SaveTerrainAlphamap",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/saveterrainalphamap-r419",
        "description": "Saves an alpha map onto the terrain and returns 1 is successful. Alpha maps can be .png, .bmp, .jpg, or .tga format. If the index parameter is 0, the alpha map RGBA channels will be retrieved from the alpha levels of the first four terrain layers. If an index value greater then 0 is used, the alpha map will be saved from the nth terrain layer.",
        "c_syntax": "int SaveTerrainAlphamap( TEntity terrain, str path, int index )",
        "cpp_syntax": "virtual bool Terrain::SaveAlphamap( const std::string& path ) const",
        "example": "\n\n"
      },
      {
        "name": "SaveTerrainHeightmap",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/saveterrainheightmap-r417",
        "description": "Saves a heightmap onto the terrain and returns 1 is successful. Heightmaps can be in .png, .bmp, .jpg, .tga, or 16-bit .raw format. RAW files provide the greatest precision.",
        "c_syntax": "int SaveTerrainHeightmap( TEntity terrain, str path )",
        "cpp_syntax": "virtual bool Terrain::SaveHeightmap( const std::string& path ) const",
        "example": "\n\n"
      },
      {
        "name": "SaveTerrainNormalmap",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/saveterrainnormalmap-r418",
        "description": "Saves a normal map onto the terrain and returns 1 is successful. Normal maps can be .png, .bmp, .jpg, or .tga format.",
        "c_syntax": "int SaveTerrainNormalmap( TEntity terrain, str path )",
        "cpp_syntax": "virtual bool Terrain::SaveNormalmap( const_str path ) const",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterrainheight-r407",
        "description": "Sets the terrain height at the specified grid point. Height should be a number between 0 and 1.",
        "c_syntax": "void SetTerrainHeight( TEntity terrain, long x, long y, flt height )",
        "cpp_syntax": "void Terrain::SetHeight( int x, int y, flt height )",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterraintexture-r408",
        "description": "Sets the terrain texture. If index is 0 the diffuse texture will be specified. If index is 1 the normal map will be specified. Layer can range from 0 to 4.",
        "c_syntax": "void SetTerrainTexture(TTerrain terrain, TTexture texture, int index = 0, int layer = 0)",
        "cpp_syntax": "void Terrain::SetTexture( const Texture& texture, int index, int layer )",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainTextureConstraints",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterraintextureconstraints-r413",
        "description": "Constrains texture layers so they will only appear within certain height and slope ranges. This will be AND combined with the layer's alpha map.",
        "c_syntax": "void SetTerrainTextureConstraints(TTerrain terrain, flt minslope, flt maxslope, flt minheight, flt maxheight, int layer)",
        "cpp_syntax": "void Terrain::SetTextureConstraints( flt minslope, flt maxslope, flt minheight, flt maxheight, int layer)",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainTextureMappingMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterraintexturemappingmode-r411",
        "description": "Sets the terrain texture mapping mode for the specified texture layer. Modes are:\n0 - horizontal\n1 - vertical",
        "c_syntax": "void SetTerrainTextureMappingMode(TTerrain terrain, int mode, int layer = 0)",
        "cpp_syntax": "void Terrain::SetTextureMappingMode( int mode, int layer )",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainTextureRotation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterraintexturerotation-r410",
        "description": "Rotates the specified texture layer.",
        "c_syntax": "void SetTerrainTextureRotation(TTerrain terrain, flt rotation, int layer = 0)",
        "cpp_syntax": "void Terrain::SetTextureRotation( flt rotation, int layer )",
        "example": "\n\n"
      },
      {
        "name": "SetTerrainTextureScale",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setterraintexturescale-r409",
        "description": "Scales the specified texture layer.",
        "c_syntax": "void SetTerrainTextureScale(TTerrain terrain, flt scale, int layer = 0)",
        "cpp_syntax": "void Terrain::SetTextureScale( flt scale, int layer )",
        "example": "\n\n"
      },
      {
        "name": "SetVegetationShadowMode",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/setvegetationshadowmode-r421",
        "description": "Enable or disable vegetation shadows for all terrains. To control the shadows of each vegetation layer, use the Vegetation Shadows setting in Editor.",
        "c_syntax": "void SetVegetationShadowMode( int mode )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TerrainDetail",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/terraindetail-r420",
        "description": "This will add the specified value to any calculated terrain LoD level. E.g. using 1 will make the usually second-highest LoD level the highest (the one used when looking at terrain closely).\nThis can be used to reduce terrain detail when rendering reflections (saving lots of polygons). It's not recommended to use this as a quality setting exposed to the end user since reducing the terrain resolution might cause visual errors (object floating in the air etc...), but this is not so noticeable in a reflection.\nDefault is 0.",
        "c_syntax": "void TerrainDetail( int detail )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "TerrainElevation",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/terrainelevation-r415",
        "description": "Retrieves the terrain height at the specified position. The height will be interpolated between the nearest 4 grid points to provide a very close estimation of the terrain height at any given position.",
        "c_syntax": "flt TerrainElevation( TEntity terrain, flt x, flt y )",
        "cpp_syntax": "flt Terrain::GetElevation( flt x, flt y ) const",
        "example": "\n\n"
      },
      {
        "name": "TerrainHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/terrainheight-r414",
        "description": "Retrieves the relative terrain height at the specified grid point. This is a value between 0 and 1.",
        "c_syntax": "flt TerrainHeight( TEntity terrain, int x, int y )",
        "cpp_syntax": "flt Terrain::GetHeight( int x, int y ) const",
        "example": "\n\n"
      },
      {
        "name": "TerrainNormal",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/terrainnormal-r416",
        "description": "Retrieves the terrain normal at the specified position. The normal will be interpolated between the nearest 4 grid points to provide a very close estimation of the terrain normal at any given position.",
        "c_syntax": "TVec3 TerrainNormal( TTerrain terrain, flt x, flt y )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "UpdateTerrainNormals",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/terrain/updateterrainnormals-r406",
        "description": "Updates all terrain point normals.",
        "c_syntax": "void UpdateTerrainNormals( TEntity terrain, int x=-1, int y=-1, int width=1, int height=1 )",
        "cpp_syntax": "void Terrain::UpdateNormals( int x=-1, int y=-1, int width=1, int height=1 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Textures",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/",
    "members": [
      {
        "name": "AFilter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/afilter-r433",
        "description": "Sets the anisotropic filter. The mode can be from 1 to the value returned by MaxAFilter().",
        "c_syntax": "void AFilter( int mode=4 )",
        "cpp_syntax": "void Engine::SetAFilter( int value = 4 )",
        "example": "\n\n"
      },
      {
        "name": "BindTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/bindtexture-r431",
        "description": "Binds the specified texture to the specified texunit of the current shader (i.e., texunit 0 is texture0 in a shader).",
        "c_syntax": "void BindTexture( TTexture texture, int texunit )",
        "cpp_syntax": "void Texture::Bind( int texunit )",
        "example": "\n\n"
      },
      {
        "name": "ClampTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/clamptexture-r426",
        "description": "Sets clamping for the axis of a texture (this does the same as the material setting \"clampn=x,y,z\" but on a per texture, in-code base).",
        "c_syntax": "void ClampTexture(TTexture texture, int x=1, int y=1, int z=1)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "CreateTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/createtexture-r423",
        "description": "Creates a new texture. The following formats can be created:TEXTURE_ALPHA,TEXTURE_ALPHA8\t - 8-bit AlphaTEXTURE_LUMINANCE,TEXTURE_LUMINANCE8\t- 8-bit LuminanceTEXTURE_RGB, TEXTURE_RGB8\t - 24-bit RGBTEXTURE_RGBA, TEXTURE_RGBA8\t - 32-bit RGBATEXTURE_DEPTH, TEXTURE_DEPTH24\t - Depth textureTEXTURE_RGBA16\t - 64-bit RGBA (use for high-quality normal buffer)TEXTURE_FLOAT\t - Float texture (16-32 bit depending on hardware) (can be used for displacement mapping)TEXTURE_RGBA32\t - 128-bit RGBA. It is unlikely this format is needed for any purposeTEXTURE_RG11B10 - 32-bit RGBA float texture. This allows you to use high-resolution RGB images, though it may not be supported on all hardware\nOnly the following formats can be bound to a buffer and rendered to on all hardware:TEXTURE_RGB, TEXTURE_RGB8TEXTURE_RGBA, TEXTURE_RGBA8TEXTURE_DEPTH, TEXTURE_DEPTH24TEXTURE_RGBA16TEXTURE_RGBA32TEXTURE_FLOAT\nFor vertex texture lookups, TEXTURE_FLOAT or TEXTURE_RGBA32 should be used. In addition, NVidia Shader Model 4 graphics cards may use the TEXTURE_RGBA16 format.",
        "c_syntax": "TTexture CreateTexture( int width, int height, int format=TEXTURE_RGBA )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "FreeTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/freetexture-r430",
        "description": "Releases the handle of a texture from memory. The texture will be deleted when it is no longer in use.",
        "c_syntax": "void FreeTexture( TTexture texture )",
        "cpp_syntax": "void Texture::Free( void ) Note: Also called from destructor",
        "example": "\n\n"
      },
      {
        "name": "LoadTexture",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/loadtexture-r424",
        "description": "Loads a texture from a texture file. This command increments the texture reference count. To allow memory management to delete the resource, the reference count must be decremented by calling FreeTexture(texture). Textures can be loaded from .dds and .raw (16-bit) formats. If a texture with the specified filename has already been loaded, it'll return a reference to that to avoid loading assets twice.",
        "c_syntax": "TTexture LoadTexture( str filepath )",
        "cpp_syntax": "Texture::Texture( const_str filepath )\nvoid Texture::Load( str filepath )",
        "example": "\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n \n\tTTexture texture = LoadTexture(\"abstract::door1.dds\");\n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tDrawImage(texture);\n \n\t\tDrawText (0,0,\"Simply drawing an image that comes with the SDK.\");\n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "MaxAFilter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/maxafilter-r434",
        "description": "Returns the maximum supported anisotropic filter on the user's machine.",
        "c_syntax": "int MaxAFilter( void )",
        "cpp_syntax": "int Engine::GetMaxAFilter( void )",
        "example": "\n\n"
      },
      {
        "name": "MaxTextureUnits",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/maxtextureunits-r435",
        "description": "Returns the maximum supported texture units on the user's machine.",
        "c_syntax": "int MaxTextureUnits( void )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetTextureQuality",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/settexturequality-r436",
        "description": "Sets the quality of loaded textures. If quality is one, textures will be loaded at full resolution. If quality is two, textures will be loaded at half resolution. If quality is three, textures will be loaded at one-fourth resolution. .dds files must contain mipmaps for this setting to have an effect.",
        "c_syntax": "void SetTextureQuality( int quality )",
        "cpp_syntax": "void Engine::SetTextureQuality( int quality )",
        "example": "\n\n"
      },
      {
        "name": "TextureFilter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/texturefilter-r425",
        "description": "ets the texture filter for the specified texture. Texture filter modes are below.TEXFILTER_PIXELTEXFILTER_SMOOTHTEXFILTER_MIPMAP",
        "c_syntax": "void TextureFilter( TTexture texture, int filter )",
        "cpp_syntax": "void Texture::SetFilter( const TextureFilters& filter ) Where filter is one of Pixel, Smooth or MipMap",
        "example": "\n#include \"engine.h\"\n \nTTexture generateImage(int width, int height)\n{\n\tTBuffer lastBuffer = CurrentBuffer();\n \n\tstatic TBuffer buffer = CreateBuffer(width, height, BUFFER_COLOR); \n\tSetBuffer(buffer);\n \n\tSetColor(Vec4(0));\n\tClearBuffer();\n \n\t// image generation, a #grid\n\tSetColor(Vec4(1));\n\tfor(int i = 0; i < width; i +=5)\n\t{\n\t\tDrawLine(i,0,0,height);\n\t}\n \n\tfor(int i = 0; i < height; i +=5)\n\t{\n\t\tDrawLine(0,i,width,0);\n\t}\n\t// end image generation\n \n\tTTexture image = GetColorBuffer(buffer);\n \n\tSetBuffer(lastBuffer);\n \n\treturn image;\n}\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"TextureFilter Demo\");\n\tGraphics(3*150,512 + 32);\n\tCreateWorld();\n \n \n\tTTexture texture1 = generateImage(512,512);\n\tTTexture texture2 = LoadTexture(\"abstract::door1.dds\");\n \n \n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tint x = (150 - 128)/2;\n \n\t\tDrawText (x,0,\"TEXFILTER_MIPMAP\");\n\t\tTextureFilter(texture1,TEXFILTER_MIPMAP);\n\t\tTextureFilter(texture2,TEXFILTER_MIPMAP);\n\t\tDrawImage(texture1,x,32\t\t ,128,256);\n\t\tDrawImage(texture2,x,32 + 256,128,256);\n\t\tx += 150;\n \n\t\tDrawText (x,0,\"TEXFILTER_PIXEL\");\n\t\tTextureFilter(texture1,TEXFILTER_PIXEL);\n\t\tTextureFilter(texture2,TEXFILTER_PIXEL);\n\t\tDrawImage(texture1,x,32\t\t ,128,256);\n\t\tDrawImage(texture2,x,32 + 256,128,256);\n\t\tx += 150;\n \n\t\tDrawText (x,0,\"TEXFILTER_SMOOTH\");\n\t\tTextureFilter(texture1,TEXFILTER_SMOOTH);\n\t\tTextureFilter(texture2,TEXFILTER_SMOOTH);\n\t\tDrawImage(texture1,x,32\t\t ,128,256);\n\t\tDrawImage(texture2,x,32 + 256,128,256);\n \n\t\tFlip();\n\t}\n \n\treturn Terminate();\n}\n\n"
      },
      {
        "name": "TextureHeight",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/textureheight-r428",
        "description": "Returns the height of the specified texture.",
        "c_syntax": "int TextureHeight( TTexture texture )",
        "cpp_syntax": "int Texture::GetHeight( void ) const",
        "example": "\n\n"
      },
      {
        "name": "TextureName",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/texturename-r429",
        "description": "Returns the name of the specified texture.",
        "c_syntax": "str TextureName( TTexture texture )",
        "cpp_syntax": "std::string Texture::GetName( void ) const",
        "example": "\n\n"
      },
      {
        "name": "TextureWidth",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/texturewidth-r427",
        "description": "Returns the width of the specified texture.",
        "c_syntax": "int TextureWidth( TTexture texture )",
        "cpp_syntax": "int Texture::GetWidth( void ) const",
        "example": "\n\n"
      },
      {
        "name": "TFilter",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/textures/tfilter-r432",
        "description": "Sets trilinear filtering mode. 1 enables trilinear filtering and 0 disables it.",
        "c_syntax": "void TFilter( int mode=1 )",
        "cpp_syntax": "void Engine::SetTFilter( int value = 1 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Timing",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/",
    "members": [
      {
        "name": "AppSpeed",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/appspeed-r440",
        "description": "Returns the current application speed. Movement values can be multiplied by this value for framerate-independent motion. If the world update speed is slower than 60 updates per second, AppSpeed() will return a value higher than 1.0 to compensate. If the program is running faster than 60 UPS, a value lower than 1.0 will be returned.",
        "c_syntax": "flt AppSpeed( void )",
        "cpp_syntax": "float Engine::GetSpeed( void ) const",
        "example": "\n//Demonstrating the timing commands.\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Timing Commands\");\n\tGraphics(640,480);\n\tCreateWorld(); TCamera cam = CreateCamera(); CameraClearMode(cam,0);\n \n\tbool paused = false;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n \n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(paused) ResumeApp();\n\t\t\telse PauseApp();\n\t\t\tpaused = !paused;\n\t\t}\n \n\t\tSetColor(Vec4(0));\n\t\tDrawRect(0,0,GraphicsWidth(),100);\n\t\tSetColor(Vec4(1));\n\t\tint currentLine = 0;\n\t\tDrawText (0,currentLine*12,\"AppSpeed() = %f\",AppSpeed()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"AppTime() = %f\",AppTime()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"UPS() = %f\",UPS()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"FPS() = %f\",FPS()); currentLine++;  // FPS is no real engine command, should not be called more than once per loop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and can be replaced with UPS for most situations.\n \n\t\tDrawText (0,currentLine*12,\"Press SPACE to toggle application time pause. Current: %s\",paused ? \"Paused\" : \"Running\"); currentLine++;\n \n\t\tFlip(0);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "AppSuspended",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/appsuspended-r444",
        "description": "Returns 1 if the application is suspended (e.g. if the window is out of focus).",
        "c_syntax": "int AppSuspended( void )",
        "cpp_syntax": "int Engine::IsSuspended( void )Example\n//This",
        "example": "\n//This example demonstrates AppSuspended\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppSuspended\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\twhile(!KeyHit(KEY_ESCAPE) )\n\t{\n\t\tUpdateAppTime();\n \n\t\tif(!AppSuspended())\n\t\t{\n\t\t\tTurnEntity(cube, Vec3(1,2,3), 0);\n\t\t}\n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "AppTime",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/apptime-r439",
        "description": "Returns the current application time.",
        "c_syntax": "flt AppTime( void )",
        "cpp_syntax": "flt Engine::GetTime( void )Example\n//This example demonstrates Apptime\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppTime\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat startTime = AppTime();\n\tfloat elapsedTime = 0;\n\tfloat currentTime;\n\tbool timerStart = false;\n\n\twhile(!KeyHit(KEY_ESCAPE) )\n\t{\n\t\tUpdateAppTime();\n\n\t\tif (KeyHit(KEY_ENTER)) \n\t\t{\n\t\t\tstartTime = AppTime(); \n\t\t\ttimerStart = true;\n\t\t}\n\t\tif(timerStart)\n\t\t{\n\t\t\tcurrentTime = AppTime();\n\t\t\telapsedTime = (currentTime - startTime) * 0.001;\n\t\t}\n \n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Timer",
        "example": "\n//This example demonstrates Apptime\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tSetAppTitle(\"AppTime\");\n\tGraphics();\n\tCreateWorld();\n\tTEntity buffer = CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\tTEntity camera = CreateCamera();\n\tMoveEntity   (camera, Vec3(0,6,-8) );\n\tRotateEntity (camera, Vec3(45,0,0) );\n \n\tTEntity cube   = CreateCube();\n\tScaleEntity  (cube,  Vec3(2,2,2) ); \n\tMoveEntity   (cube, Vec3(-1,0,0) );\n \n\tTEntity plane  = CreateCube();\n\tScaleEntity  (plane,  Vec3(100,1,100) );\n\tMoveEntity   (plane,  Vec3(0,-5,0) );\n \n\t//Create a spotlight\n\tTEntity light  = CreateSpotLight(15,0);\n\tMoveEntity   (light,  Vec3(0,5,0) );\n\tRotateEntity (light,  Vec3(90,0,0), 0);\n\tSetShadowSoftness(light,2);\n\tSetShadowmapSize(light,512);\n \n\tTMaterial lightMaterial = CreateMaterial();\n\tSetMaterialTexture(lightMaterial, LoadTexture(\"abstract::flashlight.dds\"));\n\tPaintEntity(light,lightMaterial);\n \n\tAmbientLight(Vec3(.05));\n\n\tfloat startTime = AppTime();\n\tfloat elapsedTime = 0;\n\tfloat currentTime;\n\tbool timerStart = false;\n\n\twhile(!KeyHit(KEY_ESCAPE) )\n\t{\n\t\tUpdateAppTime();\n\n\t\tif (KeyHit(KEY_ENTER)) \n\t\t{\n\t\t\tstartTime = AppTime(); \n\t\t\ttimerStart = true;\n\t\t}\n\t\tif(timerStart)\n\t\t{\n\t\t\tcurrentTime = AppTime();\n\t\t\telapsedTime = (currentTime - startTime) * 0.001;\n\t\t}\n \n\n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n\n\t\tSetBlend(BLEND_ALPHA);\n\t\t\tDrawText(0,0, \"Timer example with AppTime. Press enter to reset the Time.\");\n\t\t\tDrawText(0,15, \"%f\", elapsedTime);\n\t\tSetBlend(BLEND_NONE);\n \n\t\tFlip(1);\n\t}\n\tTerminate();\n\treturn(0);\n}\n"
      },
      {
        "name": "PauseApp",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/pauseapp-r442",
        "description": "Pauses the application time.",
        "c_syntax": "void PauseApp( void )",
        "cpp_syntax": "void Engine::Pause( void )",
        "example": "\n//Demonstrating the timing commands.\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Timing Commands\");\n\tGraphics(640,480);\n\tCreateWorld(); TCamera cam = CreateCamera(); CameraClearMode(cam,0);\n \n\tbool paused = false;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n \n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(paused) ResumeApp();\n\t\t\telse PauseApp();\n\t\t\tpaused = !paused;\n\t\t}\n \n\t\tSetColor(Vec4(0));\n\t\tDrawRect(0,0,GraphicsWidth(),100);\n\t\tSetColor(Vec4(1));\n\t\tint currentLine = 0;\n\t\tDrawText (0,currentLine*12,\"AppSpeed() = %f\",AppSpeed()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"AppTime() = %f\",AppTime()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"UPS() = %f\",UPS()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"FPS() = %f\",FPS()); currentLine++;  // FPS is no real engine command, should not be called more than once per loop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and can be replaced with UPS for most situations.\n \n\t\tDrawText (0,currentLine*12,\"Press SPACE to toggle application time pause. Current: %s\",paused ? \"Paused\" : \"Running\"); currentLine++;\n \n\t\tFlip(0);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "ResumeApp",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/resumeapp-r443",
        "description": "Resumes the application time.",
        "c_syntax": "void ResumeApp( void )",
        "cpp_syntax": "void Engine::Resume( void )",
        "example": "\n//Demonstrating the timing commands.\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Timing Commands\");\n\tGraphics(640,480);\n\tCreateWorld(); TCamera cam = CreateCamera(); CameraClearMode(cam,0);\n \n\tbool paused = false;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n \n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(paused) ResumeApp();\n\t\t\telse PauseApp();\n\t\t\tpaused = !paused;\n\t\t}\n \n\t\tSetColor(Vec4(0));\n\t\tDrawRect(0,0,GraphicsWidth(),100);\n\t\tSetColor(Vec4(1));\n\t\tint currentLine = 0;\n\t\tDrawText (0,currentLine*12,\"AppSpeed() = %f\",AppSpeed()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"AppTime() = %f\",AppTime()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"UPS() = %f\",UPS()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"FPS() = %f\",FPS()); currentLine++;  // FPS is no real engine command, should not be called more than once per loop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and can be replaced with UPS for most situations.\n \n\t\tDrawText (0,currentLine*12,\"Press SPACE to toggle application time pause. Current: %s\",paused ? \"Paused\" : \"Running\"); currentLine++;\n \n\t\tFlip(0);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "UpdateAppTime",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/updateapptime-r438",
        "description": "Updates the current application time. Should be called once per loop (needed for AppSpeed, AppTime, etc. commands) or once at the beginning of your program if you need to store off times before the main loop.",
        "c_syntax": "void UpdateAppTime( void )",
        "cpp_syntax": "void Engine::UpdateTime()",
        "example": "\nDemonstrating the timing commands.\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Timing Commands\");\n\tGraphics(640,480);\n\tCreateWorld(); TCamera cam = CreateCamera(); CameraClearMode(cam,0);\n \n\tbool paused = false;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n \n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(paused) ResumeApp();\n\t\t\telse PauseApp();\n\t\t\tpaused = !paused;\n\t\t}\n \n\t\tSetColor(Vec4(0));\n\t\tDrawRect(0,0,GraphicsWidth(),100);\n\t\tSetColor(Vec4(1));\n\t\tint currentLine = 0;\n\t\tDrawText (0,currentLine*12,\"AppSpeed() = %f\",AppSpeed()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"AppTime() = %f\",AppTime()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"UPS() = %f\",UPS()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"FPS() = %f\",FPS()); currentLine++;  // FPS is no real engine command, should not be called more than once per loop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and can be replaced with UPS for most situations.\n \n\t\tDrawText (0,currentLine*12,\"Press SPACE to toggle application time pause. Current: %s\",paused ? \"Paused\" : \"Running\"); currentLine++;\n \n\t\tFlip(0);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "UPS",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/timing/ups-r441",
        "description": "Returns the current application update speed. (Updates Per Second)",
        "c_syntax": "flt UPS( void )",
        "cpp_syntax": "float Engine::UPS(void ) const",
        "example": "\n//Demonstrating the timing commands.\n#include \"engine.h\"\n \nint main(int argc, char** argv)\n{\n\tInitialize();\n\tSetAppTitle(\"Timing Commands\");\n\tGraphics(640,480);\n\tCreateWorld(); TCamera cam = CreateCamera(); CameraClearMode(cam,0);\n \n\tbool paused = false;\n\twhile(!KeyHit(KEY_ESCAPE) && !AppTerminate())\n\t{\n\t\tRenderWorld();\n\t\tUpdateAppTime();\n\t\tUpdateWorld();\n \n \n\t\tif(KeyHit(KEY_SPACE))\n\t\t{\n\t\t\tif(paused) ResumeApp();\n\t\t\telse PauseApp();\n\t\t\tpaused = !paused;\n\t\t}\n \n\t\tSetColor(Vec4(0));\n\t\tDrawRect(0,0,GraphicsWidth(),100);\n\t\tSetColor(Vec4(1));\n\t\tint currentLine = 0;\n\t\tDrawText (0,currentLine*12,\"AppSpeed() = %f\",AppSpeed()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"AppTime() = %f\",AppTime()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"UPS() = %f\",UPS()); currentLine++;\n\t\tDrawText (0,currentLine*12,\"FPS() = %f\",FPS()); currentLine++;  // FPS is no real engine command, should not be called more than once per loop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// and can be replaced with UPS for most situations.\n \n\t\tDrawText (0,currentLine*12,\"Press SPACE to toggle application time pause. Current: %s\",paused ? \"Paused\" : \"Running\"); currentLine++;\n \n\t\tFlip(0);\n\t}\n \n\treturn Terminate();\n}\n"
      }
    ]
  },
  {
    "name": "Vehicles",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/",
    "members": [
      {
        "name": "AddTireTorque",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/addtiretorque-r448",
        "description": "Adds torque to the tire. Use this to move vehicles.",
        "c_syntax": "void AddTireTorque(TVehicle vehicle, flt torque, int tire=-1)",
        "cpp_syntax": "void Tire::AddTorque( flt angle )",
        "example": "\n\n"
      },
      {
        "name": "AddVehicleTire",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/addvehicletire-r447",
        "description": "Creates a new tire on the specified vehicle.",
        "c_syntax": "int AddVehicleTire(TVehicle vehicle, TVec3 &position=Vec3(0), flt radius=0.5f, flt suspensionLength=0.0f, flt springConstant=70.0f, flt springDamping=150.0f)",
        "cpp_syntax": "Tire::Tire( const Vehicle& veh, const Vector3& pos, const Vector3& pin, flt radius, flt suspensionLenght = 0.0f, flt springConstant = 70.0f, flt springDamping = 150.0f )\nvirtual void Tire::Create( const Vehicle& veh, const Vector3& pos, const Vector3& pin, flt radius, flt suspensionLenght = 0.0f, flt springConstant = 70.0f, flt springDamping = 150.0f )",
        "example": "\n\n"
      },
      {
        "name": "CreateVehicle",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/createvehicle-r446",
        "description": "Creates a new vehicle constraint on the specified body. You must set the chassis body mass to non-zero before creating the vehicle.",
        "c_syntax": "TVehicle CreateVehicle( TBody chassis )",
        "cpp_syntax": "Vehicle::Vehicle( const Body& rBody )\nvirtual void Vehicle::Create( const Body& rBody )",
        "example": "\n\n"
      },
      {
        "name": "GetTireMatrix",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/gettirematrix-r450",
        "description": "Returns the matrix of the specified tire. Tires start from index 0.",
        "c_syntax": "TVec16 GetTireMatrix( TVehicle vehicle, int tire=0 )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetSteerAngle",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/setsteerangle-r449",
        "description": "Sets a tire's steering angle. Use this to steer a vehicle.",
        "c_syntax": "void SetVehicleSteerAngle(TVehicle vehicle, flt angle, int tire=-1)",
        "cpp_syntax": "void Tire::SetAngle( flt angle )",
        "example": "\n\n"
      },
      {
        "name": "TireIsAirborne",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/vehicles/tireisairborne-r451",
        "description": "Returns if the specified tire is airborne. Tires start from index 0.",
        "c_syntax": "int TireIsAirborne( TVehicle vehicle, int tire=0 )",
        "cpp_syntax": "bool Vehicle::IsTireAirborne( int tire = 0 )",
        "example": "\n\n"
      }
    ]
  },
  {
    "name": "Worlds",
    "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/",
    "members": [
      {
        "name": "ClearWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/clearworld-r457",
        "description": "Clears all objects from the current world but leaves the world's memory intact.",
        "c_syntax": "void ClearWorld(void)",
        "cpp_syntax": "void World::Clear( void )",
        "example": "\n\n"
      },
      {
        "name": "CreateWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/createworld-r453",
        "description": "Creates a new world and returns the handle to it. If the world fails to load required shaders, initialize physics or sound, Null will be returned (C++: World::IsValid() will return false). This also sets the newly created world as the current world. This has to be called at least once before performing any drawing or entity/buffer creation. It is typically the first command called right after Graphics().",
        "c_syntax": "TWorld CreateWorld()",
        "cpp_syntax": "World::IsValid() will return false). This also sets the newly created world as the current world. This has to be called at least once before performing any drawing or entity/buffer creation. It is typically the first command called right after Graphics().SyntaxC:\nTWorld CreateWorld()C++:\nWorld::World( const CreateMode& mode = CREATELATER ) Set mode = CREATENOW for instant creation\nvirtual void World::Create( void )",
        "example": "\n\n"
      },
      {
        "name": "CurrentWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/currentworld-r458",
        "description": "Returns the current world.",
        "c_syntax": "TWorld CurrentWorld(void)",
        "cpp_syntax": "static World World::GetCurrent( void )",
        "example": "\n\n"
      },
      {
        "name": "FreeWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/freeworld-r465",
        "description": "Frees the specified world from memory. All objects in the world will be freed.",
        "c_syntax": "void FreeWorld( TEntity world )",
        "cpp_syntax": "void World::Free( void )",
        "example": "\n\n"
      },
      {
        "name": "LoadScene",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/loadscene-r454",
        "description": "Loads a Sandbox scene file.",
        "c_syntax": "TEntity LoadScene(str filename)",
        "cpp_syntax": "Entity World::LoadScene( str filename )",
        "example": "\n\n"
      },
      {
        "name": "RenderWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/renderworld-r456",
        "description": "Renders the specified elements of the current world to the active buffer. Possible elements is any OR-combination of these (but only the ones specified in ENTITY_RENDERABLE will actually draw something):ENTITY_MESHENTITY_EMITTERENTITY_MODELENTITY_BODYENTITY_TERRAINENTITY_BONEENTITY_CAMERAENTITY_CORONAENTITY_LISTENERENTITY_PIVOTENTITY_MESHLAYERENTITY_POINTLIGHTENTITY_SPOTLIGHTENTITY_DIRECTIONALLIGHTENTITY_ALLENTITY_RENDERABLE",
        "c_syntax": "void RenderWorld(int elements=ENTITY_RENDERABLE)",
        "cpp_syntax": "virtual void World::Render( int renderType = RENDER_ALL )",
        "example": "\n\n"
      },
      {
        "name": "SetFluidDensity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setfluiddensity-r463",
        "description": "Sets the fluid's density.",
        "c_syntax": "void SetFluidDensity(flt density=1)",
        "cpp_syntax": null,
        "example": "\n#include \"engine.h\"\n \nint main(void)\n{\n\tInitialize();\n\tGraphics(640,480);\n\tCreateWorld();\n\tTEntity buffer=CreateBuffer(640,480,BUFFER_COLOR0|BUFFER_DEPTH|BUFFER_NORMAL);\n \n\t// Camera\n\tTEntity\t\tCamera = CreateCamera(0);\t\t\t\t\n\tMoveEntity\t(Camera, Vec3(0,10,-10) );\n\tRotateEntity  (Camera, Vec3(45,0,0),0 );\n \n\t// Create light\n\tTEntity\t   Light = CreateDirectionalLight(0);\t\t\n\tMoveEntity   (Light, Vec3(0,10,0) );\n\tRotateEntity (Light, Vec3(45,45,0) ,0);\n\tEntityColor  (Light, Vec4(1));\n\tAmbientLight (Vec3(.2,.2,.3));\n \n\t// Fluid plane\n\tSetFluidPlane(Vec4(0,1,0,0), 1);\n \n \n\t//Boxes\n\tfor(int i=1; i<=50; i++)\n\t{\n\t\tTEntity\t\t cube\t = CreateCube(0);\t\t\t\n\t\tTEntity\t\t cubePhy  = CreateBodyBox(1,1,1,0);\n\t\tEntityParent   (cube,\tcubePhy,1);\n\t\tSweptCollision (cubePhy, 1);\n\t\tMoveEntity\t (cubePhy, Vec3((rand()%10)/20.0-0.25,i*1.1,(rand()%10)/20.0-0.25) );\n\t\tSetBodyMass\t(cubePhy, 1);\n\t\tEntityType\t (cubePhy, 1,0);\n\t}\n \n\tCollisions(1,1,1);  \n \n\tfloat density = 1.0;\n\tSetFluidDensity(density);\n \n\t// Main Program\n\twhile(!KeyHit(KEY_ESCAPE))\t\t\t\t\t\t\t   \n\t{\n\t\tUpdateAppTime();\n \n\t\tif(KeyDown(KEY_NUMADD))density += 0.01;\n\t\tif(KeyDown(KEY_NUMSUBTRACT))density -= 0.01;\n\t\tSetFluidDensity(density);\n \n\t\tUpdateWorld(1);\n \n\t\tSetBuffer(buffer);\n\t\tRenderWorld();\n\t\tSetBuffer(BackBuffer());\n\t\tRenderLights(buffer);\n \n\t\tDrawText(0,0,\"Demonstrating SetFluidDensity, the cubes have a density of 1 kg/m\");\n\t\tDrawText(0,12,\"Press +/- to change the fluid's density. Current = %f kg/m\", density);\n \n\t\tFlip\t   (1);\n\t}\n \n\treturn Terminate();\n}\n"
      },
      {
        "name": "SetFluidPlane",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setfluidplane-r462",
        "description": "Sets the fluid plane and it's wave amplitude. You specify the plane as a normal (the up-normal) plus an offset (the W component of the Vec4). The offset moves the plane in the opposite direction of the normal, e.g. the plane Vec4(0,1,0,-1) will be pointing upwards and have it's \"center\" at 0,0,1. The plane is infitie.\nNote: UpdateAppTime() must be called once per loop in order to make the waves move.",
        "c_syntax": "void SetFluidPlane(TVec4 &plane, flt waveamplitude=0)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetFluidViscosity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setfluidviscosity-r464",
        "description": "Sets the fluid's viscosity.",
        "c_syntax": "void SetFluidViscosity(flt linearViscosity, flt angularViscosity=-1)",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetPhysicsQuality",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setphysicsquality-r467",
        "description": "Sets the physics simulator quality mode. Modes are:Exact (most precise)Adaptive (default)Linear (fastest)",
        "c_syntax": "void SetPhysicsQuality( int mode )",
        "cpp_syntax": null,
        "example": "\n\n"
      },
      {
        "name": "SetWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setworld-r466",
        "description": "Sets the specified world as the current world. Entities are always created in the current world. Many global settings, like AmbientLight affect the current world only.",
        "c_syntax": "void SetWorld( TWorld world )",
        "cpp_syntax": "void World::Set( void )",
        "example": "\n\n"
      },
      {
        "name": "SetWorldCullRange",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setworldcullrange-r460",
        "description": "Sets the current world's entity view ranges.",
        "c_syntax": "void SetWorldCullRange( flt nearrange=50, flt mediumrange=250, flt farrange=500 )",
        "cpp_syntax": "void World::SetCullRange( flt nearrange=50, flt mediumrange=250, flt farrange=500 )",
        "example": "\n\n"
      },
      {
        "name": "SetWorldGravity",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setworldgravity-r461",
        "description": "Sets the current world's gravity.",
        "c_syntax": "void SetWorldGravity(TVec3 &gravity=Vec3(0,-9.80665f*2,0))",
        "cpp_syntax": "void World::SetGravity( const TVec3& gravity )",
        "example": "\n\n"
      },
      {
        "name": "SetWorldSize",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/setworldsize-r459",
        "description": "Resizes the current world to the given float array's values.",
        "c_syntax": "void SetWorldSize( TVec3 &size )",
        "cpp_syntax": "void World::SetSize( const TVec3& size )",
        "example": "\n\n"
      },
      {
        "name": "UpdateWorld",
        "href": "http://www.leadwerks.com/werkspace/page/Documentation/le2/_/command-reference/worlds/updateworld-r455",
        "description": "Updates physics and movement/positioning in the current world. If framerate is set to 0, the engine will update according to the application time. This is the setting that should normally be used. The framerate parameter can be used to force the program speed to execute at a constant speed, regardless of real time. This can be used to record frames at a constant speed, and combine them into movie files in an external program.\nThis command has to be called once per loop since this also runs the garbage collector! Otherwise, memory usage will constantly increase.",
        "c_syntax": "void UpdateWorld(float stepsize=1)",
        "cpp_syntax": "virtual void World::Update( float stepsize = 1 )",
        "example": "\n\n"
      }
    ]
  }
]
